Drahtlose Kommunikation
Seminar 01919 im Sommersemster 2001
Fachbereich Informatik, Praktische Informatik II

FernUniversität
Gesamthochschule in Hagen
Fachbereich Informatik
Postfach 940
D- 58084 Hagen

2

Vorwort

Vorwort
Die Welt der Rechner und Rechnernetze durchlebt derzeit einen Wandel. Während die aktuelle Situation noch durch PCs und Workstations geprägt ist, werden in Zukunft zunehmend
mobile Endgeräte wie Mobiltelefone, PDAs oder Notebooks eingesetzt. Die Grundlage für
eine Vernetzung mobiler Geräte schaffen drahtlose Netzwerke. Sie erlauben es den mobilen
Endgeräten, eine Kommunikationsverbindung zu anderen Geräten oder zu einem globalen
Netzwerk aufzubauen und zu halten. Aktuell werden drahtlose Netzwerke noch vorwiegend
zur Übertragung von Sprache genutzt, allerdings wird in Zukunft die Übertragung von Daten
in den Vordergrund rücken. Im Gegensatz zu traditionellen, stationären Rechnernetzwerken,
die sich durch eine hohe Verfügbarkeit und Stabilität auszeichnen, ist bei der drahtlosen
Kommunikation eine Fülle von Problemen zu behandeln. Einerseits sind drahtlose Übertragungstechniken in der Regel wesentlich störanfälliger, andererseits bewegen sich die Endgeräte räumlich, oft während einer laufenden Kommunikation. Spezielle Protokolle werden daher eingesetzt, um die Charakteristik drahtloser Netze vom Anwender zu verhüllen und eine
stabile und fehlerfreie Übertragung zu gewährleisten.
Die vorliegenden Ausarbeitungen sind anlässlich eines Seminars im Sommersemester 2001 an
der Fernuniversität Hagen entstanden. Im Seminar wurden die folgenden Themen behandelt:
Mobilfunknetze (z.B. GSM, UMTS), Infrarotkommunikation mit IrDA, Funkübertragung mit
DECT, Netzwerkprotokolle für drahtlose Netze (z.B. WAP) sowie Datenübertragung mit
mobilen Rechnern (OBEX, SyncML).

Jörg Roth, Juni 2001

3

Inhalt

Inhalt
GSM-Architektur, Rainer Sönksen........................................................................ 5
Die Funkschnittstelle von GSM, Alexandra Kirchmeier-Hürlimann ................. 23
Mobilfunk der dritten Generation: UMTS, Meilin Schaper................................ 37
Die Schnurlos-Technologie am Beispiel von DECT, Gerhard Dittmaier.......... 51
Infrarotkommunikation mit IrDA, Michael Diepold .......................................... 69
Der WAP-Protokollstapel, Stephan Zeindl ......................................................... 79
WML (Wireless Markup Language), Bernhard Fechner ................................... 91
Aufbau von Ad-hoc Netzwerken mit Jini, Robert Bozic................................... 113
Synchronisation mobiler Daten mit SyncML, Tobias Hoenig.......................... 127
Übertragung von Objekten mit OBEX, Johannes Magauer............................. 137

GSM-Architektur
Rainer Sönksen

Rainer.Soenksen@t-online.de
Zusammenfassung: In diesem Dokument sollen die grundsätzlichen Aspekte der GSMArchitektur dargestellt werden. Dazu gehört die Beschreibung des prinzipiellen Aufbaus,
der Komponenten, der Schnittstellen und Protokolle und der verwendeten Adressen. Ferner werden die Dienste beschrieben, die GSM anbietet. Zum besseren Verständnis, wie
die Komponenten zusammenspielen, werden exemplarisch einige Signalisierungsprozesse dargestellt. Abschließend wird noch kurz auf die Datenkommunikation im GSM
eingegangen und vor allem auf die Weiterentwicklungen im GSM der Phase 2+, die zum
Ziel haben, die Datenkommunikation zu verbessern.

1 GSM-Dienste
Die GSM-Dienste sind (wie bei ISDN) in die drei Kategorien Trägerdienste (bearer services),
Telematikdienste (teleservices) und Zusatzdienste (supplementary services) aufgeteilt. Trägerund Telematikdienste werden unter dem Oberbegriff Telekommunikationsdienste zusammengefaßt. Telekommunikationsdienste bedürfen nicht nur an der Luftschnittstelle besonderer
Maßnahmen zur Realisierung, sondern auch in der Festnetz-Infrastruktur und in der Netzübergangsvermittlungsfunktion (Interworking Function IWF) (also an der Schnittstelle zwischen Mobilfunk- und anderen Netzen wie z.B. PSTN).

1.1 Trägerdienste
Ein Trägerdienst beschreibt die Datenübertragung zwischen Endgeräten und stellt die grundlegenden technischen Möglichkeiten zur Übertragung binär vorliegender Daten zur Verfügung. Die beschriebenen Dienste befinden sich auf den Layern 1 - 3 des OSI-Schichten-Modells. Man unterscheidet Trägerdienste danach, ob die Übertragung asynchron oder synchron,
ob sie leitungs- oder paketvermittelt und ob sie transparent (d.h. nur Vorwärtsfehlerkorrektur
FEC) oder nicht-transparent (Protokoll der Sicherungsschicht heißt Radio Link Protocol
(RLP); Sicherung durch das ARQ-Verfahren (siehe 4.2.1)) geschieht. Außerdem unterscheiden sich Trägerdienste durch die Art der Weiterübertragung des Signals außerhalb des
PLMN.

1.2 Telematikdienste
Telematikdienste bauen auf den Trägerdiensten auf und beschreiben die Übertragung von
Daten mit höherschichtigen Protokollen. Sie verbinden nicht Endgeräte, sondern Benutzer.
Beispiele sind Sprache, Fax, SMS.

1.3 Zusatzdienste
Zusatzdienste sind nur zusammen mit einem Telekommunikationsdienst nutzbar und erweitern ihn in seiner Funktionalität. Viele der Zusatzdienste sind mit ISDN-Leistungsmerkmalen
identisch, einige gehen aber auch darüber hinaus. Zu den Zusatzdiensten gehören so unterschiedliche Dinge wie Rufnummeranzeige des Anrufers, Makeln und Abfrage der Gebühren.

6

GSM-Architektur

2 Das Zellularprinzip
Die Einteilung des Mobilfunknetzes in „Zellen“ soll die Wiederverwendung von Frequenzen
ermöglichen und letztendlich mehr Teilnehmer gleichzeitig bedienen.
Dafür ist das abzudeckende Gebiet in Zellen (einzelnen Funkzonen) aufgeteilt. Jede Zelle
wird von einer einzelnen Funkstationen, sogenannte Basisstationen, versorgt. In jeder Zelle
wird nur eine Teilmenge der verfügbaren Frequenzen verwendet. Keine zwei benachbarten
Zellen dürfen dieselben Frequenzen verwenden. Der Frequenzwiederholabstand D gibt an,
nach wie vielen Zellen dieselbe Frequenz wiederverwendet werden darf.
Wenn der Mobilfunkteilnehmer bei laufendem Gespräch in eine andere Zelle überwechselt,
wird die Signalisierung des Gesprächs von der neuen Basisstation übernommen. Dieser Vorgang wird Handover genannt.
Zellen sind immer gleichmäßig in der Art angeordnet, daß jede Zelle genau sechs Nachbarzellen hat (deshalb werden Zellen häufig bienenwabenförmig gezeichnet).
Zellen werden zu Clustern zusammengefaßt. Cluster können alle Frequenzen verwenden, aber
keine Frequenz in mehr als einer Zelle. Je größer ein Cluster, desto größer der Frequenzwiederholabstand und desto größer auch der Signal-Störabstand, der als Verhältnis von Nutzsignal zu Störsignal definiert ist und in dB angegeben wird. Je größer ein Cluster, desto geringer
jedoch auch die Anzahl von Kanälen und damit die Teilnehmeranzahl pro Zelle. Aus der
gleichmäßigen Anordnung der Zelle folgt, daß das kleinste Cluster aus sieben Zellen bestehen
muß.
Ein weiterer Parameter der Funknetzplanung ist die Größe der Zellradien. Durch Zellenverkleinerung läßt sich ein zellulares System an eine höhere Teilnehmerdichte adaptieren. Allerdings haben die Zellen eine minimale systembedingte Größe.

7

Rainer Sönksen

3 Die Systemarchitektur
3.1 Überblick über die Systemarchitektur

Abbildung 3.1: GSM-Systemarchitektur

Bild 3.1 zeigt die Systemarchitektur eines GSM PLMN (Public Land Mobile Network). Jeweils eine Basisstation (BTS: Base Transceiver Station) bildet eine Zelle (versinnbildlicht als
Hexagon um die BTS herum). Die eigentliche Funkverbindung wird von der BTS auf der
einen und von der Mobilstation (MS) auf der anderen Seite gebildet. Mehrere BTSen werden
von einem Base Station Controller (BSC) gesteuert. Ihr obliegt das Management der Funkkanäle. Die MSC (Mobile Switching Centre) ist die mobile Vermittlungsstation. Sie vermittelt
die Gespräche im mobilen Netz. Gespräche aus dem oder in das Festnetz werden von einem
dedizierten Vermittlungsknoten bearbeitet (GMSC: Gateway MSC). Das ISC (International
Switching Centre) übernimmt die (internationale) Vermittlung in andere Mobilfunknetze. Die
Datenbanken EIR (Equipment Identity Register), AUC (Authentication Centre), HLR (Home
Location Register) und VLR (Visitor Location Register) enthalten Daten, die zur Vermittlung
und zum Management des Netzes benötigt werden.
Die Kardinalitäten zwischen PLMN und den Komponenten bzw. zwischen verschiedenen
Komponenten eines PLMN sind wie folgt:
PLMN : EIR 1:1
PLMN : AUC 1:1
PLMN : HLR 1:1
PLMN : MSC 1:n
MSC : VLR 1:1

8

GSM-Architektur

MSC : BSC 1:n
BSC : BTS 1:n

3.2 Überblick über die Adressierung im GSM-Netz

Abbildung 3.2: Adressen und Kennziffern

•

•
•

•

•

LAI (Location Area Identity): Eine LA (Location Area) besteht aus einer Gruppe von Zellen. Diese Zellen werden von (genau) einer BSC gesteuert. Eine BSC kann jedoch mehr
als eine LA steuern. Die LAI ist die Kennziffer einer LA. Sie ist international eindeutig.
Die LAI wird regelmäßig von der BTS ausgesendet und ermöglicht es der MS, ihren aktuellen Aufenthaltsort festzustellen. Wenn sie den Wechsel der LAI feststellt, fordert sie die
Aktualisierung ihrer Aufenthaltsinformation (Location Update) in dem HLR und VLR an.
CI (Cell Identifier): Innerhalb einer LA hat jede Zelle einen eindeutigen CI. Der Global
Cell Identifier (LAI + CI) identifiziert global eindeutig jede Zelle.
BSIC (Base Transceiver Station Identity Code): Benachbarte BTSen unterscheiden sich
durch ihren BSIC; dieser wird von der BTS regelmäßig auf den Funkkanal gegeben; die
MS mißt ständig die Qualität der Verbindung zu ihrer aktuellen BTS und zu den sechs
umliegenden BTSen und schickt die Meßergebnisse zusammen mit der BSIC zur BTS zurück, die u.a. aufgrund dieser Werte eine Handover-Entscheidung trifft.
IMEI (International Mobile Equipment Identity): Wird vom Hersteller des Mobilgeräts
vergeben und kennzeichnet es international eindeutig. Im EIR sind die IMEI in drei Klassen organisiert: in derWeißen Liste sind alle Geräte registriert, in der Schwarzen Liste
sind alle gesperrten Geräte registriert (z.B. gestohlene Geräte) und in der Grauen Liste
sind fehlerhafte Geräte oder Geräte mit veralteten Softwareversionen registriert. Die IMEI
wird vom Netz üblicherweise beim Einbuchen angefordert.
IMSI (International Mobile Subscriber Identity): Die IMSI wird im Subscriber Identitiy
Module (SIM) gespeichert und kennzeichnet den Teilnehmer. Die Unterscheidung zwischen Benutzer (identifiziert durch die IMSI) und Gerät (identifiziert durch die IMEI) ist
ein bisher ausschließlich in digitalen Mobilnetzen realisiertes Konzept. Die SIM mit der
IMSI kann unabhängig vom Gerät verwendet werden. Eine Mobilstation kann nur betrie-

9

•

•

•

•

Rainer Sönksen
ben werden, wenn die SIM mit gültiger IMSI in einem Gerät mit gültiger IMEI vorhanden
ist.
MSISDN (Mobile Subscriber ISDN Number): Die MSISDN ist die Rufnummer des Mobilteilnehmers. Sie befindet sich auf der SIM und bildet eine n:1-Beziehung zur Teilnehmernummer IMSI (im ISDN beispielsweise ist die Rufnummer eine 1:1-Beziehung zum Gerät), so daß einem Teilnehmer mehrere Rufnummern zugeteilt werden können. Dies hat
den Vorteil, daß die jeweilige MSISDN zur Dienstselektion (Sprache, Daten, Fax etc.)
verwendet werden kann.
MSRN (Mobile Station Roaming Number): Die MSRN wird vom VLR vergeben und
identifiziert international eindeutig jede MSC. Die MSRN wird vom VLR an das HLR
weitergereicht; kommt nun ein Ruf für die MS, wird im HLR der MS die MSRN erfragt,
so daß der Ruf zumindest bis zur zuständigen MSC geroutet werden kann.
TMSI (Temporary Mobile Subscriber Identity): Die TMSI wird der MS vom VLR
zugewiesen; diese TMSI ist nur im Gebiet des VLR eindeutig. Weil man aus der IMSI auf
die Teilnehmeridentität schließen könnte, wird aus Sicherheitsgründen auf der Funkschnittstelle der Teilnehmer i.A. nicht mit der IMSI, sondern mit dem Tupel (TMSI, LAI)
angesprochen. Dieses Tupel ist dann ebenfalls eindeutig. Um die Vertraulichkeit noch zu
erhöhen, wird die TMSI regelmäßig gewechselt („ID Hopping“).
Die im AUC gespeicherten Daten werden bei der Authentifizierung und Chiffrierung beschrieben.

3.3 Die Komponenten eines GSM-Netzes und ihr Zusammenspiel
Das GSM-Netz wird i.A. in drei logische Subnetze mit unterschiedlichen Aufgaben unterteilt.
Das Radio Subsystem ist dabei für die funktechnischen Aspekte der Mobilstationsverbindung
zuständig. Das Network Subsystem übernimmt die vermittlungstechnischen Vorgänge. Dies
beinhaltet auch die Dienstesteuerung und ermöglicht eine Verbindungsdurchschaltung zum
oder auch vom Festnetz (ISDN, PSTN). Weiterhin gibt es das Operation and Maintenance
Subsytem, das Wartungs- und Betriebsfunktionen des Mobilfunknetzes erfüllt.
3.3.1 Radio Subsystem (RSS)
Das RSS besteht aus den nicht zur Netzinfrastruktur gehörenden Mobilstationen (MS) und
dem Funknetz BSS (Base Station Subsystem). Die BSS wiederum besteht aus dem Basisstations-Controller BSC (Base Station Controller) und den von ihm gesteuerten BTSen (Base Station Transceiver).
• Die Mobilstation (MS) wird vom Mobilteilnehmer für den Dienstzugang benutzt. Es besteht aus dem Gerät (mobile equipment ME) und der SIM. Die SIM enthält die persönlichen Daten des Teilnehmers wie die IMSI und die MSISDN und die private „Umgebung“
mit Telefonbuch und Kurznachrichtenarchiv. Auf ihr sind auch die kryptographischen Algorithmen zur Authentifizierung und Chiffrierung der Nutzdaten implementiert (siehe
5.1.2 und 5.1.3). Außerdem speichert sie netzspezifische Systeminformationen wie die
Trägerfrequenzen umliegender BTSen (siehe Beschreibung der BSIC) oder die aktuelle
LAI.
• Eine BTS stellt die Funkeinrichtung für eine GSM-Zelle dar. Jeder BTS ist ein eigener
Satz von Frequenz-Kanälen, die Cell Allocation CA, zugeteilt. Eine BTS kann aus einem
oder mehreren „Transceivern“ (TRX: „Transmitter“ + „Receiver“) aufgebaut sein. Eine
TRX ist für einen Frequenzträger zuständig (der mit Hilfe des TDMA-Verfahrens auf acht
Kanäle (Channels) aufgeteilt ist, siehe „GSM-Luftschnittstelle“). Hier erfolgt die Kanalcodierung/-decodierung und die Verschlüsselung. Eine weitere funktionelle Komponente
einer BTS ist die BCF (Base Control Function), die allgemeine Kontrollfunktionen (wie
z.B. frequency hopping) für die TRX behandelt. Sie empfängt auch die an die BTS gerichteten O&M-Nachrichten und ist für deren Ausführung zuständig.

10
•

GSM-Architektur
Um die BTSen klein zu halten, befindet sich in der BSC die wesentliche Steuerungs- und
Protokollintelligenz. Die BSC verwaltet die Kanalkonfiguration einschließlich des Frequenz-Hopping-Managements, Lokalisierung und Handover-Ausführung.

3.3.2 Network Subsystem (NSS)
Das NSS besteht aus den verschiedenen MSC (MSC, GMSC, ISC) und den beiden Location
Registern HLR und VLR.
• Die Mobilfunkvermittlungsstelle (MSC: mobile switching center) steuert die Verbindungen vom und zum mobilen Teilnehmer über ein Koppelnetz. Ein PLMN enthält i.A. mehrere vermaschte MSC, die jeweils ihre eigene service area (d.h. eine Menge von BSSen)
bedienen. Die GMSC (Gateway MSC) befindet sich an der Schnittstelle vom Mobilfunknetz zum Festnetz und schaltet entsprechende Verbindungen. Das ISC (International
Switching Center) routet Verbindungen zwischen verschiedenen Mobilfunknetzen und
andere internationale Verbindungen. Zu einer GMSC oder einer ISC gehört auch eine
Funktionseinheit, die die Protokolle des PLMN auf das jeweilige Protokoll des angeforderten Festnetzdienstes abbildet. Diese Funktionseinheit heißt IWF (Interworking Function).
• Die Datenbanken HLR (Home Location Register, Heimatregister) und VLR (Visitor
Location Register, Besucherregister) halten u.a. die für die MSC zum Routing notwendigen Daten. Jedes PLMN hat i.A. genau einen HLR, die für jeden Teilnehmer einen Eintrag mit seiner MSISDN und den für ihn freigeschalteten Dienste enthält. Außerdem enthält der Eintrag den aktuellen Aufenthaltsort (d.h. die MSRN) des Teilnehmers. Jede
MSC enthält i.A. genau einen VLR, der die Daten aller Teilnehmer speichert, die sich
momentan im Verwaltungsbereich der zugehörigen MSC aufhalten.
3.3.3 Operation and Maintenance Subsystem (OMS)
Wartungs- und Betriebsfunktionen werden vom OMS wahrgenommen.

Abbildung 3.3: Das Operation and Maintenance Subsystem

In Bild 3.3 sind die Komponenten, die zum OMS gehören, grau hinterlegt; die gestrichelt
gezeichneten Komponenten werden vom OMS überwacht und gesteuert. Die Verbindungsli-

11

Rainer Sönksen

nien stellen in dieser Zeichnung Signalpfade dar, über die Management-Informationen ausgetauscht werden.
• Das OMC-R und OMC-S (Operation and Maintenance Centre-Radio bzw. Switch) erlauben es dem Mobilfunkbetreiber, sein Mobilfunknetz zentral zu verwalten und zu überwachen. Dabei obliegt dem OMC-R die Überwachung und Steuerung einer oder mehrerer
BSSen (dabei ist das OMC-R mit den BTSen nicht direkt, sondern über die BSC verbunden) und dem OMC-S die Überwachung und Steuerung des MSC. Typische Aufgaben
sind jeweils die Netzkonfiguration, Netzbetrieb, Performance Management (d.h. Sammeln
und Auswertung von Performance Information), Sicherheitsmanagement, Fehlerüberwachung und Verwaltung. Die Netzkontrolle kann in einem Network Management Centre
(NMC) zentralisiert werden, so daß der Netzbetreiber in der Lage ist, von einem zentralen
geographischen Standort aus sein gesamtes Netz zu überwachen.
• Mit Hilfe eines LMT (Local Maintenance Terminal) können Diagnose- und
Konfigurationstätigkeiten vor Ort d.h. an der jeweiligen BTS vorgenommen werden (z.B.
beim Austausch einer defekten Karte).
• Die beiden Datenbanken EIR (Equipment Identity Register) und AUC (Authentication
Center) dienen der Systemsicherheit des GSM-Netzes. Das EIR speichert die IMEI, so
daß jede MS auf veraltete Software geprüft oder einer als gestohlenen gemeldeten MS der
Dienstzugang verwehrt werden kann. Das AUC speichert und erzeugt vertrauliche Daten
und Schlüssel zur Benutzerauthentifizierung.

4 Schnittstellen und Protokolle
4.1 Die Schnittstellen
Das folgende Bild zeigt die wichtigsten, für ein PLMN definierten Schnittstellen:

Abbildung 4.1: Schnittstellen in einem GSM PLMN

Nachfolgend werden die hauptsächlichen, über die Schnittstellen transferierten Daten beschrieben:

12
•
•
•
•
•

•
•
•

GSM-Architektur
Um zwischen den BTS und den MS bildet die Luftschnittstelle.
Über die A-Schnittstelle zwischen BSS und MSC und die Abis-Schnittstelle zwischen BSC
und BTS werden Daten für das BSS-Management, für Verbindungssteuerung und Mobilitätsmanagement ausgetauscht.
Über die B-Schnittstelle erfragt die MSC die Daten der MS, die sich in seinem
Verwaltungsbereich aufhalten. Aufenthaltsaktualisierung von MS leitet die MSC über
diese Schnittstelle an das VLR weiter.
Wegesuchinformationen enthält die MSC aus dem HLR über die C-Schnittstelle. Die
MSC kann über diese Schnittstelle auch Vergebührungsinformationen an das HLR schicken.
Über die D-Schnittstelle werden aufenthaltsbezogene Teilnehmerdaten ausgetauscht. Das
VLR informiert das HLR über den aktuellen Aufenthaltsbereich des Teilnehmers und teilt
ihm die momentane MSRN mit, das HLR übergibt dem VLR alle Teilnehmerdaten, die
notwendig sind, um lokal dem Teilnehmer den Dienstzugang zu ermöglichen. Werden
vom Mobilteilnehmer spezielle Dienstmerkmale umkonfiguriert, wird zunächst das VLR
informiert, das über die D-Schnittstelle die Daten des HLR auf den neuesten Stand bringt.
Die E-Schnittstelle wird benötigt, um ein Handover zwischen zwei verschiedenen MSCBereichen zu ermöglichen (siehe 5.3.2)
Die F-Schnittstelle dient der MSC zur Abfrage und Prüfung der Geräteidentität.
Bei einer Aufenthaltsaktualisierung eines Mobilteilnehmers werden die Daten vom alten
VLR direkt über die G-Schnittstelle zum neuen VLR transferiert.

4.2 Die Protokollarchitektur
4.2.1 Protokollarchitektur der Nutzdatenebene
• Sprachübertragung: Die auf dem Funkkanal speziell gesicherte Sprachübertragung erfolgt
transparent zwischen der MS und einer Transcodiereinheit (TRAU: Transcoding and Rate
Adaptation Unit). Die TRAU übernimmt die Transcodierung der Sprachdaten vom GSMFormat, wie sie auf der Funkschnittstelle codiert sind (13 kbit/s) in ein A-Law-Signal des
ISDN mit 64 kbit/s (die Kommunikation zwischen der BTS und der BSC erfolgt in einem
ISDN-B-Kanal). Darüber hinaus ist die TRAU für die eventuell notwendige Bitratenanpassung von Datensignalen zuständig. Die TRAU kann aber auch in der BSC oder sogar
in der MSC plaziert sein; der Vorteil hierbei ist, daß dann bis zu vier Sprachsignale à 16
kbit/s im Submultiplex auf einem ISDN-B-Kanal übertragen werden kann, so daß auf der
Strecke BTS-BSC insgesamt weniger Bandbreite benötigt wird. Die 3 kbit/s Differenz
zwischen GSM-Sprachsignal und Submultiplex-ISDN-Signal wird zur Inband-Signalisierung verwendet (die Fernsteuerung der TRAU durch die BTS).
• Datenübertragung: Die Datenübertragung kann transparent oder nicht-transparent erfolgen.
• Bei der transparenten Datenübertragung werden die Nutzdaten nur an der Funkschnittstelle durch Vorwärtsfehlerkorrektur (FEC) gegen Übertragungsfehler geschützt. Die
weitere Übertragung bis zum nächstgelegenen MSC mit einer Interworkingfunktion
IWF zum ISDN oder PSTN erfolgt ungesichert. Der transparente GSM-Datendienst
bietet konstanten Datendurchsatz und Übertragungsverzögerung, allerdings schwankt
die Restbitfehlerhäufigkeit.
• Bei der nicht-transparenten Datenübertragung wird als Sicherungsprotokoll das Radio
Link Protocol RLP zwischen MS und MSC verwendet. Es implementiert ein Fehlererkennungsschema mit automatischer Wiederübertragung von gestörten Blöcken (Automatic Repeat Request ARQ). Es ist dem HDLC des ISDN ähnlich. Wie dieses auch arbeitet RLP verbindungsorientiert. Durch die Sicherung mit dem RLP weist die nicht-

13

Rainer Sönksen
transparente Datenübertragung eine konstant niedrige Restbitfehlerrate auf, allerdings
schwankt der Datendurchsatz als auch die Übertragungsverzögerung mit der Kanalqualität.
• Zugang zum PSPDN: Schon heute gibt es zwei Möglichkeiten, von einer MS aus mit
einem Teilnehmer im PSPDN (Datex-P) zu kommunizieren. Die erste Möglichkeit ist
die, vom PLMN aus über das PSTN und einem PAD (Packet Assembler/Disassembler) des PSPDN zu gehen. Dafür wandelt die IWF der GMSC die
Daten mit Hilfe eines Modems in asynchrone, analoge Signale um, die über das PSTN
transportiert werden können; ein weiteres Modem wandelt die analogen Signale
wieder in digitale Signale um; diese werden dann vom PAD in X.25-Pakete verpackt.
Dieses Vorgehen hat den Nachteil, daß ein eigenes Teilnehmerverhältnis mit dem Paketdatennetz-Betreiber notwendig ist; außerdem ist der Zugang zum PSPDN meistens
nur über einen bestimmten PAD erlaubt; um ihn zu erreichen, müssen die Daten
manchmal durch mehrere Netze transportiert werden, so daß Roaming-Entgelte anfallen. Deshalb wurde im GSM definiert, daß jedes PLMN mindestens einen eigenen dedizierten PAD-Zugang zum PSPDN besitzen kann.

4.2.2

Protokollarchitektur der Signalisierungsebene

Abbildung 4.2: Protokollarchitektur der Signalisierungsebene

Die Signalisierung besteht aus zwei grundsätzlich verschiedenen Teilen: innerhalb der RSS
mit den Schnittstellen Um und Abis ist diese GSM-spezifisch; innerhalb des NSS und zwischen
verschiedenen PLMN ist die Signalisierung SS#7-basiert mit den Schnittstelle A, B, C und E.
Im folgenden sollen nur die wichtigsten Protokolle des Layer 3 näher erläutert werden. Sie
sind in drei untergeordnete Schichten untergliedert: das Radio Resource Management RR, das
Mobility Management MM und das Connection Management CM:
• Bei der Ausführung der im RR-Protokoll definierten Aufgaben sind - je nach Aufgabe -
sowohl die BTS, als auch die BSC und die MSC beteiligt.
• Die BTS-spezifischen Anteile werden BTS-seitig im RR'-Protokoll definiert.
• Die BSC-spezifischen Anteile werden BSC-seitig im BTSM-Protokoll definiert.

14

GSM-Architektur

• Die MSC-spezifischen Anteile werden MSC-seitig im BSSMAP-Protokoll definiert.
Die wesentlichen im RR-Protokoll definierten Aufgaben sind:
• Frequenz- und Kanalverwaltung
• Periodische Messung der Kanalqualität
• Sendeleistungskontrolle
• Synchronisierung der MS
• Handover-Management
• Das MM terminiert in der MS und der MSC. Aufgaben des MM sind die TMSI Zweisung,
Lokalisierung der MS, location update, Identifizierung und Authentifizierung der MS u.a.
• Das CM besteht aus den Subfunktionen Rufsteuerung (Call Controll CC, umfaßt alle
Aufgaben im Rahmen von Aufbau, Betrieb und Abbau von Rufen), Zusatzdienststeuerung
(Supplementary Services SS) und Kurznachrichtensteuerung SMS (Short Message
Services).
Die Signalisierung zwischen MSC und BSC ist im Base Station System Application Part
BSSAP definiert. Er setzt sich zusammen aus den Protokolle DTAP (Direct Transfer Application Part) und BSSMAP (Base Station System Management Application Part). DTAP transportiert Signalisierungmeldungen des CC und des MM zwischen MSC und MS. Diese Meldungen werden transparent über die Abis-Schnittstelle an die MS übertragen. Das BSSMAP
übernimmt, wie schon erwähnt, MSC-spezifische Funktionen des Radio Resource Management.
Zur Kommunikation im GSM-Vermittlungsnetz (also zwischen MSC, HLR und VLR) dient
die SS#7-Erweiterung MAP (Mobile Application Part).

5 Signalisierungsprozesse
Im folgenden soll der grundsätzliche Ablauf der wichtigsten Signalisierungsprozesse im
PLMN beschrieben werden. Die wichtigsten Funktionen sind
• das Einbuchen in ein PLMN (Location Registration) und das Aktualisieren der Daten über
den momentanen Aufenthaltsort einer MS (Location Update) (dazu gehört auch die Identifizierung und Authentifizierung eines Benutzers)
• der Verbindungsauf- und -abbau (und zwar sowohl mobile originated (d.h. das Gespräch
geht von der MS aus) als auch mobile terminated (d.h. die MS wird angerufen)
• und die Übergabe einer bestehenden Gesprächsverbindung an eine neue BTS (Handover)

5.1 Location Registration und Location Update
5.1.1 Location Registration Procedure
Beim Einschalten scannt die MS zunächst die möglichen Trägerfrequenzen, um herauszufinden, welche von ihnen in der aktuellen Zelle ausgestrahlt werden. Dann liest die MS die LAI,
die regelmäßig von der BTS gesendet wird. Danach fordert sie die Registrierung ihres momentanen Aufenthaltsortes. Nach erfolgreicher Authentifizierung wird dem Teilnehmer eine
neue MSRN zugeteilt und zusammen mit der LAI im HLR gespeichert. Dann wird die BTS
und die MS von dem VLR aufgefordert, mit der Chiffrierung zu beginnen. Das VLR vergibt
eine neue TMSI und übermittelt diese chiffriert an BTS und MS. Über das „Insert Subscriber
Data“-Kommando erhält die VLR von der HLR Informationen über den Teilnehmer wie z.B.
Konfigurationsparameter von Zusatzdiensten. Mit dem Empfang der „Location Update
Accepted“-Nachricht und des „TMSI-Acknowledge“ ist die Location Registration erfolgreich
beendet. Mehrere Pfeile auf derselben Horizontalen wie in Bild 5.1 bedeuten, daß die Signale
zeitlich unabhängig voneinander sind und nicht synchron.

15

Rainer Sönksen

Abbildung 5.1: Location Registration Procedure

Wenn die MS in eine neue LA wechselt, fordert sie die Aktualisierung ihrer Aufenthaltsinformationen an (Location Update Request). Wenn die MS dabei in den Verwaltungsbereich
einer neuen VLR gewechselt ist, fordert diese die Authentifizierungsdaten von der alten VLR
an (über die G-Schnittstelle) und stößt die Authentifizierungsprozedur an. Außerdem weist
das neue VLR das alte an, die Aufenthaltsdaten für die MS zu löschen. Der MS wird von der
neuen VLR eine neue TMSI zugewiesen und dem HLR wird die neue MSRN mitgeteilt (über
die D-Schnittstelle).
5.1.2 Authentifizierung
Im AUC ist für jeden Teilnehmer (IMSI) ein Authentifizierungsschlüssel Ki gespeichert. Derselbe Schlüssel ist auch auf der SIM des Teilnehmers gespeichert. Ki darf aus Sicherheitsgründen nicht zwischen den Komponenten übertragen werden. Die Authentifizierungsprozedur beginnt damit, daß das VLR eine Zufallszahl (RAND) zur MS schickt. Wenn das VLR für
die IMSI noch über keine Authentifizierungsdaten verfügt, fordert sie diese über das HLR
vom AUC an. Das AUC erzeugt die RAND und berechnet unter zur Hilfenahme des Algorithmus A3 und den Parametern RAND und Ki die Signatur SRES. RAND und SRES werden
zum VLR übertragen. Jetzt kann das VLR die RAND zur MS schicken, die ebenfalls mit dem
Algorithmus A3 und den Parametern Ki und RAND die SRES berechnet und zum VLR zurücksendet. Wenn die von der MS berechnete SRES mit der von der AUC berechneten SRES
übereinstimmt, ist die Authentifizierungsprozedur erfolgreich abgeschlossen.

16

GSM-Architektur

Abbildung 5.2: Authentifizierungsprozedur

5.1.3 Chiffrierung
Wie ebenfalls dem Bild 5.2 zu entnehmen ist, wird mit Hilfe des Ki und der RAND mit Hilfe
des Algorithmus A8 der Chiffrierungsschlüssel Kc ermittelt. Über ein „Start Ciphering“Kommando übermittelt das VLR der BTS den Kc, so daß sowohl die MS als auch die BTS
über den Kc verfügen. Mit Hilfe des Kc und des Algorithmus A5 werden nun sämtliche Nutzdaten, die auf der Funkschnittstelle ausgetauscht werden, verschlüsselt.
5.1.4 Vertraulichkeit der Teilnehmeridentität
Ein weiterer Sicherheitsaspekt ist der, daß die IMSI, die Rückschlüsse auf den Teilnehmer
erlauben würde, so selten wie nötig über die Funkschnittstelle ausgetauscht wird. Statt dessen
wird vom VLR die TMSI erzeugt. Das Mapping zwischen IMSI und TMSI ist nur im VLR
bekannt. Auch die TMSI wird nur verschlüsselt (mit Hilfe von Kc) übertragen.

5.2 Verbindungsaufbau und Verbindungsabbau
Soll eine Verbindung zu einer MS geschaltet werden, muß zunächst ihr aktueller Aufenthaltsort ermittelt werden.
Der einfachste Fall ist folgender: Der Vermittlungsknoten des Teilnehmers, der die Verbindung aufbaut, kann das HLR des Teilnehmers, der gerufen werden soll, kontaktieren. Das
HLR kennt die aktuelle MSRN des gerufenen Teilnehmers, so daß die Verbindung zur zuständigen MSC geroutet werden kann. Im VLR des MSC befinden sich zu dem Teilnehmer
seine LAI und die TMSI; die TMSI wird nun in den Zellen ausgestrahlt, die die LA umfassen;
erkennt die MS ihre TMSI, antwortet sie darauf.

17

Rainer Sönksen

Folgende Alternativen zum einfachsten Szenario sind möglich:
• Die MSRN muß nicht bei jedem Location Update neu generiert werden und im HLR
aktualisiert werden. Der GSM-Standard erlaubt auch, die MSRN nur im Falle eines Verbindungsaufbaus zu vergeben und im HLR nur die Adresse des aktuellen VLR zu speichern. Dann allerdings muß das HLR beim Verbindungsaufbau zunächst vom VLR eine
MSRN anfordern.
• Der Vermittlungsknoten des rufenden Teilnehmers ist nicht in der Lage, das HLR des
gerufenen Teilnehmers zu befragen (wegen fehlender Protokollintelligenz). Vor allem bei
Rufen aus dem Festnetz und bei Rufen in ein anderes Mobilnetz wird der lokale Vermittlungsknoten den Vermittlungsauftrag deshalb an eine GMSC weiterleiten. Bei internationalen Rufen wird der Vermittlungsauftrag an eine ISC weitergeleitet.
Beim Verbindungsaufbau muß sich sowohl der rufende als auch der gerufene Teilnehmer
authentifizieren. Der gesamte Verbindungsaufbau, auch die Übermittlung der gewünschten
Rufnummer, findet chiffriert statt.
Nach dem Abbau der Verbindung werden im HLR des rufenden Teilnehmers Informationen
zur Entgeltberechnung gespeichert. Fallen Roamingentgelte an, weil der gerufene Teilnehmer
sich nicht in seinem Heimatnetz aufgehalten hat, werden hierzu Daten im HLR des gerufenen
Teilnehmers gespeichert.

5.3 Handover
Man unterscheidet mehrere Handover-Arten:
• Intra-Zell-Handover: in der gleichen Zelle wird der MS eine neue Trägerfrequenz
zugewiesen (z.B. wegen schlechter Kanalqualität)
• Inter-Zell-Handover: die MS betritt eine neue Zelle; dabei unterscheidet man wiederum
zwei Fälle:
• die BTS, die diese neue Zelle bedient, kann von derselben BSC verwaltet werden wie
die BTS, deren Zelle verlassen wurde; dann kann die BSC den Handover selbst steuern. Ein solcher Handover wird interner Handover genannt.
• Ein externer Handover wird durchgeführt, wenn auch die verwaltende BSC sich ändert. Der externe Handover wird hauptsächlich von der MSC gesteuert. Dabei wird
unterschieden, ob die neue BSC von derselben MSC bedient wird (Intra-MSC Handover), oder ob auch die MSC wechselt (Inter-MSC Handover).
Die Entscheidung, ein Handover durchzuführen, trifft das Netz (BSC und MSC), nicht die
MS. Gründe können BSS-Kriterien (wie Empfangsfeldstärke, Kanalqualität und Entfernung
der MS von der BTS) sein, die mit Hilfe der Kanalvermessung festgestellt werden (siehe
„GSM-Luftschnittstelle“ und Beschreibung der BSIC), aber auch Netzwerk-Kriterien (z.B.
augenblickliche Verkehrslast der Zelle oder Wartungsarbeiten).
Ein Handover muß möglichst schnell und unbemerkt ablaufen, damit die Verbindung stabil
bleibt. Deshalb wird während der Umschaltung auch keine Authentizitätsprüfung und Chiffrierung benutzt.
5.3.1 Intra-MSC Handover
Aufgrund der Meßergebnisse fordert die BSC ein Handover vom MSC an; in diesem Request
übersendet sie der MSC auch die Meßergebnisse; diese enthalten u.a. die von der MS gemessenen Empfangsqualitäten ihrer aktuellen Zelle und der sechs umliegenden Zellen. Mit Hilfe
dieser Informationen kann die MSC die neue BSS ermitteln und weist diese an, einen Kanal
für den Handover bereitzustellen. Sobald die Reservierung vom neuen BSS bestätigt wurde,
wird die MS angewiesen, sich bei der neuen BSS anzumelden, woraufhin sie von dieser Informationen zur Kanalphysik erhält (z.B. zum Timing Advance oder zum neuen Sendeleistungspegel, siehe „GSM-Luftschnittstelle“). Konnte die MS den Kanal erfolgreich belegen,
bestätigt sie dies, woraufhin die Resourcen der alten BSS freigegeben werden.

18

GSM-Architektur

5.3.2 Inter-MSC Handover
Wenn die neue Zelle im Bereich einer anderen MSC ist, fordert die MSC, über die die Verbindung beim Verbindungsaufbau geführt wurde (im folgenden MSC-A genannt), von dieser
MSC (im folgenden MSC-B genannt) einen Funkkanal für die MS zu belegen. Wenn ein Kanal verfügbar ist, wird ein ISDN-Kanal zwischen den beiden MSC durchgeschaltet und von
beiden MSC wird eine Bestätigung an die MS gesendet. Diesen Vorgang nennt man Basic
Handover. Dabei bleibt die Verbindung unter der Kontrolle von MSC-A.
Wenn daraufhin die MS in eine Zelle wechselt, die dem Bereich einer MSC-B' angehört, ist
ein sogenannter Subsequent Handover nötig. Darunter versteht man den Abbau der Verbindung zwischen MSC-A und MSC-B. Dieser Subsequent Handover wird von der MSC-B angestoßen. Die MSC-A entscheidet über das Ziel des Handover-Prozesses und stößt ein Basic
Handover bei der MSC-B' an.

6 Aspekte der Datenkommunikation
6.1 Mobile Datenkommunikation heute
GSM definiert nur leitungsvermittelte Informationsübertragungen. Diese sind grundsätzlich
für die Datenkommunikation nicht geeignet, da Daten i.A. burstartig anfallen. Außerdem erlaubt jeder Signalkanal maximal eine Übertragungsgeschwindigkeit von 9,6 kbit/s.

6.2 GSM-Phase 2+: Mobile Datenkommunikation der Zukunft
Die 1997 abgeschlossenen Standards zur GSM-Phase 2+ betreffen fast alle Aspekte von
GSM. Hier sollen exemplarisch die Aspekte eingehender beschrieben werden, die sich der
Verbesserung der mobilen Datenkommunikation widmen. Dafür wurden hauptsächlich drei
neue Datendienste eingeführt: HSCSD (High Speed Circuit Switched Devices), GPRS (General Packet Radio Service) und EDGE (Enhanced Data Rates for GSM Evolution).
6.2.1 Einführung neuer Datenraten
Die Einschränkung der Übertragungsgeschwindigkeit auf 9,6 kbit/s ist eher historisch bedingt,
da bei der ursprünglichen GSM-Konzeption als Gegenstellen im Festnetz lediglich V.32-Modems vorhanden waren mit ebendieser Datenrate. Durch den Einsatz optimierter Kodierungsund Fehlerkorrekturverfahren ist es deshalb möglich, für transparente Datendienste eine
Übertragungsgeschwindigkeit von 14,4 kbit/s zu erreichen und für nicht-transparente Datendienste immerhin eine Übertragungsgeschwindigkeit von 13,2 kbit/s.
6.2.2 HSCSD
Banal ist die Idee, zur Erhöhung der Datenrate einfach eine Kanalbündelung vorzunehmen.
Durch Zusammenfassung von bis zu acht benachbarten Zeitschlitzen lassen sich Datenraten
von maximal 8 x 14,4 kbit/s erzielen. Interessant bei diesem Dienst ist, daß nur geringe Änderungen bei den bereits bestehenden Netzen notwendig wird. Nur die Anforderngen an die MS
steigen. Als entscheidender Nachteil bleibt jedoch, daß HSCSD weiterhin ein leitungsvermitteltes Verfahren ist und damit für die Datenkommunikation grundsätzlich nicht geeignet.
Auch lassen die ohnehin schon knappen Funkkanäle natürlich keine beliebige Bündelung zu.
Außerdem ist HSCSD für den Nutzer eine teure Angelegenheit, da mehrere Kanäle gleichzeitig belegt und bezahlt werden müssen.
6.2.3 GPRS
GPRS ist ein Dienst, der eine echte paketvermittelte Datenübertragung erlaubt und damit den
Funkkanal wesentlich effizienter auslastet, da er den Benutzern flexibel Bandbreite zuweisen
kann (vergleich 4.2.1 „Übergang zum PSPDN“). Ein Ziel bei der Standardisierung war es,

19

Rainer Sönksen

einen einfachen Zugang zu Netzen, die auf dem Internet Protocol (IP) (z.B. das Internet) oder
auf X.25 basieren (z.B. Datex-P) zu schaffen.
GPRS stellt der vorhandenen GSM-Netzstruktur im Prinzip noch eine zweite Netzstruktur zur
Seite, so daß die Einführung von GPRS sehr großer Investitionen bedarf. Alle für GSM beschriebenen Aspekte müßten für GPRS noch einmal beleuchtet werden, was in diesem Kapitel - allerdings sehr viel oberflächlicher - getan werden soll.
• Dienste: In GPRS gibt es Point-to-Point (PTP) Trägerdienste und Point-to-Multipoint
(PTM) Trägerdienste. Die PTP-Trägerdienste gibt es verbindungslos (PTP-CLNS, d.h. jedes einzelne Datenpaket besitzt seine vollständige Zieladresse und ist damit unabhängig
vom Zustellstatus aller anderen Datenpakete; dieses Protokoll ähnelt sehr dem IP) und
verbindungsorientiert (PTP-CONS, hier baut das GPRS-Netz für die Dauer der Datenübertragung eine virtuelle Verbindung auf, über welche die beiden Teilnehmer miteinander kommunizieren; für den Einsatz mit X.25-Netzen). Bei den Broadcast-Diensten unterscheidet man Point-to-Multipoint Multicast (PTM-M) und Point-to-Multipoint Group Call
(PTM-G). Beim PTM-M werden die Datenpakete an die Teilnehmer ausgestrahlt, die sich
aktuell in einem bestimmten geographischen Gebiet aufhalten. PTM-G hat Ähnlichkeit
mit den Newsgroups: Ein Interessent kann sich auf einen Verteiler setzen und erhält dann
die Nachrichten, die über PTM-G an die jeweilige Verteilergruppe abgesetzt wurde. Als
weiteren Dienst sind die auch bei GSM schon implementierten SMS-Dienste im GPRS
vorhanden, verursachen hier aber systembedingt weniger Aufwand. Durch die Unabhängkeit des GPRS-Netzes vom GSM-Netz können Dienste beider Netze parallel genutzt werden (also z..B. kann man ein GSM-Telefonat führen und gleichzeitig via GPRS einen
FTP-Job laufen lassen).
• Systemarchitektur: Der erste neue Knotentyp, den das GPRS einführt, ist der Serving
GPRS Support Node SGSN. Seine Funktionalität ist mit der der MSC zu vergleichen. Er
wickelt den Datentransfer von und zu den Mobilstationen ab, protokolliert den Aufenthaltsort der Teilnehmer, führt seine Authentifizierung durch und prüft die für ihn freigeschalteten Dienste. Der Gateway GPRS Support Node GGSN stellt die Schnittstelle zu den
PDN dar (IP und X.25). Er konvertiert die vom SGSN kommenden GPRS-Pakete in das
entsprechende Paketdatenprotokoll (Packet Data Protocol PDP, also z.B. IP oder X.25)
und sendet diese an das PDN. In der Gegenrichtung wird die PDP-Adresse auf die GSMAdresse des jeweiligen Teilnehmers umgesetzt und an den zuständigen SGSN gesendet.
Zwischen den SGSN und GGSN besteht eine m:n-Beziehung. SGSN und GGSN sind über
ein IP-basiertes GPRS-Backbone miteinander verbunden. Gehören SGSN und GGSN dem
selben PLMN an, handelt es sich um ein privates IP-basiertes Netz (Intra-PLMN
Backbone); gehört der GGSN zum PLMN eines anderen GPRS-Netzbetreibers und
besteht ein Roaming-Abkommen zwischen den Netzbetreibern, so läuft die Verbindung
über ein Inter-PLMN Backbone. An der Schnittstelle zwischen dem Intranet und dem Internet befindet sich ein Border Gateway BG, der u.a. Sicherheitsfunktionen ausführt, um
das Intranet vor unerlaubtem Zugriff zu schützen. Das HLR des Teilnehmers wird um einen Verweis seines aktuellen SGSN, den GPRS-spezifischen Teilnehmerdaten und dessen
aktueller PDP-Adresse erweitert.

20

GSM-Architektur

•
Abbildung 6.1: GPRS-Systemarchitektur

•

Signalisierungsprozesse: Zum Einbuchen meldet sich die MS beim SGSN an. Das SGSN
überprüft die Zugangsberechtigung der MS, kopiert die teilnehmerspezifischen Daten vom
HLR und weist der MS eine Packet Temporary Mobile Subscriber Identity P-TMSI zu
(vergleich TMSI) (dieser Vorgang heißt GPRS Attach). Danach muß die MS eine PDPAdresse beantragen. Die zuständige GGSN erzeugt dann einen PDP-Kontext, der den
PDP-Typ (z.B. IPv6), die PDP-Adresse der MS, die gewünschte Dienstgüte (Quality-ofService-Klasse, QoS-Klasse: Dienstpriorität, Zuverlässigkeit, Übertragungsverzögerung
und Durchsatz) und die Adresse des GGSN enhält. Der Kontext wird in der MS, dem
SGSN und dem GGSN gespeichert. Die Zuteilung der PDP-Adresse kann statisch oder
dynamisch erfolgen. Im dynamischen Fall kann die Adresse vom Heimatnetzbetreiber
oder vom Betreiber des Festnetzes, in dem die Mobilstation gerade eingebucht ist, vergeben werden. Wenn jetzt Daten an die MS geschickt werden sollen, werden sie zunächst
immer in das PLMN geroutet, von dem die MS ihre PDN-Adresse zugewiesen bekam
(denn die PDN-Adresse gehört ihrem Namensraum an). Der GGSN dieses Netzes befragt
dann das HLR nach dem aktuellen Aufenthaltsort der MS. Wenn dies ein anderes PLMN
ist, schickt der GGSN die Daten über das Inter-PLMN GPRS Backbone zum GGSN dieses PLMN.

6.2.4 EDGE
EDGE ersetzt das in GSM verwendete Modulationsverfahren GMSK (Gauß Minimum Shift
Keying) durch das Phasenmodulationsverfahren 8-PSK (8-Phase Shift Keying). Bei GMSK
wird pro Schrittdauer nur ein Bit ausgesendet, bei 8-PSK jedoch drei Bit. Damit erlaubt
EDGE maximal die achtfache Übertragungsgeschwindigkeit. Allerdings ist 8-PSK auch anfälliger gegenüber Störungen, so daß EDGE auch einen adaptiven Wechsel zwischen der alten
und der neuen Modulationsart vorsieht.
EDGE kann man in Kombination mit HSCSD und GPRS betreiben, die dann ECSD und
EGPRS heißen. EDGE bietet - wie später auch UMTS - vier Datenklassen, die sich durch
durch die Übertragungsgeschwindigkeit und -sicherheit und Verzögerung unterscheiden.

21

Rainer Sönksen

Referenzen
[EVB01]

J. Eberspächer, H-J. Vögel, C. Bettstetter
GSM Global System for Mobile Communication

[Det97]

Kai-Oliver Detken
GSM - „Global System for Mobile Communication“
Der Mobilfunkstandard

[Roh98]

Kai Rohrbacher
Dampf fürs Drahtlose
HSCSD, GPRS, UMTS: die Zukunft der mobilen Datenkommunikation
iX 3/1998

[NDK00]

Dirk Nikolai, Klaus Daniel, Edgar Kühn
Turbolader für Funk-Bits
Zehnfach schneller surfen mit EDGE
c't 19/2000

Die Funkschnittstelle von GSM
Alexandra Kirchmeier-Hürlimann

Alexandra.Kirchmeier-Huerlimann@stud.lrz-muenchen.de
Zusammenfassung: In diesem Dokument wird die Funkschnittstelle von GSM (im folgenden Luftschnittstelle) beschrieben. Der Schwerpunkt liegt hier auf der Schicht eins
(Physical Layer). Wirklich relevant für diese Schnittstelle sind nur die drei unteren
Schichten, in die die Daten höherer Schichten lediglich eingebettet sind und transparent
übertragen werden. So wird in diesem Dokument die physikalische Schicht mit ihren
physikalischen Kanälen und den darauf gemultiplexten logischen Kanälen beschrieben,
so wie die hier eingesetzte Kanalcodierung zur Sicherung der zu übertragenden Daten.
Außerdem wird auf das LAPDm-Protokoll der Schicht-2 und teilweise auf die Schicht-3
Übertragungsrahmen für die Signalisierung eingegangen.

1 Einleitung
Die Funkschnittstelle von GSM (Global Standard for Mobile Communications) ist die Verbindung zwischen Mobilstation (Handy) auf der einen und Basisstationen auf der anderen
Seite, die über Funkübertragung realisiert werden muß. Sie ist von ETSI (European Telecommunications Standards Institute) standardisiert, und basiert auf dem FDMA/TDMASchema.
An die Luftschnittstelle werden ähnlich hohe Ansprüche an die Sprachqualität wie im Festnetz gestellt. Bei einer begrenzten Bandbreite, nämlich 22,8 kBit/s im Gegensatz zu ISDN mit
64 kBit/s und sich ständig ändernden Qualitätsbedingungen des Übertragungsweges über die
Luft durch Mobilität und Umwelt (Vegetation, Bebauung, Wetter...), sowie Interferenzen zwischen Nachbarzellen, stellen diese enorme Anforderungen an die technische Realisierung der
Funkschnittstelle.
Auf der Funkschnittstelle sind nur die unteren drei Schichten realisiert:
• Physical Layer
• Data Link Layer und
• Network Layer.
Diese Schichten müssen immer zwischen zwei Knoten implementiert sein. Die höheren
Schichten betreffen die Luftschnittstelle nicht direkt, da die Daten transparent durchgereicht
werden. In den folgenden Abschnitten werden die drei unteren Schichten näher erläutert.

2 Die Struktur der Funkschnittstelle von GSM
2.1 Schicht 1: Die physikalische Schicht
Die physikalischen Eigenschaften der Funkschnittstelle entscheiden in besonderer Weise über
die Qualität und damit den Erfolg eines Mobilfunksystems [Sig].
2.1.1 Physikalische Kanäle
Bei immer schmaleren Frequenznischen und einem stetig steigenden Benutzeranteil und immer neuen Anwendungen spielt die Frequenzeffektivität eine besondere Rolle.

24

Die Funkschnittstelle von GSM

Während im deutschen C-Netz noch ausschließlich das FDMA (Frequency Division Multiple
Access) Schema eingesetzt wurde, basiert die Luftschnittstelle von GSM auf dem
FDMA/TDMA (Time Division Multiple Access) -Schema. Durch diese Kombination entsteht
eine zweidimensionale Kanalteilung, bei der der für GSM reservierte Frequenzbereich auf
124 Kanäle zu je 200 kHz Bandbreite aufgeteilt wird, die ihrerseits jeweils auf 8 Zeitschlitze
gesplitted werden. So kommt man auf rund 1000 physikalische Kanäle.
Um einen Duplex-Betrieb zu realisieren wird pro Gesprächsteilnehmer ein Uplink- und ein
Downlinkkanal benötigt. D.h. es wird tatsächlich jeweils ein Zeitschlitz auf zwei verschiedenen Frequenzen im Abstand von 45MHz aktiviert.

Uplink

Downlink

t
1

2

3

124

1

2

3

124

1

2

3

124

1

2

3

124

1

2

3

124

1

2

3

124

1

2

3

124

1

2

3

124

1

2

3

124

1

2

3

124

1

2

3

124

1

2

3

124

1

2

3

124

1

2

3

124

1

2

3

124

1

2

3

124
f

200 kHz
890 MHz

915 MHz

935 MHz

960 MHz

Bandabstand
45 MHz

Abbildung 1: FDMA/TDMA-Schema auf der GSM Luftschnittstelle

2.1.2 Synchronisation zwischen Uplink und Downlink
Aus technischen Gründen ist es notwendig, daß die Mobilstation (MS) nicht gleichzeitig senden und empfangen muß. Deshalb ist in der Mobilstation der Zeitrahmen des Uplink gegenüber dem des Downlink um drei Zeitschlitze versetzt:

25

Alexandra Kirchmeier-Hürlimann

Empfangen

TS0

TS1

TS2

TS3

TS4

TS5

Senden

TS5

TS6

TS7

TS0

TS1

TS2

Abbildung 2: Senden und Empfangen auf Seiten der Mobilstation [Sig]

Dazwischen mißt die Mobilstation die Feldstärken der Nachbarzellen, und sendet die Ergebnisse mittels Measurement Reports an die BTS, in der sie gerade eingeloggt ist. Mit sich ändernder Entfernung der Mobilstation zur BTS ändert sich auch die Signallaufzeit, so daß die
Mobilstation ihren Sendezeitpunkt derart anpassen muß, daß das Signal genau das zugewiesene Empfangsfenster bei der BTS erreicht. Sie muß ihn also bei wachsender Entfernung nach
vorne verlegen, und bei Annäherung entsprechend umgekehrt.
2.1.3 Modulationsverfahren
Ein nicht zu unterschätzendes Problem auf der Luftschnittstelle sind die Interferenzen zwischen Nachbarzellen. Deshalb wird dies bei der Modulation des HF-Signals besonderes berücksichtigt. Außerdem ist zu beachten, daß Mobilstationen auf geringen Energieverbrauch
und möglichst einfache und billige Bauweise, weil Massenkonsumprodukte, angewiesen sind.
Das HF-Signal wird mittels GMSK-Modulation (Gaussian Minimum Shift Keying), die zur
Familie der kontinuierlichen Phasenmodulationsverfahren gehört, erzeugt. Diese Verfahren
haben ein schmales Sendeleistungsspektrum mit geringen Nachbarkanalinterferenzen und
eine konstante Hüllkurve, die den Einsatz einfacher Verstärker ermöglicht. Im wesentlichen
besteht dieses Verfahren aus einem Minimum-Shift-Keying-Verfahren (MSK), bei dem vor
der kontinuierlichen Phasenmodulation mit dem Rechteckfilter noch zusätzlich durch einen
Gauß-Tiefpaß gefiltert werden [Eb/Vö].
2.1.4 Optionales Frequenzsprungverfahren
Auch zwischen benachbarten Frequenzen gibt es qualitative Unterschiede. Um frequenzselektive Störungen zu vermeiden, kann optional ein Frequenzsprungverfahren (Hopping) angewandt werden, bei dem jeder Burst auf einer anderen Frequenz gesendet wird. Die für das
Hopping verwendeten Frequenzen werden aus der Frequenzgruppe der jeweiligen Zelle zusammengestellt und dem Mobile über das Assignment Command (Schicht-3-Signalisierung)
mitgeteilt.
2.1.5 Rahmenhierarchie und Rahmennummern in GSM [Sig]
Für die Rahmensynchronisation und vor allem für das Multiplexen logischer Signalisierungskanäle auf einen physikalischen Kanal sind die Rahmenhierarchie und Rahmennummern von
entscheidender Bedeutung.
Pro Zeitschlitz wird ein Burst von 577µs gesendet. Die Bursts der 8 Zeitschlitze TN0 bis TN7
zusammen ergeben einen TDMA Rahmen mit fester Rahmennummer und einer Zeitspanne
von 8 * 577µs =4,615 ms. Die Wiederholungsrate der TDMA Rahmennummern beträgt 3
Stunden 28 Minuten und 53 Sekunden. Dies entspricht einem Hyperframe. Dazwischen liegen
Multiframes für Nutzkanäle und assoziierte Kontrollkanäle, die 26 TDMA Rahmen umschließen (=120ms), bzw. 51 TDMA Rahmen (=235,8ms) für Signalisierungsdaten. Außerdem
werden 26 * 51 bzw. 51 * 26 Multiframes zu Superframes zusammengenommen.

26

Die Funkschnittstelle von GSM
1 hyperframe = 2 048 superframes = 2 715 648 TDMA frames (3 h 28 mn 53 s 760 ms)

0

2

1

3

4

2042

6

5

2043

48

2044

49

2045

2046

2047

1 superframe = 1 326 TDMA frames (6,12 s)
(= 51 (26-frame) multiframes or 26 (51-frame) multiframes)
0

1
0

2

47

3
1

1 (51-frame) multiframe = 51 TDMA frames (3060/13 ms)

1 (26-frame) multiframe = 26 TDMA frames (120 ms)
0 1

2

3

4

50
25

24

2

0 1

22 23 24 25

3

46 47 48 49 50

1 TDMA frame = 8 time slots (120/26 or 4,615 ms)
0

1

2

3

4

5

6

7

1 time slot = 156,25 bit durations (15/26 or 0,577 ms)
(1 bit duration = 48/13 or 3,69 µs)
(TB: Tail bits - GP: Guard period)
Normal burst (NB)

Frequency correction burst (FB)

Synchronization burst (SB)

Access burst (AB)

TB
3

Encrypted bits
58

TB
3
TB
3
TB
8

Training sequence
26

Encrypted bits
58

Fixed bits
142
Encrypted bits
39
Synchronization sequence
41

TB GP
3 8.25

Synchronization sequence
64
Encrypted bits
36

TB GP
3 8,25

TB
3

Encrypted bits
39

TB GP
3 8,25

GP
68,25

Abbildung 3: Time frames time slots and bursts [GSM 05.01]

2.1.6 Übertragungsbursts
An die Übertragungsbursts werden je nach logischer Kanalart verschiedene Anforderungen
gestellt. Außerdem sollten die knappen Ressourcen, Frequenzband und Stromverbrauch auf
Seiten der Mobilstationen, möglichst effizient eingesetzt werden. Deshalb wurden verschiedene Burstarten definiert.
• Normal Burst (NB)
Normal Bursts werden zur Übertragung der Informationen der Verkehrs- und Signalisierungskanäle verwendet. Während der guard periode (GP) von 8,25 Bitperioden wird nichts
gesendet. Der Training Sequence Code (TSC) ist ein vordefiniertes Bitmuster, das hilft,
Laufwegunterschiede durch die Mehrwegausbreitung zu korrigieren. Es kann unter 8 verschiedenen TSCs ausgewählt werden, wobei der zu verwendende Code beim Gesprächsaufbau in einer Schicht 3-Nachricht der Mobilstation mitgeteilt wird. Die Datenbits
sind fehlerschutzcodiert und verschlüsselt.
•

•

•

Frequency Correction Burst (FB)
Dieser Burst wird zur Frequenzsynchronisierung einer Mobilstation verwendet. Die wiederholte Aussendung von FBs wird auch Frequency Correction Channel FCCH genannt,
auf dem BCCH-Träger ausgestrahlt und entspricht einem unmoduliertem Träger.
Synchronization Burst
Dieser Burst dient der Mobilstation zur zeitlichen Synchronisation mit der BTS durch eine
lange Training Sequenz, der laufenden TDMA-Rahmennummer und dem BSIC. Der logische Kanal dazu heißt Synchronization Channel (SCH).
Dummy Burst
Sie werden zumindest immer auf dem BCCH-Träger gesendet, damit auf jeden Fall irgendein Burst von der BTS gesendet wird, um den Mobilstationen Leistungsmessungen
zu ermöglichen.

27
•

Alexandra Kirchmeier-Hürlimann
Access Burst
Der Access Burst wird für wahlfreien Vielfachzugriff auf dem RACH eingesetzt, z.B. von
der Mobilstation zur Kanalanforderung eines Gesprächsaufbaus oder bei einem Handover
während des Wechsels in eine andere Zelle. Der Access Burst hat eine sehr lange guard
periode um die Wahrscheinlichkeit von Kollisionen, mangels Synchronität, herabzusetzen[Eb/Vö].

2.1.7 Kanalmultiplex
Auf jedem der rund 1000 physikalischen Kanäle werden durch Zeitmultiplex verschiedene
logische Kanäle untergebracht (Raten in Bit/s) [WS00]. Sie werden sozusagen über das Raster
der physikalischen Kanäle gelegt, wobei es aufgabenbezogen verschiedene Typen von logischen Kanälen gibt. Die logischen Kanäle sind nicht alle gleichzeitig an der Funkschnittstelle
nutzbar. Sie können nur in bestimmten Kombinationen eingesetzt und auf physikalische Kanäle gemultiplext werden. Dieser Kanalmultiplex findet auf Multiframe-Ebene statt:
B1 B2 B3 B4 B5 B6 B7 B8 B9
Bm
Lm
Lm
BCCH
FCCH
SCH
CCCH
SDCCH
SACCH
FACCH
Abbildung 4: Kanalkombinationen der Basisstation [Eb/Vö]

Auf 26-Rahmen-Multiframes werden Verkehrskanäle (Traffic Channel, TCH) abgebildet. Die
zu Übertragenden Daten können verschiedener Qualität und Art sein:
• Full-Rate Sprache (22800 brutto, 13000 netto)
• Full-Rate Daten (9600, 4800 oder 2400)
• Half-Rate Sprache (11400 brutto, 6000 netto)
• Half-Rate Daten (4800 oder 2400)
• Enhanced Full-Rate Sprache (wie Half-Rate, aber Audioqualität angeblich wie Full-Rate).
24 Rahmen fallen dabei auf den eigentlichen Verkehrskanal mit den zu übermittelnden
Daten, ein Rahmen entfällt auf den Slow Associated Control Channel (SACCH) und der
26. Rahmen ist im Fall eines Full-Rate Kanals ein Idle-Rahmen und im Fall zweier HalfRate Kanäle ein zweiter SACCH Kanal.
Für Signalisierung auf einem Verkehrskanal wird der Fast Associated Control Channel
(FACCH) verwendet. Dabei wird in 8 aufeinanderfolgenden TCH-Rahmen die Hälfte der
Bits der Bursts verwendet und durch stealing flags angezeigt.
51-Rahmen-Multiframes organisieren die Übertragung von Signalisierungskanälen (Control
Channel, CCH; Nicht nur pro Teilnehmer, sondern teilweise über alle Teilnehmer hinweg
betrachtet), die nicht auf einen Verkehrskanal assoziiert sind. Für manche Konfigurationen
sind 2 Multirahmen nötig.
Beispiel:

28

Die Funkschnittstelle von GSM
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16

FCCH
SCH
BCCH 1
BCCH 2
BCCH 3
BCCH 4
AGCH/PCH
AGCH/PCH
AGCH/PCH
AGCH/PCH
FCCH
SCH
AGCH/PCH
AGCH/PCH
AGCH/PCH
AGCH/PCH
AGCH/PCH

17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33

AGCH/PCH
AGCH/PCH
AGCH/PCH
FCCH
SCH
SDCCH 0
SDCCH 0
SDCCH 0
SDCCH 0
SDCCH 1
SDCCH 1
SDCCH 1
SDCCH 1
FCCH
SCH
CBCH
CBCH

34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50

CBCH
CBCH
SDCCH 3
SDCCH 3
SDCCH 3
SDCCH 3
FCCH
SCH
SACCH 0
SACCH 0
SACCH 0
SACCH 0
SACCH 1
SACCH 1
SACCH 1
SACCH 1

Abbildung 5 : Kombination B5 auf Zeitschlitz 0 [Sig]

•

FCCH
Frequency Correction Channel (siehe Bursts)

•

SCH
Synchronisation Channel (siehe Bursts)

•

BCCH 0-3
Broadcast Control Channel - Downlink,
o Netzinformationen
o Kennzeichnung
o Frequenzspringen
o Voice Activity Detection
o verwendete Frequenzen (eigene + Nachbarzellen)

•

AGCH/PCH
Common Control Channel (CCCH) - Zeitschlitz 0
o Paging Channel (PCH) - Downlink
o Random Access Channel (RACH) - Uplink
o Access Grant Channel (AGCH) - Downlink

•

SDCCH 0/1/3
Stand-Alone Dedicated Control Channel - solange kein TCH betrieben wird
o Registrierung
o Authentifizierung
o Aufenthaltskoordinierung
o Verbindungseinrichtung

•

CBCH
Common Broadcast Channel

29

•

Alexandra Kirchmeier-Hürlimann

SACCH 0/1
Slow Associated Control Channel - parallel zum TCH
o Pegel und Zeitungenauigkeit der MS

Wie diese logischen Kanäle auf die physikalischen verteilt sind, kann von Zelle zu Zelle variieren und ist durch die zu erwartende Auslastung bestimmt. Die Kanalkombination wird
vom Netzbetreiber je nach erwarteter Netzauslastung der einzelnen Basisstationen (Zellen)
bestimmt und kann auch geändert werden, allerdings nicht im laufenden Betrieb.
2.1.8 Kanalcodierung
Die hohe Bitfehlerhäufigkeit auf der Luftschnittstelle auf Grund von stark schwankenden
Qualitätseigenschaften des Mobilfunkkanals machen eine effiziente Kanalcodierung nötig.
Dem Datenstrom wird, unter anderem, Redundanz zur Fehlererkennung und Behebung hinzugefügt.
Äußerer Fehlerschutz
Innerer Fehlerschutz

Blockcode

Faltungscode

Interleaving

Blockcode

Faltungscode

Interleaving

Abbildung 6: Stufen der Kanalcodierung [Eb/Vö]

•

Äußerer Fehlerschutz: Blockcodierung
Je nach Art der zu übertragenden Bursts werden unterschiedliche Generatorpolynome
verwendet, die es erlauben mehr oder weniger lange Fehlerbündel zu entdecken. Der zu
übertragende Block wird durch das Generatorpolynom geteilt und der Rest als Blockprüfzeichen an den Block angehängt.

•

Innerer Fehlerschutz: Faltungscodierung
Durch den Faltungscodierer wird Redundanz der zu übertragenden Daten erzeugt und damit die Fehlerkorrekturmöglichkeiten erheblich mitbestimmt. Die Codierungsvorschrift
kann mit Polynomen beschrieben werden und unterscheidet sich auf den verschiedenen
logischen Kanälen in der Coderate und den verwendeten Polynomen.

•

Interleaving
Auf Grund der Mobilität und damit schnell wechselnden Umweltbedingungen für den
Luftübertragungskanal, kann es trotz guter Funkverbindung zu kurzfristigen Einbrüchen
der Empfangsqualität kommen, so daß komplette Datenpakete verloren gehen. Um den
Totalverlust zu minimieren, werden die Datenpakete von 456 Bit über mehrere Bursts
verteilt. Bei Verlust zusammenhängender Bitsequenzen auf der Luft relativiert sich dieser
Fehler, da er sich auf mehrere Datenpakete verteilt und so nur noch einen Bruchteil pro
Paket ausmacht.

30

Die Funkschnittstelle von GSM
Datenblöcke nach dem Channel Coding

1

Burstformatierung

2

1

2

4|114 Bit |3

3

4

5

1

6

2

4|114 Bit |3

7

8

1

1

2

2

4|114 Bit |3

1

3

4

5

2

4|114 Bit |3

6

1

7

2

4|114 Bit |3

8

1

1

2

4|114 Bit |3

2

3

4

1

5

2

4|114 Bit |3

6

7

8

1

2

4|114 Bit |3

Senden

Abbildung 7: Interleaving bei Sprachdaten [Sig]

2.1.9 Synchronisierung
Aufgrund der verschiedenen Signallaufzeiten der verschiedenen Mobilstationen ist eine effektive Bit- und Rahmensynchronisation sehr wichtig.
Für die Frequenz- und Taktsynchronisation einer Mobilstation stellt die BTS auf dem BCCHTräger verschiedene Signale bereit:
•
•

Synchronization Channel (SCH)
Frequency Correction Channel (FCCH)

Solange die BCCH-Träger-Frequenz der Mobilstation noch nicht bekannt ist, sucht sie nach
dem stärksten Signal, da dieses mit größter Wahrscheinlichkeit, wegen der pausenlos gesendeten Dummy Bursts, die Frequenz eines BCCH-Trägers ist. Mit Hilfe der Frequency Correction Bursts kann sie sich aufsynchronisieren.
Zur zeitlichen Synchronisierung wird der lange Numerierungszyklus der TDMA-Rahmen
verwendet. Jede BTS sendet die reduzierte Nummer der TDMA-Rahmen im Synchronization
Channel (SCH) periodisch aus:
T1 = FN div (26*51)
T2 = FN mod 26
T3' =(T3 -1) div 10
Mit T3 = FN mod 51

[0..2047]
[0..25]
[0..4]
[0..50]

Abbildung 8: reduzierte Rahmennummer mit FN = Frame Number

Unter der Adaptiven Rahmensynchronisierung versteht man die Fähigkeit der Mobilstation,
ihr Sende- und Empfangsfenster der Entfernung zur BTS anzupassen. Dazu wird im SACCHBlock der Wert Timing Advance (TA) im Uplink und Downlink gesendet. Durch diesen Wert
ist die maximale Entfernung der Mobilstation zur BTS auf 35 km begrenzt.

31

Alexandra Kirchmeier-Hürlimann

2.2 Schicht 2: Die Data Link Layer
Im Unterschied zum OSI-Referenzmodell wird das Einrichten und Freigeben physikalischer
Kanäle nicht über Steuerprozeduren der Schicht 2, sondern vom Radio Ressource- (RR) Management der Schicht 3 gesteuert.

Signalisierungsebene

Nutzdatenebene

Radio Ressource Management
( Schicht 3)

Traffic Channel TCH

Sicherungsschicht
(Schicht 2)

R
A
C
H

B
C
C
H

F
A
C
C
H

S
D
C
C
H

A
G
C
H
+
P
C
H

S
A
C
C
H
Physikalische Schicht
(Schicht 1)

Abbildung 9: Dienstschnittstellen der Schicht 1 [Eb/Vö]
2.2.1 Modifiziertes Link Access Protokoll (LAPDm)
Für jeden logischen Steuerkanal ist hier ein eigener Dienstzugangspunkt (Service Access
Point SAP) definiert.
Auf der GSM-Luftschnittstelle Um wird das LAPDm-Sicherungsprotokoll, das ähnlich dem
HDLC-Protokoll ist, für Signalisierungskanäle eingesetzt.
Das LAPDm-Protokoll sieht zwei Betriebsmodi vor:
• Unbestätigter Dienst (UI-Rahmen = Unnumbered Information)
Ohne Flußkontrolle und L2-Fehlerkorrektur (für alle Singalisierungskanäle außer RACH
vorgesehen).
• Bestätigter Dienst ( I-Rahmen = Information)
Mit Fehlerkorrektur durch Wiederübertragung (ARQ) und Flußkontrolle (für DCCH vorgesehen).
Die Verbindungsendpunkte von L2-Verbindungen werden durch den Data Link Connection
Identifier DLCI beschrieben und bestehen aus den Elementen:
• SAPI (Service Access Point Identifier)
Anhand des SAPI Wertes kann die Übertragung von Signalisierungsnachrichten und paketorientierten Nutzdaten (z.B. SMS) unterschieden werden.
• CEPI (Connection End Point Identifier)
Dieser wird lokal verwaltet und ist die Kennziffer des physikalischen Kanals.

32

Die Funkschnittstelle von GSM

2.2.2 Prozeduren der Schicht 2
• Data Link Procedure
Für jeden SAP wird eine LAPDm-Instanz eingerichtet, die die Data Link Procedure bearbeitet. Zu den Funktionen dieser Prozedur gehören:
o L2-Peer-to-Peer-Kommunikation
o Zwischenschicht-Dienststelle mit zugehörigen Dienstprimitiven
o Segmentier- und Wiederzusammensetzung von L3-Nachrichten.
• Distribution Procedure
o Verteilung eines physikalisch-logischen Kanals auf mehrere SAPs (z.B. SMS)
• Random Access Procedure
o Sicherungsschicht auf RACH
Für die Kommunikation stellt das LAPDm-Protokoll mehrere Rahmenformate, mit gleicher
Länge (23 Byte), für die unterschiedlichen zu übertragenden Informationen, bereit:
• Bbis-Format:
Für Broadcast-Nachrichten ohne Header und Adressierung (nur Downlink)
• A-Format:
Dient als Füllrahmen, wenn bei aktiver Verbindung keine Nutzdaten zu übertragen sind
(Uplink und Downlink)
• B-Format:
Für tatsächliche Signalisierungsübertragung (Uplink und Downlink)
[Sig]

2.3 Schicht 3: Network layer
2.3.1

Signalisierung auf der Funkschnittstelle von GSM
TI
Flag

Messages für Call Control (CC)
Messages für Mobility Manag. (MM) und Radio Ress.Manag. (RR)

Schicht 2

Daten

Messages für Call Control (CC) und Mobility Management (MM)
Messages für Radio Ressource Management (RR)

TI-Value

Skip Ind. ‚0000'

Message Typ 8 Bit

Protoc. Discr.
Protoc. Discr.

Typ-Ident. 8 Bit

0

SSN

Message Typ

0

0

Schicht 2

Message Typ

Abbildung 10: Das Schicht 3-Format auf der Funkschnittstelle
Anhand des Protocol Discriminators (PD) werden die Nachrichten einer Dienstgruppe zugeordnet:
• Radio Ressource Management (RR)
• Mobility Management (MM)
• Call Control (CC) mit
Supplementary Services (SS)
Short Message Services (SMS)

33

Alexandra Kirchmeier-Hürlimann

Gleichzeitig wird eine unterschiedliche Behandlung von transparenten und nicht transparenten Messages ermöglicht. Für die Funkschnittstelle selbst ist vor allem das Radio Ressource
Management von erheblicher Bedeutung, das die Verwaltung der logischen und physischen
Kanäle auf der Funkschnittstelle übernimmt. Die Auswertung erfolgt abhängig vom MessageTyp in der Mobilstation, im BSS und teilweise im MSC [Sig].
2.3.2 Radio Ressource Management
Die Prozeduren des Radio Ressource Management sorgen für:
• Die Vergabe und Verwaltung von Funkressourcen
• Das Auslesen von Systeminformationen aus Rundstrahlkanälen (BCCH)
• Die Auswahl der aktuellen Zelle mit den besten Empfangsverhältnissen
Radio Subsystem Link Control
Die wichtigste Aufgabe dieser Funktionseinheit besteht in der kontinuierlichen Messung der
Empfangsqualität zur Zellenauswahl (evtl. mit erneutem Location Update) und HandoverVorbereitungen, sowie die Sendeleistungsregelung (Power Control).
Zum Senden (im Up- und Downlink) des Sendeleistungsniveaus und des Timing Advance
wird der SACCH-Kanal benutzt. Auf dem selben Kanal werden ebenfalls die Meßwerte der
Mobilstation in Form von Meassurement Reports im Uplink zur BTS gesendet.
• Meßwerterfassung und -verarbeitung
Die Kanalmessung erfolgt im Ruhezustand ebenso wie während einer stehenden Verbindung. Die Parameter zur Bestimmung der Empfangsqualität sind:
o RXLEV : Empfangsfeldstärke
o RXQUAL: Signalqualität in Bitfehlerhäufigkeit (z.B. anhand der Training Sequenzen)
• Sendeleistungsregelung
Die Sendeleistungsregelung soll ermöglichen, daß eine Mobilstation immer mit minimaler
Energie sendet, während die Signale aller Mobilstationen mit fast gleichem Pegel von der
BTS empfangen werden. Die Sendeleistung wird in Schritten von 2dBm geregelt.
Die Sendeleistung des BCCH-Trägers wird immer konstant gehalten um vergleichende
Messungen benachbarter Basisstationen, deren Liste von der aktuellen BTS zur Verfügung gestellt wird (samt BSIC), zu ermöglichen.
•

Handovervorbereitung
Die gesammelten Meßdaten der aktuellen BTS und der Nachbarzellen werden im Uplink
zur BTS gesendet, wo darüber entschieden wird, wann ein Handover sinnvoll erscheint.
Die Entscheidung darüber ob, wann, wohin, und was für ein Handover durchgeführt werden soll, liegt jedoch in der BSC und höheren Netzwerkelementen.

Darüber hinaus werden im Radio Link Control auch Konnektivitätsprüfungen durchgeführt.
Der Abbruch einer Verbindung erfolgt erst nach mehreren fehlerhaften Protokollnachrichten.

34

Die Funkschnittstelle von GSM

3 Beispiel Szenario: Mobile originated call mit anschließendem
Handover
BTS_1

MS
CCCH(RACH)/RR
CHAN_REQ[Grund, Refer.]

Channel Activation
SDCCH
CCCH(AGCH)/RR
IMM_ASS_CMD[TA.Kanal,
Refer.,FN]
SDCCH/SABM/MM
CM_SERV_REQ[MS-Daten]
SDCCH/UA/MM
CM_SERV_REQ[MS-Daten]
SDCCH/I/MM
AUTH_REQ[CKSN, RAND]
SDCCH/I/MM
AUTH_RSP[SRES]

MS

BTS_1

MS

BTS_2

FACCH/I/CC
ALLERT/PROGRESS
FACCH/I/CC
CON
FACCH/I/CC
CON_ACK

SACCH/UI/RR
MEAS_REP[DL-Mess]
SACCH
[z.B. SYS_INFO 5 oder 6]

SACCH/UI/RR
MEAS_REP[DL-Mess]
SACCH
[z.B. SYS_INFO 5 oder 6]

SDCCH/I/MM
CM_SERV_ACC[-/-]

SDCCH/I/RR
CIPH_MOD_CMD[A5/X]
SDCCH/I/RR
CIPH_MOD_COM[-/-]

FACCH/I/RR
HND_CMD[HO Ref, KanalInfo]

Channel Activation
TCH

HND_ACC
[Handover Referenz]
PHYS_INFO
[einzust. Timing Advance]

SDCCH/I/CC
SETUP[ger.Tel.No.]

HND_ACC
[Handover Referenz]
SDCCH/I/CC
CALL_PROC[-/-]

PHYS_INFO
[einzust. Timing Advance]
Channel Activation
TCH

FACCH/SABM
FACCH/UA

SDCCH/I/RR
ASS_CMD[Daten des TCH]

FACCH/SABM
FACCH/UA

FACCH/I/RR
HND_COM

35

Alexandra Kirchmeier-Hürlimann

Referenzen
[HS13]

Hubert Schmid
Vortrag 13: Sprachcodierung und Mobilfunk am Beispiel GSM
Proseminar: Redundanz

[Eb/Vö]

J.Eberspächer/H.-J. Vögel
GSM
Global System for Mobile Communication 2. Auflage,
B.G. Teubner Stuttgart - Leipzig 1999

[Sig]

Gunnar Heine
GSM-Signalisierung verstehen und praktisch anwenden,
Franzis' 1998

[GSM 05.01]

GSM (GLOBAL SYSTEM FOR MOBILE COMMUNICATIONS)
Digital cellular telecommunications system (Phase 2+);
Physical Layer on the Radio Path (General Description)
(GSM 05.01 ,Release 1999),
Draft ETSI

[WS00]

Wolfgang Schönfeld
Funknetze,
GMD IPSI 2000

Mobilfunk der dritten Generation: UMTS
Meilin Schaper

Meilin.Schaper@dlr.de
Zusammenfassung: In diesem Dokument werden die Anforderungen an ein Mobilfunksystem der dritten Generation genannt und ein Einblick in das Universal Mobile Telecommunication System (UMTS), ein Vertreter der dritten Generation, gegeben. Die Zellstruktur, die Datenraten, die Frequenzen und das gegenüber der zweiten Generation neue
Zugriffsverfahren werden vorgestellt. Die Architektur wird beschrieben und abschließend
wird eine aktuelle Einschätzung gegeben.

1 Vorwort
Scherzhaft:
„Was für den einen 'Universal Mobile Telecommunication System' bedeutet, bedeutet für
den Bundesfinanzminister Hans Eichel 'unvermutete Mehreinnahmen zur Tilgung von
Staatsschulden'.“ [5]

2 Einleitung
UMTS gehört zur sogenannten dritten Generation von Mobilfunksystemen.
Es ist die europäische Variante des IMT-2000 (International Mobile Telecommunication
2000), das in Nordamerika üblich ist [4]. Es sollte ein globales Mobilfunksystem entstehen,
das weltweites „International Roaming“ ermöglicht. Als Anwendungen werden mobiler
e-Commerce, Multimedia-Kommunikation mit Sprache, Schrift, Bildern und Videos, sowie
mobiles Internet mit einer Weiterentwicklung von WAP angestrebt.
Aus Preisgründen wird der Durchbruch auf dem Privatkundenmarkt jedoch nicht vor 2010
erwartet.

3 Anforderungen an Systeme der dritten Generation
An Systeme der dritten Generation werden hohe Anforderungen gestellt:
• Unterstützung verschiedener Dienste mit wahlweise kanal- oder packetvermittelter
Übertragung.
• Integration der Satellitenanbindung zur weltweiten Kommunikation.
• Verschiedene Bitraten (niedrige für Sprache, bis zu 2 Mbit/s für MultimediaAnwendungen).
• Variable Bitrate mit dynamischer Anpassung der Dienstgüte an die aktuellen
Möglichkeiten des Funkkanals.
• Einsatz in unterschiedlich großen Zellen.
• Flexibles Frequenzmanagement.
• Flexibles Management der Funkbetriebsmittel.
• Hohe Systemkapazität.
• Unterstützung von asymmetrischem Datenverkehr.

38

Mobilfunk der dritten Generation: UMTS
•
•

Realisierung eines Virtual Home Environment: Die Benutzeroberfläche ist unanhängig
vom Netz und speichert die nutzerspezifische Konfiguration.
Konvergenz von Fest- und Mobilfunknetz: Befindet sich der Teilnehmer in der Nähe
eines Festnetzanschlusses, wird er dort automatisch angemeldet und telefoniert mit
Festnetztarif über das Festnetz. Das Handy arbeitet als Schnurlostelefon. Dies bedeutet
auch, dass der Teilnehmer eine persönliche Rufnummer unabhängig von der Netzumgebung besitzt.

4 Funk- und Trägernetz
Die Entwicklung von UMTS hat zwei Gesichtspunkte: das Funknetz und das Trägernetz.
Zum Funknetz gehören
• die Mobilstation (Handy)
• die Basisstation (Funkübertragungseinrichtung und Steuereinrichtung)
• die Funkschnittstelle zwischen Basis- und Mobilstation
Das Trägernetz verbindet die Basisstationen untereinander und mit anderen Netzen (z.B.
ISDN, Internet).
Das Trägernetz von UMTS ist eine Weiterentwicklung des Trägernetzes von GSM, das Funknetz ist jedoch eine Neuentwicklung. In der Anfangszeit von UMTS wird es ein mit GSM gemeinsames Trägernetz, aber getrennte Funknetze geben [1]. Das UMTS Funknetz wird aufgrund einer größeren Bandbreite der Frequenzkanäle (5 MHz) und eines neuen Übertragungsverfahrens (WCDMA) Multimedia-Anwendungen ermöglichen, da es Daten mit bis zu
2 Mbit/s übertragen wird.

5 Hierarchische Zellstruktur
UMTS wird weltweites Roaming ermöglichen. Zu diesem Zweck ist das Funknetz hierarchisch aufgebaut.

Abbildung 1: Hierarchischer Aufbau des UMTS Funknetzes [1]

Das erdgestützte Funknetz wird UTRAN (UMTS Terrestrial Radio Access Network) genannt
und ist in Makro-, Mikro- und Pikozellen unterteilt.
Je niedriger die Hierarchieebene der Zelle, desto kleiner ihr Radius. Kleinere Zellen erlauben
eine größere Teilnehmerdichte. In dicht besiedelten Gebieten wird es Mikrozellen und zur flächendeckenden Grundversorgung Makrozellen geben. Um der hohen Teilnehmerdichte in

39

Meilin Schaper

sog. „Hot Spots“ gerecht zu werden, wird es in Gebäuden wie Bahnhofshallen oder Flughäfen
und bei Bedarf auch in anderen Gebäuden Pikozellen geben.

6 Datenraten
In jeder Hierarchieebene gibt es unterschiedliche maximale Datenraten und größtmögliche
Teilnehmergeschwindigkeiten.
Makroebene: Es sollen mindestens 144 kbit/s bei maximal 500 km/h übertragen werden können.
Mikroebene: Bei einer Geschwindigkeit von maximal 120 km/h werden 384 kbit/s möglich
sein.
Pikoebene: Dem Teilnehmer werden bei maximal 10 km/h bis zu 2 Mbit/s zur Verfügung gestellt.

7 Frequenzspektren
Die Strecke von der Mobilstation zur Basisstation wird als Uplink bezeichnet, die Strecke von
der Basisstation zur Mobilstation als Downlink.
Die Frequenzspektren für UMTS liegen zwischen 1900 MHz und 2025 MHz sowie zwischen
2110 MHz und 2200 MHz. Für Kommunikation über Satellit ist im UMTS Spektrum ein
eigener Bereich festgelegt: Uplink 1980 MHz bis 2010 MHz, Downlink 2170 MHz bis
2200 MHz.
Für den terrestrischen Bereich werden die Frequenzen auf die beiden Betriebsarten Frequenzduplex (FDD Frequency Division Duplex) und Zeitduplex (TDD Time Division Duplex) aufgeteilt.

Abbildung 2: Das Frequenzspektrum [1]

Dem FDD-Betrieb werden zwei gleich große Bänder für Aufwärts- und Abwärtsstrecke zugewiesen (Uplink 1920 MHz-1980 MHz, Downlink 2110 MHz-2170 MHz). Er eignet sich damit vorwiegend für symmetrische Dienste, z.B. Telefonie.
Im TDD Betrieb werden Up- und Downlink durch verschiedene Zeitschlitze realisiert. Daher
benötigt man kein symmetrisches Spektrum und benutzt die verbleibenden Frequenzen
(1900 MHz bis 1920 MHz und 2010 MHz bis 2025 MHz). Diese Betriebsart bietet sich für
Internetanwendungen an.

8 Dienste und Applikationen
Die bekannteste Neuerung bei UMTS gegenüber den Systemen der 2. Generation ist die höhere Bitrate. Höhere Bitraten ziehen Forderungen nach neuen Applikationen nach sich wie
zum Beispiel nach Videotelefonie oder schnellem Download von Daten. (Die Umkehrung gilt
auch: Neue Anwendungen fordern auch eine höhere Bitrate.) Eine weitere wichtige Neuerung
gegenüber GSM ist die Möglichkeit, Parameter wie Bitfehlerrate oder maximale Verzögerung
der Funkübertragung zu verhandeln. Um erfolgreich eingesetzt werden zu können, muss
UMTS eine große Breite an Applikationen unterstützen, die verschiedenen Quality of Service
(QoS) Beschränkungen entsprechen. UMTS muss sowohl bestehende Applikationen unterstützen wie auch die Entwicklung neuer Applikationen ermöglichen und fördern.

40

Mobilfunk der dritten Generation: UMTS

UMTS unterstützt folgende QoS-Klassen:
• Conversational:
Beispiele: Sprach-, Videotelefonie, Videospiele
Charakteristik: Hält die Zeitrelationen zwischen Informationen auf dem Stream ein,
knappe und kurze Verzögerung.
• Streaming:
Beispiele: Ansehen von Videos oder Anhören von Musik, Übertragung nur in eine
Richtung.
Charakteristik: Hält die Zeitrelationen zwischen Informationen auf dem Stream ein.
• Interactive:
Beispiele: Web-Browsing, Spiele über das Netz
Charakteristik: Erfordert Antwortschema, hält die Daten unversehrt.
• Background:
Beispiele: Download von Emails im Hintergrund
Charakteristik: Das Ziel erwartet die Daten nicht innerhalb einer bestimmten Zeit, hält
die Daten unversehrt.

9 Vielfachzugriff
Das Vielfachzugriffsverfahren bei UMTS besteht aus Kombinationen der Vielfachzugriffsverfahren TDMA, FDMA und CDMA.

9.1 CDMA
Im Codemultiplex-Verfahren werden die Kanäle weder durch Frequenzbereiche noch durch
Zeitschlitze getrennt. Es wird ein schmalbandiges Funksignal in einem breiten Frequenzspektrum übertragen. Das schmalbandige Signal wird dabei durch eine Codiervorschrift auf ein
breitbandiges Signal abgebildet (Codespreizung).

Frequenz

Code
User 4
User 3
User 2
User 1

B

Zeit
Abbildung 3: Codemultiplexverfahren (in Anlehnung an [2])

Jedem Benutzer des Funkkommunikationssystems wird eine Codiervorschrift zugewiesen, die
das zu übertragene Signal auf ein Vielfaches der Originalbrandbreite spreizt. Die so erhaltenen Signale werden zeitgleich im gleichen Frequenzband übertragen. Die Codiervorschriften
müssen so gewählt werden, dass die Interferenzen beim Empfänger möglichst klein bleiben.
Hierzu wird der orthogonale Pseude Noise (PN) Code zur Trägermodulation verwendet.

41

Meilin Schaper

Der Empfänger, der die Codiervorschrift seines Senders kennen muss, kann sich auf den
Codekanal des Senders synchronisieren und das Signal wieder in Originalbreite wandeln.
Die Signale der anderen Sender werden nicht auf Originalbreite transformiert und tragen zum
Rauschpegel des empfangenen Signals bei.
Auch bei CDMA-Verfahren ist die Anzahl der Teilnehmer begrenzt, die denselben Kanal verwenden, da das Signal-zu-Rausch-Verhältnis den zur Rücktransformation erforderlichen Wert
unterschreiten kann.
Ein Vorteil des CDMA-Verfahrens ist, dass durch die Kodierung die Teilnehmerdaten verschlüsselt übertragen werden. Zum Entschlüsseln muss die Codiervorschrift des Senders bekannt sein.
Nachteile
des
CDMA-Verfahrens
sind,
dass
beim
Senden
mehrerer
Stationen gleichzeitig statistische Überlagerungen entstehen, die Fehlererkennung und -korrektur erfordern. Um zu verhindern, dass Nutzsignale stark einfallender Sender die Signale
der schwächeren überdecken, ist eine schnelle Leistungssteuerung nötig.

9.2 Einsatz in UMTS
Im FDD-Modus erfolgt der Vielfachzugriff durch eine Kombination von CDMA und FDMA.
Einzelne Teilnehmersignale werden durch verschiedene Spreizcodes und Frequenzen von einander getrennt. Der Frequenzabstand zweier FDMA Kanäle beträgt beim UMTS eingesetzten
WCDMA-Verfahren 5 MHz, kann jedoch in 200-kHz-Schritten auf 4,4 MHz verringert werden (zum Vergleich: Bei normalem CDMA beträgt der Abstand 1 MHz). Für die meisten physikalischen Kanäle ist ein FDMA-Rahmen in 10 ms Rahmen eingeteilt. Dieses dient nicht der
Trennung von Teilnehmersignalen, sondern zur Übermittlung periodischer Funktionen wie
beispielsweise Anpassung der Übertragungsrate. Variable Übertragungsraten erhält man
durch Multicode-Übertragung oder Änderung des Spreizfaktors.
Die Kombination von CDMA und FDMA ist in Abbildung 4 dargestellt.

Abbildung 4: Vielfachzugriff als Kombination aus CDMA und FDMA [2]

42

Mobilfunk der dritten Generation: UMTS

Im TDD-Modus erfolgt der Vielfachzugriff aus einer Kombination von CDMA und TDMA.
Ein TDMA-Rahmen ist in 15 Zeitschlitze unterteilt und hat ebenfalls eine Dauer von 10 ms.
In jedem Zeitschlitz können bis zu 16 CDMA Kanäle realisiert werden. Die einzelnen Zeitschlitze können unabhängig voneinander jeweils der Auf- oder der Abwärtsstrecke zugewiesen sein, sodass die Funkbetriebsmittel bei stark unsymmetrischen Verkehr optimal verteilt
werden können. Variable Übertragungsraten werden im TDD-Modus durch Multicode oder
Multislot-Übertragung realisiert. Auf der Aufwärtsstrecke eines UE können jedoch nur maximal 2 Codekanäle parallel genutzt werden.
Der Vielfachzugriff im TDD-Modus ist in Abbildung 5 dargestellt.

Abbildung 5: Vielfachzugriff als Kombination von CDMA und TDMA [2]

10 UMTS-Architektur
Der prinzipielle Aufbau von UMTS und seine Aufteilung in verschiedenen Bereiche, sog. Domains, basiert eher auf der physikalischen als auf der funktionalen Trennung einzelner Bereiche [2].
Die Abbildung 6 stellt die Architektur des UMTS mit den verschiedenen Bereichen und den
entsprechenden Schnittstellen dar.

43

Meilin Schaper

Home
Network
Domain

Zu
Cu
USIM
Domain

Uu
Mobile
Equipment
Domain

Iu
Access
Network
Domain

Yu
Serving
Network
Domain

Transmit
Network
Domain

Core Network Domain
User Equipment Domain

Infrastructure Domain

Abbildung 6: UMTS Architektur (in Anlehnung an [2])

10.1 User Equipment Domain
Das User Services Identity Module (USIM) enthält Informationen und Funktionen, die zur
Verschlüsselung und Identifikation des Endgerätes gegenüber dem Netz nötig sind. Physikalisch ist das USIM auf einer SIM-Karte untergebracht. Am Bezugspunkt Cu ist die SIM-Karte
mit dem Endgerät verbunden, am Punkt Uu ist das mobile Endgerät über die Luftschnittstelle
mit dem Zugangsnetz im Infrastrukturbereich gekoppelt. Alle zur Funkübertragung benötigten
Funktionen enthält das Endgerät im mit Mobile Termination (MT) bezeichneten Teil. Die
Teilnehmerschnittstelle, über die Ende-zu-Ende Verbindungen zwischen Anwendungen realisiert sind, befindet sich im mit Terminal (TE) bezeichneten Teil.

10.2 Access Network Domain
Die Aufgabe des Zugangsnetzes (Access Networt Domain, AND) ist, den Teilnehmern den
Zugang zum UMTS-Netz zu ermöglichen und die Verbindung zum Transportnetz zu realisieren. Die AND ist entweder durch ein UTRAN oder durch ein GSM-BSS realisiert.

10.3 Core Network Domain
Die Core Network Domain (CND) kann aus verschiedenen Transportnetzen, z.B. GSM- oder
B-ISDN-Transportnetzen, bestehen, die über Netzübergänge miteinander verbunden sind. Die
CND ist in die Teilbereiche Serving Network Domain (SND), Transmit Network Domain
(TND) und Home Network Domain (HND) unterteilt.
Die Serving Network Domain ist am Bezugspunkt Iu mit dem Zugangsnetz verbunden und
beinhaltet alle für den Teilnehmer ortsabhängigen Funktionen, die der Bewegung des Teilnehmers durch das Netz folgen. Außerdem ist sie für die Vermittlung von leitungs- und paketvermittelten Verbindungen zuständig.
Für die Funktionen des Transportnetzes, die einen Bezug zu einem festen, vom Aufenthaltsort
des Teilnehmers unabhängigen Ort haben, ist die Home Network Domain zuständig. Das betrifft Funktionen zur Verwaltung der für einen Teilnehmer signifikanten Informationen oder
ortspezifischen Diensten, die nicht von der Serving Network Domain angeboten werden. Die
Dienste sogenannter Service Provider sind in der Home Network Domain angesiedelt.
Die Transmit Network Domain realisiert die Schnittstelle zu anderen Netzen.

44

Mobilfunk der dritten Generation: UMTS

11 Die Zugangsebene

Nt

GC

Nt

DC

GC

DC

Nt

DC

Relay
GC

Nt

DC

GC

Nt

DC

GC

Uu Stratum

UE

Uu

Nt

DC

Access Stratum

GC

Iu Stratum

UTRAN

Iu

Core Network

Abbildung 7: Die Zugangsebene mit UTRAN (in Anlehnung an [2])

Die beiden Protokollstapel an den Bezugspunkten Uu und Iu bilden die Zugangsebene
(Access Stratum). Abbildung 7 zeigt ihre Einordnung in die UMTS-Architektur.
Die Zugangsebene dient zur transparenten Übertragung zwischen der Core Network Domain
und der User Equipment Domain.
Über folgende Dienstzugangspunkte werden Dienste angeboten:
General Control (GC): Innerhalb eines geographischen Gebiets wird über diesen Dienstzugangspunkt ein unbestätigter Verteildienst zur Übermittlung von nicht nutzerspezifischen Informationen an Endgeräte erbracht.
Notification (Nt): Dieser Dienstzugangspunkt stellt Verteildienste zur unbestätigten Übertragung von nutzerspezifischen Informationen zur Verfügung. Über den Nt-Dienstzugangspunkt werden Funkruf- und Benachrichtigungsdienste realisiert.
Dedicated Control (DC): Rufauf- und Abbau sowie Nutzdatenübertragung werden über diesen Dienstzugangspunkt realisiert. Der Rufaufbaudienst bietet die Möglichkeit,
gleich beim Rufaufbau Nachrichten zu übermitteln. Den einzelnen Übertragungsdiensten können Dienstgüten zugewiesen werden.

11.1 Das Kernnetz
Das Kernnetz (Core Network) ist logisch in eine Circuit Switched Domain (CSD) für kanalvermittelte Dienste und eine Packet Switched Domain (PSD) für paketvermittelte Dienste aufgeteilt. Die Iu-Schnittstelle zwischen Kernnetz und UTRAN wird daher in IuCS und IuPS unterteilt.
Abbildung 8 beinhaltet unter anderem den funktionalen Aufbau des Kernnetzes. Zur Circuit
Switched Domain gehören das Mobile-services Switching Centre (GMSC) und das Visitor
Location Register (VLR). Der Serving GPRS Support Node (SGSN) und der Gateway GPRS
Support Node (GGSN) gehören zur Packet Switched Domain. Die funktionalen Elemente des
Kernnetzes in der Circuit Switched Domain entsprechen im wesentlichen denjenigen des
GSM und in der Packed Switched Domain denjenigen des General Packet Radio Service
(GPRS).

45

Meilin Schaper

User
Equipment
(UE)

cell

IuCS

oder

cell

U
S
I
M

Mobileservices
Switching
Centre
(MSC)

Radio
Network
Controller
(RNC)

cell

ME

U
S
I
M

Core Network

Radio Network Subsystem (RNS)

Node B
Iub

Gateway
Mobileservices
Switching
Centre
(GMSC)

Visitor
Location
Register
(VLR)

Iur
RNS

HLR

AuC

cell

EIR

cell

ME
oder
U
S
I
M

cell

U
S
I
M

Radio
Network
Controller
(RNC)

Node B

IuPS

cell

oder
U
S
I
M

cell

U
S
I
M

Gateway
GPRS
Support Node
(GGSN)

cell

ME

Serving
GPRS
Support Node
(SGSN)

Node B
Uu

Iu

Abbildung 8: Die Architektur der Zugangsebene (in Anlehnung an [2])

11.2 UMTS Terrestrial Radio Access Network (UTRAN)
Mit UMTS Terrestrial Radio Access Network (UTRAN) werden die Funktionen und Protokolle der Datenübertragung über das terrestrische Funknetz innerhalb der Access Network Domain bezeichnet. Hierzu gehören die Protokolle am Bezugspunkt Uu zwischen dem Mobile
Termination der UE und der Access Network Domain und die Protokolle am Bezugspunkt Iu
zwischen Access Network Domain und dem Transportnetz. Das UTRAN beinhaltet daher die
Instanzen der Uu- und Iu-Protokollstapel.

11.3 Funktionaler Aufbau des UTRAN
Das UTRAN besteht aus mehreren Funkteilsystemen (Radio Network Subsystem, RNS), die
jeweils über die Iu-Schnittstelle mit dem Transportnetz CN verbunden sind. Zu jedem Funkteilsystem gehören ein Radio Network Controller (RNC) und ein oder mehrere Node B
(Basisstationen). Ein Node B ist über die Iub-Schnittstelle mit dem Radio Network Controller
verbunden. Er ist für die Funkübertragung in einer oder mehreren Zellen verantwortlich. Zum
User Equipment enthält der Node B nur die physikalische Schicht.
Jeder Verbindung zwischen einem User Equipment und dem UTRAN ist ein RNC im Serving
Radio Network Subsystem (SRNS) zugeordnet. Ein RNC, von dem bei Bedarf einer Verbindung weitere Funkbetriebsmittel zur Verfügung gestellt werden, wird als Drift Radio Network
Subsystem (DRNS) bezeichnet. Die zwischen SRNS und DRNS bestehende Verbindung um
Bezugspunkt Iur wird auf die Iu-Schnittstelle abgebildet. Zwischen User Equipment und Core
Network bestehende Ende-zu-Ende-Verbindungen gehen nur über die Iu-Schnittstelle am
SRNS.

46

Mobilfunk der dritten Generation: UMTS

11.4 Funktionen des UTRAN
Hier wird nur eine Auswahl der Funktionen des UTRAN erläutert, da eine detailliertere Beschreibung der Funktionen den Rahmen dieses Vortrags sprengen würde.
Admission Control: Die Admission Control-Funktion ist im Serving Radio Network Subsystem angesiedelt. Sie entscheidet über Belegungen der Funkbetriebsmittel. Dies umfasst
die Zugangskontrolle bei neuen Verbindungen und Neukonfiguration bei bestehenden
Verbindungen.
System Information Broadcasting: Durch diese Funktion wird die Mobilstation mit allen
zum Betrieb notwendigen Informationen der Zugriffsebene und höherer Ebenen versorgt.
Handover: Die Mobilitätsverwaltung an der Luftschnittstelle wird durch die Handover-Funktion realisiert. Weiterhin wird die Handover-Funktion dazu benutzt, die vom Core Network geforderte Dienstgüte einzuhalten. Die Dienstgüte wird entweder vom Netz oder
vom User Equipment gesteuert. Die Handover-Funktion im UTRAN erlaubt eine Verbindungsweiterleitung in andere Netze sowie von anderen Netzen ins UTRAN, z.B. bei
einem GSM/UMTS Handover.
Makrodiversität: Diese Funktion erlaubt die Vervielfältigung von Datenströmen und die
Übertragung über mehrere physikalische Kanäle in verschiedenen Zellen gleichzeitig zu
einem Endgerät. Umgekehrt dient es auch dazu, von einer Mobilstation gesendete Daten
an mehreren Basisstationen zu empfangen und wieder zusammen zu führen. Die Funktion der Makrodiversität befindet sich im UTRAN und wird nur im FDD-Modus angewendet.

12 Die Funkschnittstelle
Am Bezugspunkt Uu ist der Protokollstapel in Bitübertragungs-, Sicherungs- und Vermittlungsschicht unterteilt.
Die Sicherungsschicht zerfällt in
• Medium Access Control (MAC),
• Radio Link Control (RLC),
• Packet Data Convergence Protocol (PDCP) und
• Broadcast/Multicast Control (BMC).
Die Vermittlungsschicht gliedert sich in
• Radio Resource Control (RRC) und
• Duplication Avoidance,
wobei nur die RRC-Schicht auch im UTRAN endet.

47

Meilin Schaper
GC

Nt

DC

Duplication Avoidance
GC

Nt

DC

Steuerung

Steuerungsebene

Nutzerebene
control

Schicht 3/RRC

control

control
Messwerte

Messwerte

Steuerung

RRC

PDCP

Schicht 2/PDCP

PDCP
BMC

RLC

Schicht 2/BMC

RLC

RLC

RLC

RLC

RLC

RLC

Schicht 2/RLC

RLC

logische
Kanäle

MAC

Schicht 2/MAC
Transport
Kanäle

PHY

Schicht 1
physikalische
Kanäle

Abbildung 9: Aufbau der Schichten (in Anlehnung an [2])

Abbildung 9 zeigt den Protokollstapel am Bezugspunkt Uu. Ellipsen zwischen den Schichten
symbolisieren die Orte der Dienstzugangspunkte für die Kommunikation mit den jeweiligen
Partnerinstanzen.
Die korrespondierende Instanz der Duplication Avoidance gehört nicht zum UTRAN, sondern
wurde ins Core Network ausgelagert.
In der Vermittlungsschicht (Schicht 3) wird zwischen Steuerungs- und Nutzerebene unterschieden. Die Packet Data Convergence Protocol- und die Broadcast/Multicast ControlSchicht gehören ausschließlich zur Nutzerebene.
Die Radio Resource Control-Schicht steuert und verwaltet die Nutzung der Funkbetriebsmittel und hat daher Zugangspunkte zu allen anderen Schichten, um deren Konfiguration zu steu-

48

Mobilfunk der dritten Generation: UMTS

ern. Die Steuerdienstzugangspunkte dienen nicht der Kommunikation mit den Partnerinstanzen, sondern ausschließlich der Kommunikation der Schichten desselben Protokollstapels.
Um entsprechend steuern zu können, müssen von der physikalischen- und der MAC-Schicht
Messwerte an die Radio Resource Control-Schicht geliefert werden.
Solange sich bei Verbindungen vom Core Network zum UTRAN am Bezugspunkt Iu nichts
ändert, muss das UTRAN eine verlustfreie Übertragung garantieren. Dies gilt auch für ein
Handover innerhalb eines Serving Radio Network Subsystems. Diese Sicherung wird von der
Radio Link Control-Schicht übernommen. Bei einem SRNS-Wechsel übernimmt die Duplication Avoidance Schicht die Funktion, dass keine Daten verloren gehen.
Übertragungsdienste der Bitübertragungschicht werden an den Dienstzugangspunkten über
Transportkanäle, die Dienste der MAC-Schicht über logische Kanäle erbracht. Für jedes User
Equipment gibt es in der Steuerungsebene genau einen Dienstzugangspunkt der RLC- und der
MAC-Schicht.

13 Ausblick
Auch wenn die Systeme der dritten Generation noch nicht eingesetzt werden, wird schon über
die vierte Generation nachgedacht. UMTS ist wie GSM ein Sprachtelefoniesystem, das auch
Daten übertragen kann.
Ebenso wird das „Universal“ seinem Namen nicht gerecht. Parallel zu den Arbeiten in Europa
definierte die ITU (International Telecommunication Union) die Anforderungen und Systemparameter für ein globales Future Public Land Mobile Telecommunication System
(FPLMTS), das auch unter dem Namen IMT-2000 bekannt ist. Es enthält fünf verschiedene
Funkschnittstellen, von denen in Amerika, Asien und Europa unterschiedliche benutzt werden. Außerdem wird erwartet, dass die Netzbetreiber, die keine UMTS-Lizenz ersteigern
konnten, auf EDGE setzen. Ob sich UMTS gegen diese Konkurrenz durchsetzt, bleibt abzuwarten.
[6]

49

Meilin Schaper

14 Abkürzungen
AND
BMC
CDMA
CN
CND
CSD
DC
DECT
DRNS
EDGE
FDD
FDMA
FPLMTS
GC
GGSN
GMSC
GPRS
GSM
HND
ISDN
MAC
ME
MSS
MT
Nt
PDCP
PSD
QoS
RLC
RNC
RNS
RRC
SGSN
SND
SRNS
TDD
TDMA
TE
TND
UE
UMTS
USIM
UTRAN
VLR
WAP
WCDMA

Access Network Domain
Broadcast/Multicast Control
Code Division Multiple Access
Core Network
Core Network Domain
Circuit Switched Domain
Dedicated Control
Digital European Cordless Telecommunications
Drift Radio Network Subsystem
Enhanced Datarates for GSM Evolution
Frequency Division Duplex
Frequency Division Multiple Access
Future Public Land Mobile Telecommunication System
General Control
Gateway GPRS Support Node
Mobile-services Switching Centre
General Packet Radio Service
Groupe Speciale Mobile
Home Network Domain
Integrated Services Digital Network
Medium Access Control
Mobile Equipment
Mobile Satellite Service
Mobile Termination
Notification
Packet Data Convergence Protocol
Packet Switched Domain
Quality of Service
Radio Link Control
Radio Network Controller
Radio Network Subsystem
Radio Resource Control
Serving GPRS Support Node
Serving Network Domain
Serving Radio Network Subsystem
Time Division Duplex
Time Division Multiple Access
Terminal
Transmit Network Domain
User Equipment
Universal Mobile Telecommunication System
User Services Identity Module
UMTS Terrestrial Radio Access Network
Visitor Location Register
Wireless Application Protocol
Wideband Code Division Muliple Access

50

Mobilfunk der dritten Generation: UMTS

Referenzen
[1]

Thomas Neubauer, Arbeitsgruppe Mobilkommunikation, TU Wien:
www.nt.tuwien.ac.at/mobile/Projects/UMTS/de/

[2]

Walke, Bernhard: Mobilfunknetze und ihre Protokolle, Band 1: Grundlagen, GSM,
UMTS und andere zellulare Mobilfunknetze, Teubner-Verlag

[3]

Holma, Harri; Toskala, Antti: WCDMA for UMTS, Wiley&Sons-Verlag

[4]

Andreas Blecher: www.blecher-ing.de/umts/index.html

[5]

Wolfgang Schönfeld, TU Darmstadt:
www.darmstadt.gmd.de/mobile/teaching/courses/mobinkom/2Funk/W-WAN.htm

[6]

Richard Sietmann: Quo Vadis, Mobilfunk?, c't 5/2001, Heise-Verlag

Die Schnurlos-Technologie am Beispiel von DECT
Gerhard Dittmaier

Gerhard.Dittmaier@Fernuni-hagen.de
Zusammenfassung: DECT ist eine standardisierte drahtlose Übertragungstechnik. Der
Datentransfer erfolgt bidirektional über eine Funkschnittstelle. Die KommunikationsDienste sind innerhalb eines Protokollstacks in 4 Schichten angeordnet und bieten die
Möglichkeit der mobilen digitalen Sprach- und Datenübertragung. Durch Standardisierung ist die Interoperabilität von Komponenten unterschiedlicher Hersteller sichergestellt,
womit mobile Systeme auch außerhalb ihres normalen Aufenthaltsortes genutzt werden
können. Innerhalb DECT wird durch System- bzw. Benutzer-Authentifizierung und der
Möglichkeit der Verschlüsselung auf der Luftschnittstelle ein hoher Sicherheitsstandard
bei Zugang und Übertragung erreicht.

1 Überblick
1.1 Einleitung
In den Anfängen der Telekommunikation waren Laufburschen und optische Signale (Flaggen,
Licht, Rauch) die einzigen Möglichkeiten, um Informationen über Entfernungen hinweg zu
transportieren. Mit wachsenden Anforderungen an Geschwindigkeit und zunehmender Informationsfülle wurden praktikablere Methoden zur Datenübertragung entwickelt.
Ein Meilenstein war die erste drahtgebundene Übermittlung mittels Telegraph und Morsealphabet am 24.05.1844. Die Technologie hat sich weiter verbessert und bald gab es Geräte,
die wie Schreibmaschinen benutzt werden konnten und mit denen Textübertragung zu einem
entfernten Empfänger möglich war. Einige Dinge haben sich seit der Erfindung des Fernschreibers verändert, so daß nun auch drahtlose Kommunikation möglich ist.
Am Beispiel von DECT wird hier ein Einblick in die Schnurlos-Technologie gegeben.

1.2 DECT, was ist das?
DECT ist eine drathlose digitale Zweiwege-Übertragungstechnik mit niedriger Leistung. Sie
hat sich in den 80er Jahren im Bereich schnurloser Telefone in Europa entwickelt. Nach Festlegung von Spezifikationen für die Funk-Übertragung stand die Abkürzung anfangs für
Digital European Cordless Telephone. Seither hat sich die Bedeutung zweimal geändert. Zuerst wurde sie geändert in Digital European Cordless Telecommunications, womit der zunehmenden Anzahl Nicht-Telefonie Anwendungen in DECT Rechnung getragen wurde.
Schließlich wurde 1996 eine Änderung zu Digital Enhanced Cordless Telecommunications
vorgenommen, da sich die Technologie in immer mehr außereuropäischen Ländern durchgesetzt hat. Das Äquivalent in den U.S.A. ist PWT (Personal Wireless Telecommunications).
Der DECT-Standard ist seit 1992 verfügbar und wurde 1996 um GAP (Generic Access
Profile) erweitert, um die Interoperabilität der Komponenten verschiedenster Hersteller bei

52

Die Schnurlos-Technologie am Beispiel von DECT

der Sprachübertragung sicher zu stellen. Mittlerweile hat die Zahl der Anwendungen für
DECT u.a. auch im Bereich Datenübertragung zugenommen.

1.3 Spezifikationen
DECT beschreibt in erster Linie Standards für Zugangsverfahren in digitalen drahtlosen Kommunikationssystemen (z.B. Funkschnittstelle), nicht die Systeme selbst oder ihre Applikationen.
Im DECT-Standard spezifizierte Teilbereiche:
• Koexistenz-Parameter und Prozeduren der Funkschnittstelle zur Sicherstellung der gegenseitigen Nichtbeeinflussung bei Betrieb im selben Frequenzspektrum.
• Interne (Punkt-zu-Punkt) Operationen zwischen Fest- und Mobilstation, die drahtlose
Kommunikationsdienste anbieten.
• Schnittstelle zur Applikation für Nutzung der angebotenen Kommunikationsdienste.
Zur Einordnung von DECT ist folgende Übersicht (s. Abb. 1.1) hilfreich:

Abb. 1.1: Einordnung von DECT

In größeren Anlagen mit mehreren Funkzellen und Feststationen, wird die Kommunikation
mit den Mobilstationen über ein intelligentes Mobilitäts-Managementsystem geführt, das für
die Funkzellen jeweils eine Funkstation (RFP, radio fixed part) und für mehrere RFPs eine
zentrale Kontrolleinheit (CCFP, central control fixed part) hat. Funkstation und Kontrolleinheit bilden zusammen den festen Endpunkt (FT, fixed termination) der Funkstrecke (s. Abb.
1.2).

53

Gerhard Dittmaier

Abb. 1.2: DECT im Kommunikationssystem

Das Mobilitäts-Management (MM, mobility management) ist als Applikation im lokalen
Kommunikationsnetz enthalten und wird, anders als beispielsweise bei GSM, nicht direkt
durch die DECT-Standards spezifiziert. Festgelegt ist lediglich eine Menge von Diensten, die
den Anwendungen für Mobilitäts-Management zur Verfügung gestellt werden.

2 DECT Schichtenmodell
Im DECT-Modell werden 4 Schichten unterschieden, die den unteren 3 Schichten des OSIReferenz-Modells ziemlich ähnlich sind (s. Abb. 2.1).

Abb. 2.1: Vergleich zwischen DECT- und OSI-Schichtenmodell

Neben den verschiedenen Schichten gibt es noch ein Lower Layer Management, welches für
Dienste verantwortlich ist, die nicht innerhalb der 4 Schichten definiert sind. Oberhalb von
MAC erfolgt eine Unterteilung der Schichten in C-Plane (Control-Daten) und U-Plane (UserDaten).
Über dem Network Layer ist die Internetworking Unit (IWU) angesiedelt, die als Schnittstelle
für Applikationen der höheren Ebene dient und diesen den Zugang zum Netzwerk gewährt.
Prinzipiell kann deshalb jedes drahtlose System (i.S. Applikation) durch Austausch der IWU
an jedes Übertragungsmedium angeschlossen werden.

54

Die Schnurlos-Technologie am Beispiel von DECT

Abb. 2.2: Datenfluß zwischen den Schichten

Abb. 2.2 gibt einen Überblick über die Datenflüsse innerhalb der Schichten und Typ sowie
Struktur der Nachrichten, die zwischen gleichen Ebenen ausgetauscht werden.

3 Physical Layer PHL
Der Physical Layer ist verantwortlich für die Aufteilung des Funkübertragungsbereichs in
physikalische Kanäle und den Transfer der übergebenen Daten.

3.1 Frequenzaufteilung
Die Übertragung erfolgt in Europa in einem 20 MHz breiten Frequenzband im Bereich
1,88-1,90 GHz. Innerhalb dieses Spektrums stehen 10 Funkkanäle von je 1,728 MHz Bandbreite mit Trägerfrequenzen fc
fc := 1897,344 MHz - c * 1,728 MHz

;

c = 0..9

zur Verfügung (s. Abb. 3.1). Jedes den DECT-Standard unterstützende Gerät kann auf allen
diesen Frequenzen arbeiten.

Abb. 3.1: Aufteilung des Funk-Spektrums

Die Modulation erfolgt für jedes einzelne Bit mittels GMSK (Gaussian-filtered minimum
shift keying) wobei die Trägerfrequenz fc bei einer binären 1 um 288 kHz erhöht und bei einer
binären 0 um 288 kHz verringert wird.

3.2 Zeitmultiplex-Verfahren, Übertragungsrate
Die Übertragung erfolgt in festen Intervallen von 10 ms Länge, die als Frame bezeichnet werden. Jedes dieser Intervalle ist wiederum unterteilt in 24 Zeitscheiben (time slots), innerhalb
derer die Daten mit einer Geschwindigkeit von 1,152 Mbps übertragen werden.

55

Gerhard Dittmaier

In einem Frame finden deshalb 11520 bit an Informationen Platz, je time slot sind das 480 bit.

Abb. 3.2: Zeitscheibenaufteilung

Durch Zuordnung von Daten zu bestimmten Zeitscheiben entstehen physikalische Datenübertragungskanäle, die eine (Pseudo-) Parallelübertragung ermöglichen. Dieser Mechanismus
wird als Zeitmulitplex-Verfahren (TDMA, time division multiple access) bezeichnet.

3.3 Duplex-Modus
Für jedes Telefongespräch werden 2 Übertragungskanäle benötigt, je 1 für Sende- und Empfangsrichtung. DECT benutzt für jede Übertragungsrichtung einen physikalischen Kanal, der
innerhalb eines Frequenzbandes durch Zeitmultiplex entstanden ist. Die Übertragung zwischen Basis- und Mobilstation erfolgt burst-artig. Während der ersten 12 time slots eines
Frames überträgt die Basisstation zur Mobilstation, während der zweiten 12 time slots erfolgt
die Übertragung umgekehrt.

Abb. 3.3: Rahmenstruktur und Duplex-Modus

Jeder Sende-slot hat einen korrespondierenden Empfangs-slot 12 Zeitscheiben später. Dieses
Verfahren heißt Zeitduplex-Verfahren (TDD, time division duplex), weil es beiden Teilnehmern, Basis- und Mobilstation, erlaubt, miteinander scheinbar gleichzeitig zu kommunizieren
und nur eine Übertragungsfrequenz für beide Richtungen zu benutzen.
Über jeden der oben beschriebenen Funkkanäle können deshalb gleichzeitig 12 Telefongespräche geführt werden.

3.4 Datenübertragung
Um ein kontinuierliches Sprachsignal in einer Folge von bursts zu übertragen, muß das Signal
gepuffert werden. Das analoge Signal wird digitalisiert, codiert und mit 32 kbps in einen Puffer geschrieben. Während der Dauer eines Frames (10 ms) werden 320 bit an Sprachdaten
gesammelt. Wenn der entsprechende time slot für die Übertragung an der Reihe ist, werden
die Daten aus dem Puffer mit der wesentlich höheren Datenrate von 1,152 Mbps übertragen
(s. Abb. 3.4). Der komplette Pufferinhalt wird somit innerhalb eines slots in weniger als
416,7 µs gesendet.

56

Die Schnurlos-Technologie am Beispiel von DECT

Abb. 3.4: Pufferung der Sprache

Durch die Pufferung wird die Übertragung um die Dauer eines Frames (~10 ms) verzögert.
Während eines time slots werden die Daten paketweise übertragen. Durch kontinuierliche
Übertragung von Paketen in aufeinanderfolgenden Frames, jeweils in den selben Zeitscheiben, entstehen physikalische Übertragungskanäle. Für Kanäle mit unterschiedlicher Bandbreite werden Datenpakete mit unterschiedlichen Längen in unterschiedlichen slot-Typen (full
slot, double slot) übertragen. Folgende Abbildung (s. Abb. 3.5) zeigt den Aufbau eines "normalen" P32-packet.

Abb. 3.5: Paketstruktur

Es besteht aus einem Feld zur Synchronisation des Receivers (Start), dem Datenfeld
(Signaling + payload) sowie einem Feld zur Erkennung verschiedener Fehler (Stop). Zur (digitalen) Sprachübermittlung werden im Datenfeld Signalisierungs- und Kontroll-Mechanismen eingefügt.
Für die Datenübertragung wird ein physikalischer Funkkanal dynamisch ausgewählt (DCA,
dynamic channel allocation). Der Mechanismus basiert auf 2 Prinzipien: Die Mobilstation
wählt den Kanal der Basisstation mit dem stärksten empfangenen Trägersignal und Mobilsowie Basisstation speichern die Signalstärken der Funkkanäle, die sie momentan nicht benutzen. Damit ist einer Mobilstation der Wechsel zu einer anderen Basisstation mit besserer
Signalqualität möglich (s. Abb. 3.6), beispielsweise bei Bewegung der Mobilstation.

57

Gerhard Dittmaier

Abb. 3.6: Übergang zu anderer Feststation

Der Übergang erfolgt nahtlos (seamless handover), da zuerst die Verbindung zu der Station
mit dem besseren Signal aufgebaut wird, bevor die schlechtere Verbindung abgebrochen
wird. In der Übergangsphase sind also 2 Verbindungen aktiv.

3.5 Synchronisation
Eine Schlüsselrolle bei der Datenübertragung spielt die Synchronisation der Taktfrequenz.
Die Systeme synchronisieren ihren Takt durch die übertragenen Pakete. In jedem Paket befindet sich dazu ein Synchronisationsfeld (s. Abb. 3.5), welches durch den Empfänger erkannt
und ausgewertet wird. Basis- und Mobilstation benutzen unterschiedliche Synchronisationsmarken, um zu verhindern, daß sich Mobilstationen untereinander statt mit der zugehörigen
Basisstation synchronisieren.
Trotzdem besteht bei Übertragung die Möglichkeit von Kollisionen. Dies ist beispielsweise
der Fall, wenn mehrere Mobilstationen mit benachbarten Basisstationen in unmittelbar aufeinanderfolgenden time slots kommunizieren (s. Abb. 3.7).

Abb. 3.7: Gleitende Kollision

Durch Abdriften der Taktfrequenz einer Kommunikationsverbindung verschieben sich die
Pakete zeitlich immer weiter "nach hinten", bis sie schließlich mit denen der anderen Verbindung kollidieren. Hierbei treten die Kollisionen bei der einen Verbindung am Anfang, bei der
anderen am Ende der Pakete auf.
Findet die Kollision am Anfang statt, ist eine Erkennung einfach. Das dort befindliche Synchronisationsfeld weist ein bekanntes Bitmuster auf und wird im Kollisionsfall verändert.

58

Die Schnurlos-Technologie am Beispiel von DECT

Eine Erkennung am Ende eines Datenpakets ist schwieriger, da dort kein bekanntes Bitmuster
sondern das CRC-Feld (X) steht, dessen Inhalt sich ständig ändert. Durch Hinzufügen eines
Duplikates des CRC-Feldes (Z) kann eine Kollision erkannt werden. "Paßt" das erste CRCFeld (X) zu den Daten und das zweite ist verändert, hat möglicherweise eine Kollision am
Paketende statt gefunden.

4 Medium Access Control Layer MAC
Die Charakteristiken des PHL und des MAC-Layer beeinflussen das Übertragungsprotokoll
ziemlich stark, wobei der MAC-Layer die Hauptlast trägt. So gesehen sind MAC-Layer und
PHL das Herz des Protokolls.
Der MAC-Layer abstrahiert die physikalische Schicht gegenüber den höheren Schichten. Die
Existenz von Datenpaketen bleibt hierbei den übergeordneten Schichten verborgen.

4.1 Hauptaufgaben
Die Hauptaufgaben im MAC-Layer sind:
• Generierung von bearers (Träger, i.S. Trägersignal bei Datenübertragung) für verbindungslose, verbindungsorientierte und Broadcast-Dienste und Zuweisung zu Kommunikationsverbindungen
• Broadcast-Übertragung von beacons (Leuchtfeuer, Signal) in jeder Funkzelle durch die
Feststationen. Bei den beacons handelt es sich um spezielle Datenpakete mit Informationen, die von den Mobilstationen für den Netzzugang benötigt werden.
• Aufteilung der Datenpakete vom PHL in logische Kanäle zu höheren Schichten und zu
LLME.

4.2 Bearer
Kommunikationsverbindungen werden über sogenannte Träger (bearer) geführt. Es werden 3
Typen von Trägern unterschieden: Simplex, double simplex und duplex bearers.
Ein simplex bearer (s. Abb. 4.1) entsteht durch Übertragung von einzelnen Paketen je Frame
in einem bestimmten time slot auf einer bestimmten Frequenz fc in einer bestimmten Richtung
(uplink/downlink).

Abb. 4.1: Simplex bearer

Ein double simplex bearer (s. Abb. 4.2)entsteht durch zwei simplex bearer, die 12 time slots
auseinander liegen.

Abb. 4.2: Double simplex bearer

Ein duplex bearer (s. Abb. 4.3)funktioniert ähnlich wie ein double simplex bearer, mit dem
Unterschied, daß hier ein simplex bearer Daten sendet und der andere Daten empfängt.

59

Gerhard Dittmaier

Abb. 4.3: Duplex bearer

Kommunikation ist sowohl über symmetrische Verbindungen als auch über asymmetrische
Verbindungen möglich.
Für symmetrische Verbindungen (z.B. normale Sprachübertragung) wird ein duplex bearer
benutzt. Damit steht für diesen Fall ein 32 kbps Duplexkanal für Benutzerdaten und ein
6,4 kbps Duplexkanal für Kontrollinformationen und Signalisierung zur Verfügung.
Asymmetrische Verbindungen bieten höhere Übertragungsbandbreite durch Nutzung von
multi-bearer Verbindungen (Belegung mehrerer Kanäle). Die Datenübertragung erfolgt hierbei nur in einer Richtung. Zu beachten ist, daß in diesem Fall nicht alle 24 time slots belegt
werden dürfen, da mindestens ein Kanalpaar für einen speziellen bidirektionalen bearer - den
pilot bearer - frei gelassen werden muß, um den Austausch von Kontrollinformationen (Flußkontrolle) zwischen Sender und Empfänger zu ermöglichen.

4.3 Beacon
Ein beacon ist ein Dienst, der im MAC-Layer erzeugt und von den Feststationen unmittelbar
nach dem Einschalten kontinuierlich als Broadcast ausgesendet wird. Er kann alleine mittels
eines eigenen bearer übertragen werden oder zusammen mit anderen Datenpaketen in einem
speziell dafür vorgesehenen Feld (s. Abb. 4.4).

Abb. 4.4: Übertragung von beacons

Der beacon enthält Informationen über das Kommunikationssystem, Kennungen, Zugangsberechtigungen und zur Verfügung stehende Dienste.
Von den Mobilstationen werden diese Informationen benutzt, um sich auf das Basis-System
einzustellen. So dürfen zum Beispiel von den Mobilgeräten keine weiteren Dienste angeboten
werden, wenn sie vom Festsystem nicht unterstützt werden.
Der beacon überträgt auch Mitteilungen an den Benutzer (paging informations), wie beispielsweise die Signalisierung eines ankommenden Rufes.

4.4 Multiplexen von logischen Kanälen
Im Protokollstack werden zwei Typen von Daten unterschieden: Kontroll- (C-plane) und Benutzerdaten (U-plane).
Die MAC-Schicht gruppiert die durchlaufenden Informationen in verschiedene logische Kanäle (C, G, I, M, N, P, Q), denen unterschiedliche Funktionalitäten zugeordnet sind. Zu nennen wären hier Kontrollkanäle (CS, CF), Signalisierung innerhalb der MAC-Ebene (M),
Paging Informationen (P) oder Austausch von Systeminformationen (Q).

60

Die Schnurlos-Technologie am Beispiel von DECT

Zur Übermittlung der in den logischen Kanälen enthaltenen Informationen wird das D-Feld
eines Datenpaketes unterteilt in ein A-Feld, welches ausschließlich Kontrollinformationen für
die Kanalzuordnung aufnimmt und ein B-Feld, größtenteils für Benutzerdaten (s. Abb. 4.5).

Abb. 4.5: Multiplexstruktur der MAC-Schicht

Als Teil des T-MUX überlagert der MAC-layer die 10 ms frames des PHL mit einer 160 ms
langen Multiframe-Struktur aus 16 frames (s. Abb. 3.3). Intern sind die Rahmen von 0 bis 15
durchnumeriert. Abhängig von der Position im Multiframe dürfen nur bestimmte Daten (logische Kanäle) übertragen werden, die auch noch unterschiedliche Prioritäten aufweisen.
Als Beispiel seien hier die Kontrollinformationen (C) der Feststation genannt, die in jedem
frame mit ungerader Nummer übertragen werden, wenn keine Signalisierung innerhalb der
MAC-Ebene (M) stattfindet.
Die im A-Feld enthaltenen Informationen werden stets durch CRC-Prüfdaten (RA) bei der
Übertragung gesichert, so daß der Empfänger Übertragungsfehler erkennen und ein erneutes
Senden der fehlerhaften Daten veranlassen kann. Hierzu wird ein einfaches Sende-und-Warte
ARQ-Protokoll ausgeführt (ARQ, automatic repeat request), bei dem ein neues Paket erst
übertragen wird, wenn das vorherige korrekt empfangen wurde (MOD-2 ARQ). Das B-Feld
bietet die Möglichkeit der ungesicherten bzw. der gesicherten Übertragung.

5 Data Link Control Layer DLC
Der DLC-layer stellt den höheren Schichten bei Bedarf gesicherte Verbindungen zur Verfügung.
Intern ist die DLC-Schicht unterteilt in eine obere und untere Hälfte (upper/lower DLC-layer).
Der obere Teil kommuniziert mit der darüberliegenden Netzwerkschicht (NWK) über Dienstprimitiven, die in den Standards festgelegt sind. Die Primtiven enthalten entweder Kontrolldaten (C-plane) oder Benutzerdaten (U-plane). Der DLC-layer Standard legt Frame-Strukturen fest, jede angepaßt auf den bestimmten Datentyp, der mit dem NWK-layer ausgetauscht
wird.
Für Sprachdaten (U-plane) sieht der Standard beispielsweise eine Größe von 40 Oktetten vor,
die unverändert, also ohne Sequenznummer oder CRC anzuhängen, in die Frames eingefügt
werden.

61

Gerhard Dittmaier

Bei Kontrollinformationen (C-plane) sorgt die obere DLC-Schicht dafür, daß alles was vom
eigenen NWK-layer übergeben wird den DLC- und NWK-layer auf der anderen Seite der
Verbindung in der richtigen Reihenfolge und ohne Fehler erreicht.
Die von der NWK-Ebene erhaltenen Nachrichten (messages) werden bei Bedarf in Segmente
passender Größe aufgeteilt (segmentation, s. Abb. 5.1). Aus jedem Segment wird ein Frame
generiert, indem verschiedene Oktette für Fehlerkontrolle und Reihenfolge-Informationen angehängt werden. Damit erhält der empfangende DLC-layer die Möglichkeit, bei fehlerhaft
oder nicht übertragenen Frames eine erneute Übertragung anzufordern. Auf Empfängerseite
werden umgekehrt aus den Frames wieder Segmente extrahiert und zu Nachrichten zusammengesetzt (assembly).

Abb. 5.1: Unterteilung der DLC-Schicht

Die untere DLC-Schicht tauscht Daten mit der darunterliegenden MAC-Schicht aus. Sie erhält von der oberen DLC-Schicht sowohl U-plane als auch C-plane frames und teilt diese für
den MAC-layer passend weiter auf (fragmentation). Die Fragmente werden an den MACLayer übergeben. Auf der Gegenseite werden aus den Fragmenten wieder Frames zusammengesetzt (recombination).
Für eine Sprachübertragung ist der Vorgang im lower DLC-layer recht einfach. Wie bereits
oben erwähnt ist die Frame-Größe 40 Oktette (unveränderte Daten vom NWK-Layer). Die
Länge eines Fragments ist ebenfalls auf 40 Oktette festgelegt, was von der Kapazität des
B-Feldes (payload, 320 bit) in einem P32 PHL-Paketes herrührt. Die Sprachdaten werden
deshalb "direkt durchgereicht".
Bei den Kanälen mit Kontrollinformationen sind jedoch Frames bis zu 72 Oktetten Länge
erlaubt, um die NWK-layer messages plus Sequenznummern und CRC-Daten des upper
DLC-layer aufzunehmen. Die Fragmente für die (langsamen) Kontrollkanäle sind mit einer
Länge von 5 Oktetten definiert, damit sie die 40 bit Nutzdaten des A-Feldes in einem P32Paket ausfüllen.
DLC wird hauptsächlich für die Signalisierung und für Datenübertragung eingesetzt und
spielt bei der Sprachübertragung (i.S. Daten der U-plane) nur eine untergeordnete Rolle.
Für die Datenübertragung werden auf DLC-Ebene u.a. Dienste in den Bereichen frame relay,
frame switching und rate-adaption zur Verfügung gestellt.
Die eingesetzten Sicherungsmechanismen sind Go-Back-N und Selective-Repeat.

62

Die Schnurlos-Technologie am Beispiel von DECT

6 Network Layer NWK
Die Netzwerkschicht ist die standardisierte Schnittstelle des DECT-Übertragungssystems
nach außen. Ihre Hauptaufgabe besteht in der Organisation des Informations-Austausches
über die Funkverbindung auf Anforderung der Applikation.
Sie stellt dafür spezielle Dienste zur Verfügung:
• Rufkontrolle (CC, call control)
• verbindungsorientierte Nachrichtendienste (COMS, connection-oriented message service)
• verbindungslose Nachrichtendienste (CLMS, connectionless message service)
• Mobilitätsmanagement (MM, mobility management)
• zusätzliche Dienste (SS, supplementary service)

6.1 Grundprinzipien
Die primäre Datenstruktur innerhalb des NWK-layer und die zwischen den Network-layern
von Fest- und Mobilstation übertragene ist die Nachricht (message). Sie enthält eine variable
Anzahl von Informationselementen (IE, information elements), die jeweils einen spezifischen
Inhalt haben.
Anzumerken ist, daß nur Kontrolldaten in der Netzwerkschicht behandelt werden. Daten der
U-plane (z.B. Sprachdaten) werden durchgereicht. Ebenso wie in der DLC-Ebene findet in der
Netzwerkebene eine Unterteilung in obere und untere Schicht statt (s. Abb. 6.1).

Abb. 6.1: Unterteilung der NWK-Schicht

Die Dienste im oberen Teil der Netzwerkschicht stehen der IWU (internetworking unit) über
Dienstzugangspunkte (SAP, service access points) zur Verfügung. Die Verbindungskontrolleinheit (LCE, link control entity) im unteren Teil benutzt ebenfalls SAPs für die Kommunikation mit dem DLC-layer.

6.2 Link Control Entity
Die LCE ist verantwortlich für die Kontrolle aller C-plane Verbindungen mit der DLCSchicht und für alle aktiven Verbindungen in der NWK-Schicht.
Bei Gesprächsanforderungen (i.S. Verbindung) ist sie für die erste Phase des Gesprächsaufbaus zuständig und fordert bei der DLC-Schicht eine sichere C-plane Verbindung an. Die
Kontrolle über diese Verbindung wird an die anfordernde Instanz der höheren Ebene weitergegeben.

63

Gerhard Dittmaier

In der unteren Netzwerkschicht werden zwei Nachrichtentypen unterschieden, die mit
S-FORMAT und B-FORMAT bezeichnet werden. Bei Nachrichten vom Typ S-FORMAT
handelt es sich um normale Kontroll-Nachrichten mit expliziten Quell-/Ziel-Informationen
des NWK-layer. B-FORMAT messages enthalten broadcast-Informationen wie z.B. Signalisierung eines ankommender Rufes oder Übertragung alphanumerischer Daten für die Anzeige
auf dem Display.

6.3 Call Control
Call control stellt "leitungsvermittelte" und paketvermittelte Dienste zur Verfügung. Erstere
werden in GAP-Systemen zur Kontrolle der Datenflüsse in der U-plane eingesetzt (digitale
Sprachübertragung). Letztere finden Anwendung in speziellen Verbindungen (advanced
connections), die jedoch ebenfalls von MAC- und DLC-Schicht unterstützt werden müssen.
Zu nennen wären hier: Weiterleiten, Einstellen, Wiederaufnahme von Diensten.
Für jeden Anruf wird eine eigene CC-Instanz generiert, die sich von den anderen durch ihre
Transaktionskennung (TI, transaction identifier) unterscheidet. Werden von den beteiligten
Endgeräten Mehrfachverbindungen unterstützt, dann existieren in den Systemen mehrere CCEinheiten. Dies ist bei einer Mobilstation zum Beispiel der Fall, wenn eine Verbindung gehalten wird und die andere aktiv ist (Makeln). Bei der Datenübermittlung wird in jeder Nachricht die CC-Instanz, für welche die message bestimmt ist, durch den transaction identifier
(TI) adressiert.
CC-entities handhaben Anforderung, Herstellung und Abbau von Verbindungen, Austausch
von Verbindungsinformationen, Aushandeln von Diensten sowie Wechseln von Diensten
während aktiver Verbindungen. Die Einrichtung einer Verbindung erfolgt, daß von der unteren Netzwerkschicht (LCE) zunächst ein Kontrollkanal beim DLC-layer angefordert wird.
Über diesen Kanal tauschen die CC-Einheiten Informationen aus, um die Verbindung festzulegen. Unter anderem werden Kennungen der CC-Instanzen, Fest- und Mobilstationen sowie
Verbindungsattribute übertragen.

6.4 Mobility Management
Wie in Abschnitt 1.3 bereits erwähnt, ist Mobilitäts-Management eine Sache der Anwendung.
Die MM-Funktionalitäten in der Netzwerkschicht sind lediglich dafür bestimmt, die applikationsspezifischen Anforderungen bezüglich Bewegung von Mobilstationen zu unterstützen.
Zur Verfügung stehen u.a. Dienste für:
• Bestimmen des Standorts von Mobilteilen (location)
• Identitätserkennung (identity)
• Zugangsrechte (access rights)
6.4.1 Location
Der Hauptgrund für die Bereitstellung einer Reihe von Funktionen zur Ortsbestimmung ist, zu
ermöglichen, daß eingehende Anrufe an mobile Stationen übermittelt werden können, deren
Standort im vorhinein nicht bekannt ist.
In DECT-Systemen ist nicht die Feststation für das Aufspüren/Verfolgen einer Mobilstation
verantwortlich, sondern die Mobilstation weiß durch das ständig empfangene "Leuchtfeuer"
(beacon), wo innerhalb des Systems sie sich befindet und teilt der Feststation den Aufenthaltsort mit. Erkennt eine Mobilstation an Hand des beacon, daß sie in ein anderes Gebiet gewechselt hat, übermittelt sie der Basisstation den neuen Aufenthaltsort und erhält für dieses Gebiet
für die Dauer des Aufenthaltes vom System eine temporäre ID zugewiesen. Damit ist der
Feststation immer der Aufenthaltsort der Mobilstation bekannt.

64

Die Schnurlos-Technologie am Beispiel von DECT

6.4.2 Identity
Die Kennung von Festsystemen und Mobilgeräten muß für eine Kommunikationsbeziehung
eindeutig sein.
Jeder Feststation (FP, fixed part) eines Systems ist ein eindeutiger Identifikator, bestehend aus
der ARI (access rights identity) des Systems und einer RFPN (radio fixed part number), zugeordnet. Der Identifikator wird periodisch als broadcast über einen der Kontrollkanäle (NT)
mittels beacon übertragen (s. Abb. 6.2) und erlaubt durch seine Struktur die Unterscheidung
von räumlichen Teilbereichen (Zellen).

Abb. 6.2: Identifikation im DECT-System

Für die Identifikation der Mobilstationen wird die IPUI (international portable user identity)
übermittelt, welche sich aus PUT (portable user type) und PUN (portable user number)
zusammensetzt und lokal - bezogen auf eine Feststation - bzw. global eindeutig ist.
6.4.3 Access Rights
Ein Mobilteil muß an der Feststation registriert werden, um deren Dienste in Anspruch nehmen zu können (Vergabe einer Zugangsberechtigung). Dies geschieht meist über die Applikation (z.B. Registrierungs-Taste), wobei Identifikatoren von Basis- und Feststation ausgetauscht und die Daten der Basisstation (ähnlich einem Zugriffsprofil) im Speicher des Mobilteils abgelegt werden. Die übermittelte ARI wird nach Übertragung zur Mobilstation dort zum
PARK (portable access rights key).
Mit verschiedenen Zugangsberechtigungen kann einem Mobilsystem die Nutzung mehrerer
unterschiedlicher (Fest-) Systeme ermöglicht werden. Dazu existieren in den mobilen Geräten
getrennte nichtflüchtige Speicherbereiche zur Aufnahme von IPUI, PARK und anderen Service-spezifischen Informationen. Da mehrere Speicherbereiche zur Verfügung stehen, kann
eine Registrierung an verschiedenen Systemen vorgenommen werden.
Die Zuordnung zu einem System geht folgendermaßen vor sich:
Nach Einschalten des Mobilteils, vergleicht es die im beacon von der Feststation übermittelten Informationen über Zugangsrechte mit den im Speicher abgelegten. Wird hier Übereinstimmung mit einem PARK festgestellt, erfolgt die Zuordnung zum System mit den im zugehörigen Speicherblock stehenden Daten.
So könnte man zum Beispiel mit ein und demselben Mobiltelefon zu Hause und im Büro telefonieren. In einem Fall unter Kennung und auf Rechnung des privaten Anschlusses, im anderen Fall unter der des geschäftlichen Anschlusses.

65

Gerhard Dittmaier

7 Sicherheit
7.1 Authentifizierung
Die Prozeduren zur Echtheitsbestätigung erlauben der Feststation die Überprüfung, ob der
jeweilige Kommunikationspartner auch der ist, für den er sich ausgibt. Grundlage dafür ist,
den Beweis zu erlangen, daß die Gegenstelle Kenntnis von einem geheimen Benutzer-Authentifizierungsschlüssel (UAK, user authentication key) hat, ohne den Schlüssel öffentlich zu
übertragen (s. Abb. 7.1).

Abb. 7.1: Authentifizierung der Mobilstation

Dazu sendet die Basisstation der Mobilstation eine Zufallszahl (challenge), die Mobilstation
verschlüsselt die Zahl mit dem geheimen Schlüssel und schickt das Ergebnis zurück
(response). Die Feststation, welche ebenfalls im Besitz des geheimen Schlüssels ist und die
Zahl damit verschlüsselt hat, vergleicht das Ergebnis der Mobilstation mit dem eigenen Ergebnis. Stimmen beide überein, kann die Feststation davon ausgehen, daß das mobile Gerät
den Schlüssel kennt.
Der beschriebene Mechanismus ist ein Challenge-Response-Verfahren und wird für Authentifizierung der Mobilstationen und Benutzer eingesetzt. Bei mobilen Geräten wendet man ihn
beim Verbindungsaufbau an und entscheidet an dieser Stelle über Annahme oder Ablehnung
der Verbindung. Des weiteren kann auch während aktiver Verbindungen eine periodische
Authentisierung stattfinden, um zu erkennen, ob sich ein Unbefugter in die Verbindung geschaltet hat.

7.2 Verschlüsselung
Innerhalb eines DECT-Systems besteht mit dem oben beschriebenen Verfahren ebenfalls die
Möglichkeit, einen Sitzungsschlüssel zu generieren und damit Daten der C-plane (Signalisierung) und der U-plane (Sprache/Daten) zu verschlüsseln. Dadurch erhält man eine abhörsichere Verbindung zwischen Mobil- und Basisstation.

66

Die Schnurlos-Technologie am Beispiel von DECT

Abkürzungen
ARI

Access Rights Identity

ARQ

Automatic Repeat Request

CC

Call Control

CCFP

Central Control Fixed Part

CLMS

Connectionless Message Service

COMS

Connection-oriented Message Service

DECT

Digital Enhanced Cordless Telecommunications

DCA

Dynamic Channel Allocation

DLC

Data Link Control

FDMA

Frequency Division Multiple Access

FP

Fixed Part

FT

Fixed Termination

GAP

Generic Access Profile

GMSK

Gaussian-Filtered Minimum Shift Keying

GSM

Global System for Mobile Communication

IE

Information Element

IPUI

International Portable User Identity

IWU

Internetworking Unit

LCE

Link Control Entity

LLME

Lower Layer Management Entity

MAC

Medium Access Control Layer

MM

Mobility Management

NWK

Network Layer

PARK

Portable Access Rights Key

PHL

Physical Layer

PT

Portable Termination

PUN

Portable User Number

PUT

Portable User Type

RFP

Radio Fixed Part

RFPN

Radio Fixed Part Number

SS

Supplementary Services

TDD

Time Division Duplex

TDMA

TIME Division Multiple Access

TI

Transaction Identifier

UAK

User Authentication Key

67

Gerhard Dittmaier

Referenzen
[Ber98]

Berger O.M. (1998):
DECT in the Factory of the Future,
Aachener Informatik-Berichte 98-6, RWTH Aachen

[PN98]

Phillips J.; Mac Namee G. (1998):
Personal Wireless Communication With DECT an PWT,
Artech House, Boston, London, 1998

Infrarotkommunikation mit IrDA
Michael Diepold

MCDiepol@aol.com
Zusammenfassung: IrDA ist eine Möglichkeit Daten kabellos zu übertragen. Es wird zur
Datenübertragung die Infrarottechnik eingesetzt. Durch diese optoelekronische Methode
müssen verschiedene örtliche Gegebenheiten erfüllt sein - wie z.B. Sichtkontakt zwischen den Geräten. IrDA ist ein weltweit stark verbreiteter Standard. Insbesondere bei
Laptops kommt die Infrarotübertragung zum Einsatz. Seine Stärken liegen im Kostenbereich und der einfachen Handhabung.

1 Einleitung
Ich komme mit meinem Notebook nach Hause, und möchte meine überarbeiteten Daten auf
den heimischen PC übertragen. Nun beginnt das alte Spiel, paralelles Kabel rausholen und
anstecken. Jetzt will ich was drucken. Das heißt umstecken des Drucker- und Transferkabels.
Wenn ich jetzt Daten vergessen habe muß ich schon wieder umstecken. Wenn ich mir jetzt
noch einen Scanner, Drucker oder eine Digitalkamera kaufe, dann ist das Kabelgewirr kaum
noch zu durchschauen.
Für dieses Problem gibt es eine Lösung: die drahtlose Datenübertragung zwischen den Peripheriegeräten bzw. Computern. Es gibt zwei Ansätze diese Problematik anzugehen, nämlich
die Infrarotlösung und die Funklösung. Ich möchte hier ein Verfahren genauer erklären, nämlich die drahtlose Kommunikation mittels Infrarot.

1.1 Geschichtliche Entwicklung
Seit 1994 setzt IrDA DATA einen Standard für universellen, kabellosen, 2-Weg Datentransport, der auf infrarotem Licht basiert. Die IrDA Technologie kommt bereits in über 100
Million elektronischen Geräten (Desktops, Notebooks, Palm PCs, Drucker, Digitale Kameras,
öffentliche Terminals, Pagers, PDAs, elektronische Bücher und andere MobilGeräte) zur Anwendung. IrDA ist eine internationale Organisation, die preiswerte infrarote Verbindungsstandards erstellt. Diese Standards umfassen ein weites Feld an Geräten. Hier möchte ich einen kurzen Überblick über die geschichtliche Entwicklung und die bisher erreichten technischen Standards geben.

70

Infrarotkommunikation mit IrDA

Die Organisation
Die Firma:
Hauptsitz:
gegründet:
Vorhaben:

Mitglieder:

IrDA, The Infrared Data Association
Walnut Creek, California
1993: gegründet als eine Non-Profit-Organisation
IrDA ist eine internationale Organisation, die preiswerte infrarote Verbindungsstandards erarbeitet und bewirbt. Diese Standards umfassen ein weites
Feld an Geräten und deren Verwendungszwecke.
Die Mitglieder der IrDA Organisation sind meist bekannte und große Firmen
aus den Bereichen Software, PCs, Mobilfunk, Drucker, PDAs ... usw.
Eine Liste findet sich unter http://www.irda.org/members/members.asp

[IRD]

Technische Meilensteine
Januar 2000

Oktober 1999

Juni 1999

Januar 1999

Oktober 1998
Februar 1998
November 1997
Oktober 1997
Juli 1997
Januar 1997
November 1995
Oktober 1995
Juni 1994

IrDA veröffentlicht IrWW Spezifikationen
IrDA beruft eine MP3 SIG (Special interest Group) um einen Standard für den
Datenaustausch von und zu MP3-Playern zu entwickeln.
IrDA veröffentlicht "JetSend Point and Shoot" und "JetSend Digital Photography"
Eine neue SIG wurde ins Leben gerufen. Sie widmet sich Finanztransaktion, die
auf IR (Infrarot) basieren sollen.
Ziel dieser SIG ist es einen Standard zu entwerfen, der die infrarote Kommuniktion voranbringt, so wie HTML seinerzeit das Internet voranbrachte. Dieser Standard soll möglichst allumfassend sein. D.h. auch Entwürfe für Designs, Protokolle und Einbindungsmöglichkeiten.
Die Hardware Implementation SIG ist zuständig für Implementationsempfehlungen. Sie soll Referenzen schaffen, die es Firmen einfacher machen, den IrDA
Physical Layer in Verbindung mit anderen Spezifikationen zu nutzen.
Das IrOBEX Protokoll übernimmt den Kommunikationsrahmen für den drahtlosen Austausch mit der Bluetooth SIG. IrDA's IrObex ist der erste API- Layer der
mit beiden kabellosen Spezifikationen (IR und Bluetooth) zusammen arbeiten
kann. D.h. ein gemeinsamer Layer für beide Übertragungsverfahren.
IrDA veröffentlicht 16Mbs Speed Erweiterung (VFIR) basierend auf dem IrDA
Data1.1 Standard.
IrDA vervollständigt die MAC Spezifikation für einen breiteren Einsatz im OfficeBereich
IrDA IrWW für Kommunikation von Kleinstgeräten wie Armbanduhren.
IrDA RealTime Video für die Untersützung von Audio- und/oder Video-Streams
IrDA veröffentlicht IrDA Control, für schnurlose Eingabegeräte (wie Mäuse, Tastaturen, Gamepads...)
IrDA veröffentlicht IrMC, eine neue Standardspezifikation für Verbindungen zwischen Mobilfunkgeräten
IrDA veröffentlicht IrTran-P (Infrared Picture Transfer) Standardspezifikation für
Bilderaustausch wie er in digitalen Kameras genutzt wird.
Automobile Charter Meeting verabschiedet eine Infrarot Bi-Directional Standard
Initiative
Telekommunikations Charter Meeting entwirft Vorschläge mit dessen Hilfe
drahtlose Geräte (z.B. Pager) mit bi-direktionalem IrDA Informationen übertragen
können
Microsoft kündigt Support für IrDA Verbindungen unter Windows 95 an, damit
werden preiswerte Verbindungen zwischen Win95 basierenden PC's und Peripheriegeräten möglich.
Veröffentlichung von einer Erweiterung des SIR Standards (enthält 4Mbs)
IrDA veröffentlicht die IrDA Spezifikation die folgendes enthält: Serial Infrared

71

Michael Diepold

September 1993

(SIR) Infrared Link, Protocol Stack Link Access Protocol (IrLAP), und Link Management Protocol (IrLMP).
IrDA setzt die Basis für alle IrDA Serial Infrared (SIR) Physical Layer Link Spezifikation
IrDA Charter Meeting von 50 Firmen

Juni 1993
Anmerkung: Dies ist nur ein Auszug. Die vollständige Historie ist auf der Homepage von
IrDa verfügbar [IRD] http://www.irda.org..

1.2 Einsatzmöglichkeiten von IrDA
Die Liste der Produkte, in denen bereits Infrarotunterstützung eingebaut ist, ist sehr umfangreich. Deshalb möchte ich hier nur einen Auszug vorstellen.
•
•
•
•
•
•

Drucker (z.B. HP-2100TN)
Handhelds (z.B. Palmpilot)
Handys (z.B. Siemens S25)
Motherbords (z.B. Asus TX97-XE)
Mäuse (z.B. Mitsumi ECM-W5103)
Armbanduhren (z.B. Casio PC-Unite II)

Als Beispiel für die vielseitigen Einsatzmöglichkeiten kann auch folgende Grafik dienen.

1.3 Technische Daten von IrDA
IrDA hat kurz zusammengefaßt folgende technischen Eigenschaften. Entscheidender Faktor
für den Datenaustausch mittels IrDA ist die Sichtverbindung zwischen den betroffenen Geräten. Dies begründet sich darin, daß die Datenübertragung mittels (unsichtbaren) Lichtes erfolgt. Insbesondere ist hier hervorzuheben, daß die Übertragung durch den Abstrahlwinkel
begrenzt ist. Als zusätzliche erhebliche Einschränkung ist zu bemerken, daß die Kommunikation nur zwischen den Clients und dem Host möglich ist. Dies wird auch dadurch deutlich,
daß eine Station den Status „Primary“ und alle weiteren den Status „Secondary“. Eine Kommunikation zwischen den einzelnen Clients ist nicht möglich [WI], [IRD].
Eigenschaft
Wellenlänge
Ausgangsleistung
Abstrahlwinkel

Wert laut Spezifikation
850nm bis 900nm
zwischen 40 und 500
mw/Sr
circa 15°

72

Infrarotkommunikation mit IrDA

Datenübertragungsrate
Fehlerkorrektur
Entfernung der Geräte
Anzahl der Clients pro Host
Anstiegszeit der Signalflanke
Fallzeit der Signalflanke

max. 4Mbps
CRC-16 oder CRC-32
5m max. (30cm typisch
für 4Mbps)
max 8 by IrDa Control
<600ns
<600ns

[IRD]
In folgender Grafik soll nochmals die Bedeutung des Abstrahlwinkels verdeutlicht werden
und die Reduzierung der Leistung mit zunehmendem Winkel.

1.4 Architektur von IrDA
IrDa kann intern in 2 Bereiche gegliedert werden, auf der einen Seite IrDA Data und auf der
anderen Seite IrDA Control [IRD].
1.4.1

IrDA Date

IrDa Data eignet sich besonders für eine relativ hohe Datenübertragung auf kurze Entfernung.
Diese Punkt-zu-Punkt Verbindung ist auf nur wenige Zentimeter beschränkt. Sie ist damit
geeignet für Digitalkameras, Handhelds, PDAs, Drucker usw. Wenn ein Produkt IrDa unterstützt, so sollte der Hersteller auch den neuesten Standart der 4Mbit/s anstreben. IrDA Data
gliedert sich in verschiedene Protokolle. Hierbei ist zwischen festen und optionalen Protokollen zu unterscheiden. Die festen (verbindlichen) Protokolle sind:
• PHY (Physical Signaling Layer)
• IrLAP (Link Access Protocol)
• IrLMP (Link Management Protocol and Information Access Service (IAS))

73

Michael Diepold

1.4.1.1 Verbindliche Protokolle
(1) Eigenschaften des Physical IrDA Data Signaling
• Entfernung: Im Normalfall ist die zu überwindende Strecke 1m (typischerweise sind es
maximal 2m). Niederstromvarianten beschränken die Entfernung auf 20-30cm. Damit
wird rund ein 1/10tel weniger Strom verbraucht. Der Stromverbauch ist gerade bei mobilen Geräten ein wichtiger Aspekt. Deshalb werden oft solche Niederstromvarianten verwendet.
• Bi-Direktionale Kommunikation der Geräte ist die Basis aller IrDa Spezifikationen .
• Übertragungsraten von 9600 b/s über 115 kb/s und dem Maximum von 4 Mb/s sind möglich.
• Die Datenpakete sind über eine Prüfsumme (aus dem engl. kurz: CRC) gegen Fehler gesichert.
(CRC-16 bei Raten bis1.152Mb/s und CRC-32 bei 4 Mb/s).
•
(2) Eigenschaften des IrDA Link Access Protocol (IrLAP)
• Unterstützt eine Gerät-zu-Gerät Verbindung für den einfachen Datentransfer.
• Es enthält die Geräte-Erkennungs-Proceduren. Weiterhin ist das IrLAP für den
Verbindungsaufbau zuständig. Jede Verbindung startet mit 9600 Baud und sobald die
Übertragungsgeschwindigkeit zwischen den Geräten ausgetauscht ist, werden die logischen Kanäle aufgebaut [INT].
•
(3) Eigenschaften des IrDA Link Management Protocol (IrLMP)
• Unterstützt Multiplexing des IrLAP Layers; Gewährleistet Multiple Kanäle über eine
IrLAP Verbindung.
• Enthält Protokoll- und Service-Erkennung mit Hilfe des Information Access Service
(IAS).
•
1.4.1.2 Optionale IrDA Data Protokolle
• Tiny TP - Fluß-Kontrolle bei IrLMP Verbindungen mit einer optionalen Segmentierung
und einem Reassembly Service. Sie ist unter anderem zuständig für die Fehlerkorrektur
(z.B. Verlorene Pakete). Hier werden die Daten in Pakete aufgeteilt und es erfolgt umgekehrt die Wiederherstellung der Daten aus den Paketen
• IrCOMM - COM (seriell und parallel) Port Emulation für normale COM Applikationen,
Drucker- und Modemgeräte
• IrOBEX - Ermöglicht "object exchange services" so wie z.B. HTTP.
• IrDA Lite - Ermöglicht Methoden der Reduzierung von IrDA Code, während immer noch
die volle Kompatibilität gewährleistet wird.
• IrTran-P - Ermöglicht Bildaustausch-Protokolle, wie sie in digitalen Kameras verwendet
werden.
• IrMC - Spezifiziert die Kommunikation von Mobiltelefonen oder anderen in Echtzeit
laufenden Anwendungen für Sprache (Töne).
• IrLAN - Beschreibt ein Protokoll um Infrarot Geräte in LANs einzubinden.

74

Infrarotkommunikation mit IrDA

IrDA DATA - Hardware/Protocol Stacks

1.4.2 IrDA CONTROL
IrDA Control ist ein infraroter Kommunikationsstandard der es kabellosen Peripheriegeräten
wie Tastaturen, Mäusen, GamePads und Joysticks erlaubt mit vielen intelligenten Hosts zu
interagieren. Hosts können zum Beispiel PCs, Haushaltsgeräte, Spielekonsolen, Fernseher
oder Videorecorder sein.
IrDA Control Protokolle bestehen aus 3 verbindlichen Protokollen:
•
• PHY (Physical layer)
• MAC (Media Access Control)
• LLC (Logical Link Control)
•
(1) Eigenschaften von IrDA Control Physical Signaling:
• Entfernung und Bereich (Abstrahlwinkel) ist äquivalent zu derzeit existierenden unidirektionaler infrarot Fernbedienungen (Maximum 5m Reichweite).
• Bi-direktionale Kommunikation.
• Datenübertragungsrate 75 kb/s max
• Die Daten werden bei über eine Grundträgerfrequenz von 1.5 MHz übertragen. (beschrieben in IEC 1603-1)
• Die Übertragung der Datenpakete wird über eine CRC (CRC-8 für kurze Pakete und
CRC-16 für lange Pakete) gesichert. Das PHY wurde für geringen Leistungsverbrauch
optimiert und kann problemlos in Low-Cost Hardware verbaut werden.
(2) Eigenschaften von IrDA Control MAC:
• Ermöglicht einem Host mit mehreren Peripheriegeräten gleichzeitig zu kommunizieren
(1:n). Dabei können es aber maximal 8 Client-Geräte sein.
• Garantiert schnelle Antwort- und Verzögerungszeiten. (13.8 ms basic Pollingrate)
• Ermöglicht dynamische Verknüpfungen und Wiederbenutzung von Peripherieadressen.
•
(3) Eigenschaften von IrDA Control LLC:
• Ermöglicht die Wiederholung einer Transmission, wenn Fehler erkannt wurden.
• Alle benötigten und optionalen Protokolle für IrDA Data und IrDA Control gibt es in einer detaillierteren Version auf der offiziellen Webseite http://www.irda.org..

75

Michael Diepold

2 Komponenten eines einfachen Infrarot-Ports
Mit Hilfe weniger kostengünstiger elektronischer Bauteile läßt sich ein einfacher IrDA Infrarot-Port realisieren. Entsprechende Bauanleitungen finden sich im Internet unter der Adresse:
http://www.infrarotport.de
Es werden folgende Komponenten benötigt [INF]:
Bauteile:
- IrDA Tranceiver Chip von Hewlett Packard ('HSDL-1001' oder 100% kompatibel)
- C1: 4.7 µF (mikro-Farad!)
- C2: 100 nF (nano-Farad!)
- C3: 220 nF
- C4: 470 nF
- R1: 10 R
- R2: 330 R
- einen Stecker, der auf den 5-Pin-Connector des Boards passt
- 4-adriges geschirmtes Kabel
- ein kurzes 8-adriges Flachbandkabel
Die Kosten für diese Teile beschränken sich auf ca. 30 DM

3 Nachteile von IrDA
Neben den oben beschriebenen Vorteilen von IrDA, wie die leichte Handhabung und die geringen Kosten, existieren auch erhebliche Nachteile. Am einfachsten kann man diese deutlich
machen, indem man die Eigenschaften von IrDA mit einem anderen Verfahren zur drahtlosen
Datenübertragung vergleicht. Als wahrscheinlich künftigen Standard zur Funkübertragung
wurde als Vergleichsverfahren Bluetooth gewählt.

76

Infrarotkommunikation mit IrDA

Bluetooth
Tägliche Benutzung

Gößere Reichweite (bis 10 m)
auch durch Wände hindurch
Bewegung stört Übertragung nicht

IrDa

Unterstützung auf den
Computern

+

bewährt sich gut

+

Einschränkend ist die direkte
Verbindung, bei der möglichst
beide Geräte ruhen sollten

+

+
+
+

Weites Feld von unterstützten Varianten

+

Für Windows und Linux kein Problem

+
+

Störsicherheit im Alltag

Ist gut vorbereitet

Wird sich sehr einfach gestalten, Aufgrund +
der Tatsache, das viele existierende Protokolle übernommen wurden und unterstützt
werden
Bei korrekter Realisierung wird es kaum
+
zu Störungen kommen
Eine Fehlerkorrektur ist vorhanden
+
Andere Anbieter haben bereits Geräte im
Umlauf, die ebenfalls bei 2,45 GHz arbeiten. Hier kann es zu möglichen Störungen
kommen.

Oft als COM-Port Emulator im Bios
realisiert

Sicher, denn schon im Kernprotokoll LMP ist eine Verschlüsselung vorgesehen
Bis maximal 127 Geräte in einem Funknetz (relativiert sich)
Keine Geschwindigkeitssteigerung mög+
lich, durch begrenztes Frequenzband

Verschlüsselung nicht vorgesehen

+
+
-

Abhörsicherheit im Alltag
Mehrere Geräte im Einsatz
Mögliche Erweiterungen
für die Zukunft (Geschwindigkeit und Protokolle)

+

Sonstiges

+

+
-

+

Protokolle können erweitert und neue
aufgesetzt werden
Wenig Geräte verfügbar (im Moment)

+
+
+
+

Recht sicher, wenn auf kurzer Distanz
nichts dazwischen steht.
Eine Fehlerkorrektur ist vorhanden

Bis maximal 8 Geräte an einem Host
(relativiert sich)
Durch neue Standards (schnellere IRDioden) auch höhere Übertragungsraten
möglich
Protokolle können erweitert und neue
aufgesetzt werden
Weite Verbreitung
Gutes Preis/Leistungsverhältnis
Geringer Stromverbrauch

[BLU], [IRD]

4 Zusammenfassung
IrDA ist eine Technologie, die eine drahtlose Übertragung von Daten ermöglicht. Grundlage
ist ein opto-elektronisches Verfahren, daß mittels der Infrarottechnik die Datenübertragung
realisiert.
IrDA ist eine ist eine Standardtechnologie die seit 1993 weltweit eingesetzt wird. Weit verbreitet ist IrDA bei mobilen Geräten.
Die Stärken liegen insbesondere im Kostenbereich und der einfachen Handhabung. Es werden
Schnittstellen zu einem Preis realisiert, der im Vergleich zu sonstigen Gerätekosten, marginal
ist.
In diesem Zusammenhang ist auch das Kosten und Leistungsverhältnis zu sehen. Im Vergleich zu neuen Technologien, wie zum Beispiel Bluetooth hat IrDA eine sehr gute Übertragungsrate, die im Vergleich zu den Kosten noch überzeugender wirkt.
Bluetooth und IrDA sind beides gute Ergänzungen für übergreifende, kabellose Kommunikation von Geräten. Bluetooth ist aber leider kaum verbreitet, aufgrund der jüngeren Entstehung. Dies ist auch gleichzeitig noch das größte Problem. Denn diese Technologie ist sicher
noch stark ausbaufähig. Besonders in Bezug auf Preis-/Leistungs-Verhältnisse und Stromer-

77

Michael Diepold

sparnisse. Das Gute ist, daß beide Verfahren nicht gegeneinander arbeiten. Das OBEX Protokoll zeigt, daß es gemeinsame Interessen gibt. Dies kommt am Ende den Anwendern zu gute,
die die gleiche Software zum Datenabgleich für ihr Bluetooth-LAN und ihren Handheld nutzen können.
Daher wird auch weiterhin in bestimmten Bereichen IrDA seine Berechtigung behalten.

5 Ausblick
Obwohl IrDA ein bewährter Standard zur Datenübertragung ist, wird er in Zukunft erhebliche
Konkurrenz durch weitere drahtlose Übertragungstechniken bekommen. Bluetooth zeichnet
sich dadurch aus, daß es nicht die Schwächen von IrDA besitzt.
Insbesondere ist keine Sichtkontakt zwischen den Geräten mehr erforderlich. Die Übertragungsdistanz ist erweitert auf bis zu 10 Meter. Weiterhin werden 8 Geräte gleichzeitig unterstützt im Gegensatz zu nur 2 Geräten bei IrDA (Host / Client).
Durch diese doch erheblichen Vorteile wird Bluetooth wohl in der Zukunft IrDA in vielen
Bereichen verdrängen. Durch die große Flexibilität dieser Technologie wird die drahtlose
Kommunikation noch erheblich an Bedeutung gewinnen und die Kabelverbindung zwischen
Geräten erheblich zurückdrängen.
Dennoch ist nicht zu erwarten, daß IrDA gänzlich vom Markt verschwindet. In bestimmten
Bereichen wird es weiterhin seine Berechtigung haben.

Referenzen
[MI2000]

Microsoft,IrDA Protocol Overview, 2000

[WI]

Williams,IrDA Platform, HP Labs, Bristol

[BLU]

http://www.e-online.de/public/chrigi/bluetooth.htm

[INF]

http://www.infrarotport.de

[IRD]

http://www.irda.org.

Der WAP-Protokollstapel
Ein Überblick über Architektur und Protokolle
Stephan Zeindl

zeindls@lycos.de
Zusammenfassung: Gegenstand dieser Ausarbeitung ist ein Überblick über die Protokolle der WAP-Protokollfamilie. Nach einleitenden Betrachtungen über die Motivation
zur Einführung von WAP und den aktuellen Entwicklungsstand der Spezifikation wird
zunächst kurz die WAP-Architektur im Vergleich zur WWW-Architektur vorgestellt. Die
Gegenüberstellung mit den korrespondierenden TCP/IP- bzw. WWW-Protokollen begleitet auch leitmotivisch die dann folgende Diskussion der einzelnen WAP-Protokolle, sowohl was den Aufbau des Protokollstacks im Ganzen anbelangt als auch bei der Vorstellung der Features der jeweiligen Schichten. Abschließende Betrachtungen zur Security
und ein Ausblick auf die weitere Entwicklung von WAP runden die Darstellung ab.

1 Einführung
1.1 WAP und das WAP-Forum
WAP (Wireless Application Protocol) ist ein weltweiter Standard, der eine Anwendungs- und
Protokollumgebung für mobile Endgeräte wie Handys, PDAs und Smartphones/Sreenphones
realisiert. Dabei stehen Intra/Internet-Anwendungen im Vordergrund. Standardisiert wird die
WAP-Spezifikation durch das WAP-Forum, ein Konsortium von Endgeräte-Herstellern, Systemtechnik-Lieferanten, Netzbetreibern und Softwareindustrie, dem heute über 500 Mitglieder angehören. Das WAP-Forum wurde im Juni 1997 von Nokia, Ericsson, Motorala und
phone.com ins Leben gerufen, also ausnahmslos von Endgeräteherstellern, bei denen das Interesse WAP möglichst schnell einzuführen besonders groß war, um so eine neue Generation
von Endgeräten beim Kunden zu platzieren. Aufgrund der zentralen Rolle des WAP-Forums
bei der Entwicklung und Verabschiedung des neuen Standards stellt es auch die authoritative
Quelle für alle mit WAP bzw. den WAP-Protokollen verbundenen technischen Detailfragen
dar. Die Spezifikationen werden auf der Web-Site des Konsortiums (www.wapforum.org) als
PDF-Dateien veröffentlicht und stehen dort zur Einsichtnahme bzw. zum Download bereit.
Aktuelle Version des Standards ist 1.2, die aber erst im Sommer 2000 vom WAP-Forum verabschiedet wurde und daher von vielen Endgeräten und Netzbetreibern noch nicht unterstützt
wird. Version 1.2 wird sich aber vermutlich noch im Laufe des Jahres 2001 flächendeckend
durchsetzen und die Vorgängerversion 1.1 ablösen. 1.2 ist voll kompatibel zu 1.1 und stellt
lediglich eine Erweiterung dar. Hinzugekommen sind im wesentlichen Möglickeiten zur Endgerätedifferenzierung, die WIM-Spezifikation und die Push-Technik. Letztere ermöglicht
sogenannte Real Time Alerts (z.B. Börsenticker) von einem Server aus auf den mobilen
Clients zu initiieren und wird in Abschnitt 3.2.4 noch genauer erläutert werden. Noch im
Laufe des Jahres 2001 soll die Spezifikation von Version 1.3 abgeschlossen werden, die insbesondere im Security-Bereich deutliche Verbesserungen bringen soll.

80

Der WAP-Protokollstapel

1.2 Motivation für die Einführung eines neuen Protokollstacks
Vom technologischen Standpunkt aus ergibt sich die Motivation zur Einführung eines auf die
speziellen Bedürfnisse mobiler Kommunikation zugeschnittenen Protokollstapels aus der
Überlegung, daß man in zweifacher Hinsicht gravierende Unterschiede zu stationären Computernetzwerken hat:
• Zum einen weist die Kommunikationsumgebung selbst andere Charakteristika auf:
o Niedrige Bandbreite der Datenkommunikation (9,6 kBit/s bei GSM)
o Hohe Latenzzeit
o Geringe Stabilität der Verbindung über die Luft
o Schwieriger zu garantierende Verfügbarkeit
• Zum anderen unterscheiden sich die Endgeräte erheblich von den im stationären Umfeld
verwendeten Desktop-Maschinen:
o Geringere Rechenleistung und Speicherkapazität von mobilen Geräten (insbesondere
Handies)
o Stromverbrauch von mobilen Geräten ist begrenzt
o Größe und Auflösungsvermögen des Bildschirms/Displays
o Kein permanenter Speicher auf dem Handy
Vor dem Hintergrund dieser Herausforderungen wurden die in den folgenden Kapiteln dargestellten WAP-Protokolle spezifiziert.

2 Architektur und Schichtenmodell
2.1 WAP- versus WWW-Architektur
Eines der zentralen Anliegen, das zur Gründung des WAP-Forums führte, war es InternetInhalte, insbesondere Web-Content auf mobile Endgeräte zu bringen. Der WAP-Standard
wird daher in [WAP] auch ganz bewußt der WWW-Architektur gegenübergestellt. Ein Leitmotiv der folgenden Ausführungen über die WAP-Protokolle wird daher - soweit möglich
und sinnvoll der stete Vergleich mit den korrespondierenden Internetarchitekturen bzw. Protokollen sein.

Client

Web Server
Request

Web
Browser

CGI
Scripts
etc.

Response
Content

Abbildung 1: WWW-Architektur bei direkter Kommunikation zwischen Client und Server

Charakteristisch für die WWW-Architektur ist, daß Content und Applikationen auf einem
Webserver bereit stehen und von einem als Web-Browser bezeichneten Client-Programm
zugreifbar sind. Resourcen auf Webservern sind über URLs weltweit eindeutig identifizierbar,
Content-Typ und Content-Formate sind standardisiert und die Kommunikation erfolgt über
ein TCP/IP-Protokoll, in der Regel HTTP. Die Kommunikation zwischen Client und Server
kann dabei, wie Abbildung 1 zeigt, direkt erfolgen oder über ein oder mehrere dazwischen-

81

Stephan Zeindl

geschaltete Programme, die als Proxy-Server bezeichnet werden und gegenüber den Webservern die Rolle des Clients sowie gegenüber den Clients die Rolle des Webservers einnehmen.
Der zentrale Unterschied der WAP-Architektur zu dem oben geschilderten WWW-Modell
besteht in der Tatsache, daß jetzt keine direkte Kommunikation zwischen Client und Webserver mehr möglich ist, sondern auf jeden Fall ein Proxy benötigt wird. Letzterer dient als
Bindeglied zwischen dem drahtlosen Netz des Clients und dem IP-basierten Festnetz, dem der
Webserver angehört. Als solches hat er im wesentlichen die folgenden beiden Aufgaben zu
erfüllen:
• Die Rolle eines Protokoll-Gateways, das für die Umsetzung der WAP-Protokolle in Internet-Protokolle und umgekehrt sorgt.
• Die Rolle eines Content-Encoders und -Decoders, die WAP-Formate in kompaktes Binärformat übersetzen und so die zu übertragende Datenmenge minimieren. Für WAP wurde
dazu ein eigenes Binärformat mit der Bezeichnung WBXML geschaffen, das in der Version 1.2 vorliegt.

Client
WAE
Web
User
Browser
Agent

Web Server

WAP Gateway
Request

Response

Encoder
und
Decoder

Request

CGI
Scripts
etc.

Response
Content

Abbildung 2: WAP-Architektur

Statt des in [WAP] verwendeten Begriffs des WAP-Proxy findet man in der Literatur - z.B. in
[WH01] - meist den Begriff WAP-Gateway. Obwohl die erste Bezeichnung technisch korrekter ist, da auf einem Gateway in der Regel keine Daten zwischengespeichert werden,
scheint sich letztere in der industriellen Praxis durchzusetzen, weshalb im folgenden die Begriffe „WAP-Proxy“ und „WAP-Gateway“ synonym verwendet werden sollen.
Webserver und WAP-Gateway können als Softwarekomponenten auch auf der derselben physikalischen Maschine untergebracht werden. Man spricht dann kurz von einem WAP-Server
[ARE00].
Die Analogie zum Web-Browser bildet in der WAP-Welt ein sogenannter Micro-Browser, der
die Daten vom Proxy empfängt und und diese dann umsetzt und für das Display rendert. Der
Micro-Browser wird auch als WAE User Agent (oder WML User Agent, siehe 3.1) bezeichnet und stellt neben dem WTA User Agent die zweite Client-Komponente auf einem WAPEndgerät dar. Abbildung 2 zeigt die beschriebene Architektur im Überblick. Diese Infrastruktur stellt einerseits sicher, daß mobile Terminals auf unterschiedliche WAP-Inhalte und -
Anwendungen zugreifen können, andererseits erlaubt sie Anwendungsentwicklern Informationsangebote zu erstellen, die von einer Vielzahl von Terminals interpretiert und dargestellt
werden können. Über den WAP-Proxy werden die Inhalte und Anwendungen auf einem
Standard-Webserver veröffentlicht, wobei auch webtypische Techniken wie etwa CGIScripting benutzt werden können.

82

Der WAP-Protokollstapel

2.2 Ein Schichtenmodell für WAP-Protokolle
Bei dem nun folgenden allgemeinen Überblick über den WAP-Protokollstapel bietet sich eine
Analyse an, die sich im wesentlichen auf die folgenden beiden Aspekte konzentriert:
• Den Vergleich mit dem ISO-Referenzmodell. Dieses beschreibt bekanntlich Anzahl und
allgemeine Funktionalität der Schichten auf die die zur Kommunikation in verteilten Systemen benötigten Funktionen aufgeteilt werden [TAN97]. Obwohl es sich in der Praxis
nicht durchsetzen konnte, hat es Bedeutung für die Strukturierung und Beschreibung von
Kommunikationsvorgängen und soll daher bei der Diskussion der WAP-Protokolle miteinbezogen werden.
• Der Vergleich mit TCP/IP bzw. den WWW-Protokollen, die - wie oben bereits mehrfach
erläutert - eine zentrale Rolle bei der und für die Entwicklung von WAP gespielt haben.
WWW- Protokolle

WAP- Protokolle

HTML
JavaScript

Wireless Application
Environment (WAE)

Other Services and
Applications

Session Layer (WSP)

HTTP
Transaction Layer (WTP)
Security Layer (WTLS)

TLS - SSL

Transport Layer (WDP)

TCP/IP
UDP/IP

Bearers:
SMS

USSD

CSD

IS-136

CDMA

CDPD

PDC-P

Etc..

Abbildung 3: WAP- versus WWW-Protokollstack

Abbildung 3 zeigt die Übersicht über den WAP-Protokollstack wie man sie in der Regel in
der Literatur, insbesondere in [WAP] findet. Außer den WAP-Protokollen werden auf der linken Seite der Grafik die jeweils korrespondierenden WWW-Schichten dargestellt während die
OSI-Schichten aus Übersichtlichkeitsgründen nicht mit aufgeführt wurden. Folgende Beobachtungen sind festzuhalten:
• Die drei unteren Schichten des ISO-Referenzmodells, die im wesentlichen für die Verbindung der Endsysteme zuständig sind und von Anwendungsprozessen „noch nichts wissen“, werden im WAP-Modell pauschal als Bearer bezeichnet. Bei TCP/IP wo Physicalund Data-Link-Layer meist zu einer Schicht zusammengefaßt werden [TAN97] würden
die Bearer die beiden untersten Schichten bis zur Ebene IP repräsentieren. Bei den
Bearern handelt es sich um die Trägerdienste bzw. -Netze der Telekommunikationsinfrastruktur über die das jeweilige WAP-Endgerät kommuniziert.
• Die Transportschicht des ISO-Modells - bei TCP/IP als TCP und UDP bekannt - findet
im WAP-Stack seine Entsprechung in einem WDP (Wireless Datagram Protocol) genannten Layer. Im Falle einer Kommunikation über IP wird allerdings auch bei WAP
UDP als Transportprotokoll verwendet.
• Nach dem Vorbild von TCP/IP ist auch die - im ISO-Modell so gar nicht vorhandene Sicherheitsschicht designed. Sie wird in Analogie zu SSL bzw. TLS ebenfalls zwischen

83

Stephan Zeindl

der Transport- und den eigentlichen Anwendungsschichten eingezogen und WTLS
(Wireless Transport Layer Security) genannt.
• Oberhalb der Transport- bzw. Sicherheitsschicht wird der Vergleich zwischen WAP und
den WWW-Protokollen schwieriger, da TCP/IP hier nicht mehr weiter zwischen verschiedenen Layern differenziert, sondern alles pauschal zu einer Schicht zusammenfaßt.
WAP ist hier mit seinen beiden Protokollen WTP (Wireless Transaction Protocol) und
WSP (Wireless Session Protocol) vertreten, die in Abbildung 3 beide dem Internet-Protokoll HTTP gegenübergestellt sind, aber eine 1 : 1 - Abbildung der beiden ProtokollStacks aufeinander ist hier nicht mehr möglich, da das WWW-Modell nicht transaktionsorientiert arbeitet.
• Da Abbildung 3 strenggenommen nur den WAP- bzw. WWW-Protokollstack zeigen
sollte, ist die oberste der dargestellten Schichten eigentlich fehl am Platz, da es sich bei ihr
- wie der Name WAE (Wireless Application Environment) ausdrückt - nicht um ein Protokoll, sondern um eine Anwendungsumgebung handelt. Die Darstellung trägt jedoch der
gängigen Sprachregelung Rechnung, nach der „eine Anwendungsumgebung auf Protokollen aufsetzt“ und wird wohl deshalb in der Literatur durchgängig wie in Abbildung 3
gewählt. Innerhalb von WAE hat man erneut viele aus der WWW-Welt bekannte Elemente. Die Seitenbeschreibungssprache HTML findet ihr WAP-Pendant in WML
(Wireless Markup Language) und Java-Script hat seine Entsprechung in einer SkriptSprache namens WML-Script.
Wie Abbildung 3 außerdem zeigt, ermöglicht der Aufbau des WAP-Stacks darüberhinaus
auch anderen Diensten und Applikationen jede der Schichten WSP, WTP, WTLS und WDP
über definierte Schnittstellen direkt zu erreichen.

3 Die WAP-Protokolle im einzelnen
3.1 WAE
Da es sich bei WAE, wie oben erwähnt, um kein Protokoll im eigentlichen Sinne handelt, soll
hier nur ein vergleichsweise kurzer Überblick gegeben werden: Die WAE-Spezifiktionen
[WAEoview] und [WAE] unterscheiden, wie Abbildung 4 zeigt, zwischen User Agenten einerseits und Formaten und Diensten andererseits. User Agenten sind zum einen der bereits
erwähnte Microbrowser, der hier als WML User Agent bezeichnet wird. (Der Begriff WAE
User Agent wird manchmal als Sammelbegriff für alle User Agenten, manchmal - wie in Abbildung 2 - exklusiv für den MicroBrowser gebraucht. Die Nomenklatur ist hier nicht ganz
einheitlich). Zum anderen hat man den WTA-User-Agenten, der ein Interface zu verschiedenen Telefonfunktionalitäten des Endgeräts, wie Telefonbuch oder Kalenderapplikationen bildet. WAE läßt den Entwicklern große Freiheit bei der Entwicklung und Spezifikation weiterer
User-Agenten und legt bewußt nur die für die Interoperabilität grundlegenden Dienste und
Formate fest. Dies sind beispielsweise:
• Die Seitenbeschreibungssprache WML und die Skript-Sprache WML-Skript.
• Die URLs: Diese folgen im wesentlichen der HTTP-URL-Konvention. Eine Ausnahme
bildet das URL-Schema für die WTAI-Sezifikation. Es entspricht nicht dem HTTP-Standard, wird aber in der Praxis auch noch nicht eingesetzt.
• Andere Formate:
o WBMP als bisher einziges Format für Bilder
o vCalendar 1.0 als Austauschformat für elektronische Kalender und Zeitplanung

84

Der WAP-Protokollstapel
o vCard 1.0 als Austauschformat für elektronische Visitenkarten

WAE
User Agents

WML User Agent
WML User Agent

WTA User Agent
WTA User Agent

Services/Formats
WML
WML

WTA Srvs
WTA Srvs

Other Agents
Other Agents

Other
Apps.
and
Services

WML Script
WML Script
URLs
URLs

Other Srvs &
Other Srvs &
Formats
Formats

WAP Protocol Stack and Servives
Device OS/Services
Abbildung 4: WAE-Client-Komponenten

3.2 WSP
WSP wurde in 2.2 dem HTTP-Protokoll gegenübergestellt, da es alle in HTTP/1.1 bereitgestellten Funktionalitäten enthält. Tatsächlich handelt es sich bei WSP um eine ganze Protokollfamilie, wobei der für das Browsen von Anwendungen zuständige Teil auch WSP/B
[WAP] genannt wird. Die Diskussion des WSP-Protokolls (spezifiziert in [WSP]) soll sich
daher insbesondere auf die gegenüber HTTP/1.1 vorhandenen Unterschiede bzw. Erweiterungen konzentrieren:
3.2.1 Binäre Header-Codierung
Eine der wesentlichen Motivationen HTTP nicht unmodifiziert zur Kommunikation über mobile Netze zu nutzen, war der große Daten-Overhead, den die von HTTP erzeugten Meta-Informationen generieren. Die WSP-Spezifikation enthält daher eine Reihe von Definitionen
nach denen die aus HTTP/1.1 bekannten HEADER-Namen und -Werte in ein kompaktes Binärformat kodiert werden können. Über HEADER-Code-Pages mit maximal 128 Einträgen ist
es außerdem möglich, daß der kodierte Integer-Wert jedes HEADER-Namens durch ein Oktett repräsentiert werden kann. Applikationsspezifische HEADER-Namen werden in eigenen
Code-Pages definiert und auch ein Mechanismus für einen Wechsel zwischen Code-Pages
während einer Session ist vorgesehen.
3.2.2 Verbindungsorientierte und verbindungslose Sessions
WSP ermöglicht anders als das HTTP-Protokoll neben verbindungsorientierten auch verbindungslose Sessions. Erstere arbeiten über das WTP-Protokoll, letztere verwenden dagegen
direkt WDP. Die Dienste unterscheiden sich über die jeweils zugelassenen Primitives. Bekanntlich wird ein Dienst formell als Gruppe von Operationen (Primitives) spezifiziert, die
einem Benutzer oder einer anderen Einheit zugänglich sind [TAN97]. Die in den WAP-Spezifikationen gewählte Syntax für einen Primitive ist X-Service.type (Parameters). Dabei ist
• X die jeweils betrachtete Protokollschicht, im Falle von WSP also „S“ für Session Layer,
• Type einer der 4 zugelassenen Typen Request, Indication, Response und Confirm,
• Service die eigentliche Operation, z.B. connect für einen Verbindungsaufbau
• Parameters die Parameter, die beim Aufruf je nach Spezifikation des Services mitgegeben
werden müssen oder können

85

Stephan Zeindl

So wäre beispielsweise S-Connect.req mit Client- und Server-Adresse als Parametern die Initialisierung eines Verbindunsaufbaus seitens des Clients. Während der verbindungsorientierte
Modus insgesamt 11 Services und alle Typen zulässt, sind bei dem verbindungslosen nur drei,
jeweils unbestätigte Services (S-Unit-MethodInvoke, S-Unit-MethodResult und S-Unit-Push)
und zwei Typen (Request und Indication) möglich.
3.2.3 Suspendierung und Wiederaufnahme von Sessions
Eine besonderes Merkmal von WSP ist die Möglichkeit bestehende Sessions zu unterbrechen
und wiederaufzunehmen (suspend and resume). Man erreicht dadurch beispielsweise Unabhängigkeit vom darunterliegenden Trägernetzwerk, d.h. also, daß eine WSP-Session suspendiert und auf einem anderen Netzwerk basierend wiederaufgenommen werden kann. Hierfür
stehen die Service-Primitives S-Suspend mit den Typen Request und Indication sowie SResume mit Request, Indication, Response und Confirmation zur Verfügung.
3.2.4 Push-Funktionalität
Neben den normalen Sitzungsdiensten bietet WSP auch Push-Funktionalitäten, d.h. daß der
Server Informationen an den Client schickt ohne daß dieser sie angefordert hat. Man hat hier
einige technologische Unterschiede zu den üblichen Pull-Mechanismen. Die eigens für Push
entwickelten Protokolle der stationären (PushAccesProtocol, PAP) und mobilen (Push Overthe-air Protocol, Push OTA Protocol) Welt werden nicht an einem WAP-Gateway, sondern an
einem PushProxyGateway (PPG) ineinander übersetzt. Dabei wird das PAP über HTTP getunnelt, das Push OTA Protocol basiert dagegen auf WSP-Diensten. Die Push-Mechanismen
von WSP erlauben 3 Arten des Datentransfers:
• Daten-Push innerhalb einer bestehenden Sitzung mit Bestätigung. Hierfür werden die
Primitives S-ConfirmedPush und S-PushAbort bereitgestellt. Letztere dient dem Client
dazu eine Push-Operation des Servers zurückzuweisen.
• Daten-Push innerhalb einer bestehenden Sitzung ohne Bestätigung. Dieser wird durch die
Primitive S-Push geregelt. Da eine Confirmation nicht vorgesehen ist, ist S-Push nur für
die Typen Request und Indication definiert, ein Analogon zu S-PushAbort aus dem obigen
Fall existiert damit selbstverständlich auch nicht. Die Initialisierung eines verbindungsorientierten Daten-Pushs seitens des Servers ist allerdings nicht ohne weiteres möglich, da
eine WSP-Sitzung nur vom Client, nicht vom PPG aufgebaut werden kann. In den Client
wurde daher eine sog. Session Initiation Application (SIA) integriert, die auf Sitzungsanfragen seitens des Gateways hört und ggf. die WSP-Session etabliert.
• Daten-Push ohne bestehende Sitzung und ohne Bestätigung. Die hier verwendete Primitive heißt S-Unit-Push und ist aus den oben genannten Gründen ebenfalls nur für die Typen Request und Indication definiert.
3.2.5 Capability Negotiation
Die aus HTTP bekannte Möglichkeit bestimmte Kommunikationsaspekte zwischen Client
und Server am Beginn der Session aushandeln zu lassen (z.B. Content Negotiation), wurde in
der WSP-Spezifikation wesentlich erweitert und unter dem Begriff Capability Negotiation
zusammengefaßt. Ausgehandelt werden können beispielsweise
•
•
•
•

Die maximale Größe einer Dateneinheit (Service Data Unit, SDU), die während einer
Session jeweils zum Client oder zum Server gesendet werden darf
Die maximale Zahl von Methodenaufrufen, die während der Session gleichzeitig aktiv
sein können
Die maximale Zahl von Push-Aufrufen, die während einer Session gleichzeitig aktiv sein
können
Methoden, die über die in HTTP/1.1 spezifizierten hinausgehen

86
•

Der WAP-Protokollstapel
Protokolloptionen: Die im verbindungsorientierten Modus von WSP möglichen Primitives
werden zu Gruppen zusammengefaßt, man spricht dann von Facilities [WSP]. Zur
Session-Resume-Facility würden beispielsweise die Primitives S-Suspend und S-Resume
gehören. Die Verhandlungen über die Protokoll-Optionen ermöglichen es festzulegen
welche der Facilities bei der Kommunikation verfügbar sind. Obligatorisch sind nur diejenigen für das Session Management und das Exception Reporting.

3.3 WTP
Das WTP-Protokoll, spezifiziert in [WTP], stellt Dienste zur Verfügung, die zuverlässige
(reliable) und unzuverlässige (unreliable) Transaktionen erlauben. Eine Transaktion besteht
dabei aus Anfrage und Antwort. Alle verbindungsorientierten Sitzungsdienste von WSP setzen daher auf WTP auf. WTP seinerseits benutzt die Datagramm-Layer als darunterliegende
Schichten oder bei entsprechenden Sicherheitsanforderungenen wahlweise zunächst den
Security-Layer WTLS, da es selbst keine Security-Funktionalitäten zur Verfügung stellt. Im
folgenden sollen die Transaktionsklassen sowie einige ausgewählte Features von WTP vorgestellt werden.
3.3.1 WTP-Transaktionsklassen
Ähnlich wie bei WSP sind auch für das WTP-Protokoll Service-Primitives definiert. Diese
bieten sich an, um die Transaktionsklassen genauer zu charakterisieren. Mit der aus 3.2.1 bekannten Notation hat man wieder die 4 Typen Request, Indication, Response und Confirm,
aber diesmal nur die 3 Services TR-Invoke, TR-Result, TR-Abort, deren Verfügbarkeit bzw.
Nichtverfügbarkeit die jeweilige Transaktionsklasse kennzeichnet. Dabei wurde TR als Kürzel für den WTP-Layer gewählt. Folgende Klassen sind spezifiziert:
• Klasse 0: Unzuverlässige Ein-Weg Anfrage. Hier schickt der Initiator eine Nachricht an
den Responder auf die er keine Bestätigung erhält und auch ein erneutes Verschicken der
Nachricht ist nicht vorgesehen. Ein Beispiel für diese Art der Transaktion ist der im Abschnitt über WSP vorgestellte „Daten-Push innerhalb einer bestehenden Sitzung ohne Bestätigung“. Es steht nur die Primitive TR-Invoke zur Verfügung, was insbesondere bedeutet, daß die Transaktion nicht abgebrochen werden kann. Die Transaktion ist für den
Initiator nach dem Abschicken der Nachricht beendet, für den Responder nach ihrem Erhalt.
• Klasse 1: Zuverlässige Ein-Weg Anfrage. Hier bestätigt der Responder den Empfang einer
vom Initiator gesendeten Nachricht. Für den Initiator ist die Transaktion beendet sobald er
die Bestätigung vorliegen hat. Zur Verfügung stehen die Primitives TR-Invoke und TRAbort, so daß die Transaktion auch jederzeit abgebrochen werden kann. Der von WSP bereitgestellte „Daten-Push innerhalb einer bestehenden Sitzung mit Bestätigung“ ist ein
Beispiel für eine Klasse 1-Transaktion.
• Klasse 2 : Zuverlässige Zwei-Weg Anfrage mit Ergebnisnachricht (result message). Der
Responder schickt hier eine komplette Ergebnisnachricht als Antwort auf die ursprüngliche Nachricht des Initiators. Die Ergebnisnachricht fungiert implizit als Bestätigung. Falls
das Aufbereiten bzw. Verschicken der Ergebnisnachricht länger dauert, kann der
Responder zunächst auch mit einem „hold on“-Acknowledgement antworten. Der Initiator
bestätigt schließlich noch die Ergebnisnachricht. Erreicht diese Bestätigung den
Responder ist die Transaktion für ihn beendet. Alle innerhalb von WTP definierten
Primitives TR-Invoke, TR-Result und TR-Abort stehen jetzt zur Verfügung, so daß auch
diese Art der Transaktion jederzeit abgebrochen werden kann. Klasse 2-Transaktionen
werden für das Browsen benötigt: Die Anforderung eines mobilen Clients bei einem
Content-Server nach Inhalten wird nicht mit einer Bestätigung, sondern mit dem Versenden von Content beantwortet.

87

Stephan Zeindl

3.3.2 WTP-Features
• Effizienterer Austausch von Nutzdaten: Gegenüber TCP wurde WTP insbesondere was
die Reduzierung des ausgetauschten Daten-Overhead anbelangt optimiert. Man hat keinen
expliziten Verbindungsauf- oder abbbau, sondern es werden bereits mit dem ersten ausgetauschten Packet Nutzdaten transportiert. Nach einem Beispiel aus [WWP] würden bei
einer typischen Session, die aus 3 Anfragen und 3 Antworten besteht, im Falle von
HTTP/TCP 17 Packete ausgetauscht, im Falle von WSP/WTP/UDP dagegen nur 7. Vergleicht man die Zahl der Anfragen/Antworten bei denen keine Nutzdaten ausgetauscht mit
der Gesamtzahl der Anfragen/Antworten und definiert dieses Verhältnis als Overhead, so
ergibt sich ein Overhead von 65 % bei dem HTTP/TCP-Beispiel, aber nur 14% bei den
WAP-Protokollen.
• Unterstützung asynchroner Transaktionen: Der Initiator soll mehrere Transaktionen anstoßen können, ohne daß er die Antwort auf die erste erhalten hat. Die Antworten können
asynchron eintreffen, d.h. in anderer Reihenfolge als die Nachrichten, die sie beantworten.
Der Responder sendet das Resultat, sobald die entsprechenden Daten verfügbar sind, unabhängig von anderen Transaktionen.
• User Acknowledgement: Arbeitet man mit dieser Funktionalität, so schickt der WTPProvider erst dann eine Antwort auf eine empfangene Nachricht wenn der entsprechende
WTP-User (das ist in der Regel der Dienst der nächsthöheren Ebene, also WSP) den Eingang der Nachricht bestätigt hat. Man hat so eine gegenüber der klassischen Definition eines bestätigten Dienstes weitaus stärkere Forderung. Während normalerweise nur der
Service Provider bestätigen muß und dies unabhängig von Rückmeldungen des ServiceUsers erfolgt, muß der Service Provider jetzt für jede eingegangene Nachricht die Antwort
des Service Users einholen und abwarten bevor er bestätigen kann.
• Zusatzinformationen im letzten Acknowledgement: Der WTP-User hat die Möglichkeit
im letzten ACK-Packet einer Transaktion Informationen über die Transaktion mitzuschicken. Je nachdem zu welcher Klasse die Transaktion gehörte kann damit entweder der
Initiator dem Responder Informationen mitteilen oder umgekehrt der Responder dem Initiator. Die betreffenden Informationen könnten beispielsweise Performance-Messungen
beinhalten.
WTP bietet noch eine Reihe weiterer Features, wie beispielsweise die Verkettung mehrerer
PDUs (Protocol Data Unit) oder den Abbruch ausstehender Transaktionen, auf die aus Platzgründen nicht näher eingegangen werden kann. Insgesamt wurde mit WTP ein leichtgewichtiges Transaktionsprototokoll geschaffen, das an den Bedürfnissen von „thin Clients“ und
schmalbandigen, Datagramm-basierten, drahtlosen Netzen ausgerichtet ist.

3.4 WDP und die Bearers
WDP stellt einen verbindungslosen, unzuverlässigen Datagramm-Transport zur Verfügung.
Dieser hat die Aufgabe ein eingehendes Datagramm an den richtigen WDP-User zu routen,
der normalerweise durch eine eindeutige Port-Nummer identifiziert wird. Für WDP werden
dafür die beiden Service-Primitives T-DUnitdata zum Versenden von Daten als Datagramm
und T-DError, um höhere Schichten über Fehler zu informieren, bereitgestellt. „T“ indiziert
dabei den Transport-Layer. Eine weitere zentrale Aufgabe von WDP besteht darin, die höheren Schichten von den Bearern so abzuschirmen, daß erstere unabhängig von deren speziellen
Charakteristika funktionieren, so daß Applikationen transparent Daten über die verschiedensten Telekommunikationsinfrastrukturen austauschen können. Dies kann jedoch nur über eine
Anpassung von WDP an die Bearer-Spezifikation erreicht werden, genauer über sog.
Adaption-Layer, die die Spezifikationen des jeweiligen Netzwerks enthalten. Diese Anpassung kann so stark sein, daß von WDP nichts übrig bleibt, was beispielsweise der Fall ist
wenn der Trägerdienst des Netzes auf IP basiert und WDP zu UDP wird. Abbildung 5 veranschaulicht graphisch die Rolle, die WDP bei der Übertragung spielt. Der Adaption-Layer en-

88

Der WAP-Protokollstapel

det am Gateway und übergibt die WDP-Packete an einen WAP-Proxy/Server via einem Tunnel-Protokoll, das die Schnittstelle zwischen dem Gateway des jeweiligen Trägerdienstes und
dem WAP-Proxy/Server bildet.

WAP
Proxy/Server

Mobile

Apps on
WAE
other servers

WAE
WSP

WSP

Wireless
Data
Gateway

WTP

WTP

WDP & Adaption

Bearer

WDP & Adaption
Bearer

Tunnel

Tunnel

Subnetwork

Subnetwork

Abbildung 5: Die Rolle von WDP im WAP-Modell

Der unterliegende Bearer hat dagegen die Aufgabe die Datagramme zum richtigen Endgerät
zu routen. Die Adressierung dieses Endgeräts kann in Abhängigkeit vom Typ des Trägernetzwerks über eine IP-Adresse oder eine Telefonnummer erfolgen. Ein Bearer kann durch
Angabe eines Datentransportmechanismus wie z.B. SMS (Short Message Service) und des
Netzes über den dieser Datentransportmechanismus stattfindet, z.B. GSM (Global System for
Mobile Communication) vollständig beschrieben werden. Der entsprechende Bearer wäre also
GSM SMS. WAP unterstützt gemäß der aktuellen WDP-Spezifikation [WDP] über 20 der in
diesem Sinne definierten Bearer, davon 5 GSM-basierte: GSM SMS, GSM CSD (Circuit
Switched Data), GSM USSD (Unstructured Supplementary Service Data), GSM GPRS
(General Packet Radio Service) und GSM Cell Broadcast.
Die hier erfolgte gemeinsame Behandlung von WDP und den Bearern ist neben den oben dargestellten Zusammenhängen zwischen den Schichten auch dadurch gerechtfertigt, daß eine
Reihe von Aufgaben existieren, die je nach Art des Netzwerks und der Implementierung entweder von WDP oder den Bearern wahrgenommen werden können. Als Beispiele seien hier
die Fehlererkennung bei der Übertragung von Datagrammen (innerhalb von WDP über das
Wireless Control Message Protocol WCMP möglich, dessen Implementierung aber nicht obligatorisch ist) sowie Fragmentierung und Wiederzusammensetzen von Datenpacketen genannt.

3.5 WTLS
Die WTLS-Spezifikation [WTLS] baut auf TLS v1.0 auf, das seinerseits auf dem SSL v3.0Standard basiert. Analog zu SSL besteht die Aufgabe von WTLS darin die Vertraulichkeit der
Datenkommunikation, die Integrität der ausgetauschten Daten und die Authentizität der
Kommunikationspartner sicherzustellen. Die WTLS-Spezifikation definiert 3 Sicherheitsklassen, die sich dadurch unterscheiden welche Sicherheitstechnolgien bzw. -funktionalitäten
darin entweder obligatorisch, fakultativ oder nicht vorhanden sind. In jeder der drei Klassen
ist beispielsweise Public-Key-Exchange, Verschlüsselung sowie die Verwendung von MACs
(Message Authenication Code) vorgesehen. Server-Zertifikate müssen dagegen nur in den
Klassen 2 und 3, Client-Zertifikate nur in Klasse 3 verwendet werden.

89

Stephan Zeindl

Ähnlich wie die anderen WAP-Protokolle zeichnet sich auch WTLS dadurch aus, daß es im
Vergleich zu den korrespondierenden Internetprotokollen (in diesem Fall also SSL) auf die
besonderen Randbedingungenen der mobilen Datenkommunikation, wie geringe Bandbreite
und hohe Latenzzeiten optimiert ist. Im folgenden sollen einige der über SSL hinausgehenden
Features exemplarisch vorgestellt werden.
3.5.1 WTLS-Features
• Optimierte Handshake-Prozeduren: Einer der zentralen Bestandteile des WTLS-Protokolls
ist das Handshake-Protokoll, über das Client und Server am Beginn einer Secure Session
eine Protokollversion und kryptographische Algorithmen austauschen, sich ggf. gegenseitig authentifizieren und mittels entsprechender Public-Key-Technologien geheime
Schlüssel erzeugen bzw. austauschen. WTLS erlaubt es eine suspendierte Secure Session
über eine optimierte Handshake-Prozedur wiederaufzunehmen , die im Vergleich zum
vollen Handshake wesentlich kompakter ist.
• Zuverlässigkeit der Daten-Übertragung bei Transport über Datagramm-Layer: Da WTLS
auf den unzuverlässigen Transport-Layern WDP oder UDP aufsetzt, sorgt WTLS dafür,
daß alle Handshake-Nachrichten, die in dieselbe Richtung gehen innerhalb einer SDU
(Service Data Unit) zusammengekettet und transportiert werden, daß der Client die
Handshake-Nachricht wenn nötig wiederholt und daß der Server diese Nachrichten entsprechend beantwortet.
• Mehrere Secure-Connections über eine Secure-Session: Über eine Secure-Session können
mehrere Secure Connections etabliert werden, also Connections, die die gleiche SessionID haben und mehrere Security-Parameter (z.B. das Master-Secret) teilen. Insbesondere
bedeutet die Störung einer Connection nicht das Ende der Session, die, wie oben bereits
erwähnt, zu einem späteren Zeitpunkt wiederaufgenommen werden kann.
• Dynamisches Key-Refreshing: Client und Server können aushandeln wie oft während
einer Session bestimmte Parameter der Connection wie zum Beispiel der encryption key
geändert werden sollen. Neue Schlüssel werden für jede n-te Nachricht mit n = 2key_refresh
berechnet, also bei key_refresh = 3 z.B. für jede 8. Nachricht.
• Mini-Zertifikate: WTLS läßt zwar die Verwendung von X.509-Zertifikaten zu, die meisten Endgeräte unterstützen diese wegen ihrer Größe jedoch nicht. Es wurden daher eigene, schlankere WTLS-Zertifikate definiert, bei denen gegenüber den X.509-Zertifikaten
beispielsweise die Serial Number oder Issuer- und Subject-ID weggelassen werden.
3.5.2 Allgemeine Sicherheitsprobleme bei WAP
Aus sicherheitstechnischer Sicht ist das Hauptproblem der in Abbildung 2 dargestellten
WAP-Architektur der am WAP-Proxy stattfindende Protokollbruch. WTLS-Daten werden
entschlüsselt , um dann wieder SSL-verschlüsselt an den Web-Server weitergesendet zu werden bzw. umgekehrt. Das führt dazu, daß sämtliche übertragenen Daten auf dem WAPGateway unverschlüsselt vorliegen. Die Gateway-Betreiber müssen daher garantieren, daß
unverschlüsselte Informationen niemals auf Sekundärspeicher gelangen, das Ver- und Entschlüsseln ausschließlich und so schnell wie möglich im Arbeitsspeicher stattfindet und alle
hierfür benutzten Speicherbereiche vor der erneuten Freigabe überschrieben werden.
Mit der in WAP 1.2 neu hinzugekommenen WIM-Spezifikation sollen Security-relevante
Funktionalitäten von der Software des mobilen Endgeräts auf eigene Hardware-Devices, namentlich Smart-Cards oder SIMs (Subscriber Identity Module) verlagert werden. Allerdings
enthält die Spezifikation keine API und ist deshalb von WML oder WMLScript aus nicht direkt zugänglich. Die Implementierung ist also vom Gerätehersteller abhängig [ARE00].
Digitale Serverzertifikate sind zwar seit WAP 1.1, entsprechende Client-Zertifikate seit WAP
1.2 verfügbar, eine ergänzende PKI-Funktionalität etwa für digitale Signaturen existiert jedoch noch nicht. Alle heutigen PKI-Lösungen sind proprietär.

90

Der WAP-Protokollstapel

4 Ausblick
Die vorangegangenen Betrachtungen dürften deutlich gemacht haben, daß die Spezifikationen
der WAP-Protokolle in steter Entwicklung begriffen sind. Beispielsweise wird momentan das
in 3.4 erwähnte Tunnel-Protokoll, das die Schnittstelle zwischen dem Gateway des jeweiligen
Trägerdienstes und dem WAP-Proxy/Server bildet, für den Trägerdienst GSM SMS spezifiziert. Eine große Herausforderung für die Zukunft bilden auch die vielen offenen SecurityFragen, von denen einige in 3.5.2 angeschnitten wurden. Ein weiterer Trend wird sicherlich
auch das noch engere Zusammenwachsen der WAP-Protokolle mit den Internet-Protokollen
sein: Das bereits in Arbeit befindliche WAP 2.0 soll auch auf TCP als Transportlayer aufsetzen können. Erweiterungen und Ergänzungen des WAP-Standards dürften damit auch in den
kommenden Jahren zu den dynamischsten Entwicklungen der mobilen Kommunikation gehören, da man auch bei deutlich erhöhten Übertragungsraten und Bandbreiten die Schlankheit
der WAP-Protokolle und ihre Optimierung auf die Bedürfnisse der drahtlosen Kommunikation hin zu schätzen wissen wird.

Referenzen
[ARE00]

Arehart C. et al. (2000): Professional WAP; Wrox Press Ltd. 2000

[TAN97]

Tanenbaum A. S. (1997): Computernetzwerke; Prentice Hall 1997

[WAEoview]

„Wireless Application Environment Overview“, WAP Forum, March 29, 2000. URL:
http://www.wapforum.org/

[WAE]

„Wireless Application Environment Specification“, WAP Forum, March 29, 2000.
URL: http://www.wapforum.org/

[WAP]

„Wireless Application Protocol Architecture Specification“, WAP Forum, April 30,
1998. URL: http://www.wapforum.org/

[WDP]

„Wireless Datagram Protocol Specification“, WAP Forum, February 19, 2000. URL:
http://www.wapforum.org/

[WH01]

Wenz C.;Hauser T. (2001): WAP Architektur - Programmierung - Referenz, Carl
Hanser Verlag München Wien, 2001

[WSP]

„Wireless Session Protocol Specification“, WAP Forum, May 4, 2000. URL:
http://www.wapforum.org/

[WTLS]

„Wireless Transport Layer Security Protocol Specification“, WAP Forum, February
18, 2000. URL: http://www.wapforum.org/

[WTP]

„Wireless Transaction Protocol Specification“, WAP Forum, February 19, 2000.
URL: http://www.wapforum.org/

[WWP]

„Wireless Application Protocol White Paper“, WAP Forum, Juni 2000. URL:
http://www.wapforum.org/

WML (Wireless Markup Language)
Die Seitenbeschreibungssprache des Wireless Application Protocol
Bernhard Fechner

Bernhard.Fechner@Fernuni-Hagen.de
Zusammenfassung: In den letzten 3 Jahren haben sich Mobiltelefone (Handys) als
Hilfsmittel moderner Kommunikation massiv durchgesetzt. Es kam bald der Wunsch
nach mehr Komfort und den Zugriff auf Informationen über das Internet (s. Glossar) auf.
Wenn HTML [4] (Hypertext Markup Language s. Glossar) zur Darstellung von Web-Seiten auf Mobiltelefonen verwendet werden soll, muss man sich vergegenwärtigen, dass der
Implementationsaufwand von HTML-Parsern relativ groß ist. Daraus folgt: man benötigt
(für Handys) ungewöhnlich viel RAM, ROM und einen leistungsfähigen Prozessor.
Leistung, die bei Mobilteilen von den Batterien bezogen wird. Dazu kommt, dass die derzeitigen Bandbreiten und Anzeigen der Handys eher klein sind. Deswegen suchte man
nach einer Seitenbeschreibungssprache, die diese Nachteile kompensieren sollte. Dies
versucht WML, die Wireless Markup Language. Im Folgenden soll diese Sprache vorgestellt und charakterisiert werden.

1 Eigenschaften von WML
Die derzeitige Bandbreite von Handys ist klein (derzeit 300bps bis 10kbps). Es wird noch
einige Jahre dauern, bis sich neuere Übertragungstechnologien, wie etwa UMTS (Universal
Mobile Telephony Standard), die höhere Bandbreiten zur Verfügung stellen, auf dem Markt
etabliert haben. Die Anzeige der Mobilteile ist ebenfalls sehr klein, typischerweise zehn bis
zwanzig Wörter in zwei bis fünf Zeilen. Da WAP-Geräte über geringe Leistung verfügen,
muss ein Format und Protokoll verwendet werden, das möglichst effizient verarbeitet werden
kann. Deshalb wird für diese Zwecke nicht HTML [4] über HTTP, sondern WML über WAP
verwendet.
WML (Wireless Markup Language) ist eine Seitenbeschreibungssprache auf Hypertext1Ebene, definiert für solche Geräte. Die WML ähnelt der HTML2, ist jedoch in der Funktionsweise stark eingeschränkt. Einige Sprachelemente von HTML und WML sind identisch. Dennoch ist die WML keine echte Teilmenge von HTML. WML wird durch die sogenannte Document Type Definition (DTD, s. Glossar) in XML3 [3] definiert. XML ist wiederum von
SGML [5] (Standard Generalised Markup Language) abgeleitet. Mit diesen Eigenschaften ist
WML kontextsensitiv und wesentlich konsistenter als HTML definiert, da HTML direkt
durch SGML und nicht über XML erklärt ist.
Um WML-Seiten lesen zu können, benötigt man einen WAP-Browser (z.B. ccWAP von
www.ccwap.com). Farbattribute sind im Moment nicht vorhanden. Alle Seiten sind schwarzweiß, da Farben im Moment noch zu viel Speicherkapazität in Anspruch nehmen und farbige
1

s. Glossar
HTML (Hypertext Markup Language) s. Glossar
3
XML (Extensible Markup Language) s. Glossar
2

92

WML (Wireless Markup Language)

Flachbildschirme teuer sind. Das einzige (standardisierte4) Grafikformat ist WBMP, Wireless
Bitmap (s. 3.10 Bilder).
WML-Seiten müssen so geschrieben werden, dass sie von der Client-Hardware, auf der sie
dargestellt werden, unabhängig sind [6,8]. WML verwendet dazu (wie HTML) das Prinzip
des logischen Markup. Das bedeutet: Absätze, Zeilenwechsel, etc. sollten immer so eingesetzt
werden, wie es der logischen Struktur des Dokuments entspricht, unabhängig von der Größe
der Anzeige, Zeilenzahl, Zeilenlänge, Schriftgröße und Schriftart des darstellenden Geräts.
Die Darstellung wird auf jedem Client an die dort verfügbare Display-Größe und Schrift angepasst.
WML-Seiten müssen so entworfen werden, dass sie von der Software-Version des WAP-Geräts unabhängig sind. Deshalb sollten WML-Dateien nur die von der WML-Norm festgelegten Elemente enthalten5. WML-Erweiterungen und Abweichungen, die nur auf bestimmten
Geräten oder nur in bestimmten Software-Versionen funktionieren, sollten strikt vermieden
werden. Derzeit wird von den meisten WAP-Geräten WML 1.1 (1999 definiert) vollständig
unterstützt. Die WAP6-Spezifikation verlangt den Gebrauch von WML.
Um WML-Seiten zu programmieren und zu testen benötigt man einen einfachen Editor, möglichst mit WML-Syntax-Hervorhebung und eine Software-Emulation eines WAP-Gerätes z.B.
M3Gate von Numeric Algorithm Laboratories (http://www.m3gate.com/Scripts/d.asp).

1.1 Tags
Da WML auf XML [3] basiert, ist es case sensitive, d.h. Tags (die Formatbeschreibungszeichen) müssen definitionsgemäß klein geschrieben werden. Alle WML-Tags werden zwischen
spitzen Klammern (<,>) eingeschlossen. Das Tag muss dabei direkt ohne dazwischenliegende Leerzeichen der öffnenden Klammer folgen. Tags werden mit <tag> begonnen und
mit </tag> beendet. Benötigt der Tag kein abschließendes Element, so wird die Kurzform
<tag/> verwendet. Im Gegensatz zu HTML darf in WML und XML das abschließende Tag
niemals weggelassen werden. WML-Befehle müssen zudem immer richtig geschachtelt werden, also immer die umgekehrte Reihenfolge der öffnenden Tags darstellen, z.B.
<a><b>...</b></a>.
Ein Tag mit Attributangabe wird in der Form <tag attribut="wert"> geschrieben. Anführungszeichen umschließen den Attributwert. Jedes WML-Tag hat die Standardattribute id
und class. Das Standardattribut id dient zur eindeutigen Identifizierung des WML-Tags. Es
muss im jeweiligen WML-Deck eindeutig sein. Das zweite Standardattribut class kann verschiedene Elemente zu einer Klasse zusammenfassen.

2 Das WAP-Gerät greift auf das Internet zu
W AP-G erät

IDC

TAL K /D ATA
TA LK

RS CS T R R D TD CD

Modem

Einwahl- Server (RAS)

W eb-Server

W AP-Gateway

Mobiles
Netzwert
Internet

W eb-Inhalte

W AP-Inhalte

Abbildung 2-1: Zugriff auf das Internet von einem WAP-Gerät
4

M3Gate unterstützt u.a. das Grafikformat png (portable network graphics)
In diesem Beitrag wird nur die WML Spezifikation 1.3. behandelt. Auf die in den USA vor WML verwendete
HDML (Handheld Device Markup Language) wird nicht eingegangen.
6
Wireless Application Protocol
5

93

Bernhard Fechner

In Abbildung 2-1 links, befindet sich das WAP-Gerät, das sich, um Zugang zum Internet zu
erhalten, über ein mobiles Netzwerk, typischerweise GSM7 in ein Modem eines Servers mit
aktiviertem RAS (Remote Access Service) einwählt. Dieser Server stellt dem WAP-Gerät die
eventuell benötigten Protokolle und eine IP-Adresse zur Verfügung. Dies sind dieselben lowlevel Protokolle, die auch ein Internet-Service-Provider zur Verfügung stellt, z.B. PPP, das
Point-to-Point Protokoll. Diese Protokolle werden benutzt, um mit dem WAP Gateway (s.
Glossar) zu kommunizieren. Eine Anfrage (z.B. ein http get (request)) wird an das WAP
Gateway weitergeleitet. Das Gateway stellt die Verbindung zwischen der drahtlosen Welt und
dem Internet dar. Es gibt spezielle WAP-Gateways, die versuchen, bestehende HTML-Informationen automatisch in WML umzuwandeln. Meistens genügt eine solche automatische
Umwandlung aber nicht, weil Informationen für kleinere Anzeigen kürzer und kompakter
formuliert und anders strukturiert werden müssen. Wenn man eine Information für alle Endbenutzer mit allen möglichen Geräten zur Verfügung stellen will, dann muss sie auf dem
Web-Server in zwei Versionen verfügbar sein:
•
•

die komplette Version für große Bildschirme als HTML-, XML- oder XHTML
(s. Glossar) Datei.
die gekürzte Version für kleine Anzeigen als WML-Datei.

Der Web-Server bekommt nun die Anfrage des Gateways, z.B. den Inhalt einer WAP-Seite
(textuellen WML-Code) zu senden, der vom Server zurück zum Gateway gesendet wird. Das
Gateway wandelt die erhaltene Seite in das binäre WML-XML Format (WBXML [2]) um.
WBXML ist die komprimierte Version der WML-Seite. Alle WML-Tags werden dabei durch
einzelne 8-Bit-Zeichen kodiert [9]. WML-Seiten werden in WBXML kompiliert. Dadurch
wird die benötigte Bandbreite und der Aufwand (Speicherplatzbedarf) eines WML-Parsers
reduziert. Das WAP-Gerät erhält nun die komprimierte WML-Seite (ein WAP-Browser kann
meist nur WBXML lesen). Die vom WAP Gerät angeforderte WML-Seite wird nun entpackt
und darstellt.

3 Aufbau einer WML-Seite
WML-Dateien sind reine ASCII-Text-Dateien. Sie tragen immer die Dateiendung .wml. Der
gesamte Inhalt einer WML-Datei, außer der XML-Deklaration und der Definition des Dokumententyps, wird in die Tags <wml> und </wml> eingeschlossen. Da Handy-Speicher klein
sind, wird die WML-Seite (man kann synonym den Begriff Deck verwenden) in einen oder
mehrere kleinere Abschnitte unterteilt. Diese Abschnitte nennt man Cards. Eine Card entspricht dem Teil des Decks, der gerade in der Anzeige des Handys dargestellt wird. Wegen
der derzeit relativ geringen Übertragungsraten wird ein Deck komplett übertragen, im Speicher abgelegt und die erste Card angezeigt [7]. Innerhalb eines Decks ist es möglich, zwischen Cards hin- und herzuspringen. Da sich diese bereits im Speicher befinden, muss dafür
keine neue Verbindung aufgebaut werden. Sobald ein anderes Deck geladen wird, wird der
Speicher des WAP-Gerätes geleert und mit den neuen Daten gefüllt. Da diese Vorgänge länger dauern, sollten logisch zusammenhängende Seiten möglichst in einem Deck integriert
werden.

3.1 Der Prolog
Jedes gültige WML-Dokument muss einen Prolog besitzen, der auf die verwendete XMLVersion und WML-Dokumentbeschreibung verweist. Damit die WML-Datei auch von XMLProgrammen verarbeitet werden kann, sollte man am Beginn der Datei, d.h. vor dem <wml>Tag, die XML-Deklaration in folgendem Format einfügen:
7

Global System for Mobile Communication: eine Übertragungstechnik für Mobilkommunikation bei 9,6 Kbit/s

94

WML (Wireless Markup Language)

<?xml version="1.0"?>
<!DOCTYPE wml PUBLIC "-//WAPFORUM//DTD WML 1.3//EN" "http://www.wapforum.org/DTD/wml_1_3.dtd">

Durch die Angabe von <?xml version="1.0"?> in der ersten Zeile wird angezeigt, dass
WML durch XML-Version 1.0 definiert wird. Die zweite Zeile legt den Dokumententyp fest
und spezifiziert den verwendeten WML-Standard, hier 1.3.

3.2 Entitäten, Sonderzeichen in WML
Die Zeichen <, > und & haben eine Sonderbedeutung in HTML und WML-Dateien. Anders
als in HTML sind in WML keine Entitäten wie &auml; für ä vordefiniert. Entitäten
z.B. Umlaute, scharfes s, französische Akzente, Copyright, Paragraph, das Euro-Symbol, etc.,
sollten in hexadezimaler Form nach dem Unicode-Standard in die WML-Seite eingebaut werden. Ein ü kann z.B. durch die Zeichenfolge &#xFC; dargestellt werden. Damit Texte auf
WAP-Geräten sinnvoll lesbar sind, die nur den ASCII verwenden und nicht den vollen ISO8859-1-Code darstellen können, sollte man Umlaute ersetzen.
&lt;
&gt;
&amp;
&quot;
&apos;
&nbsp;
&shy;
&#yy;
&#xyy;
$$

für das Kleiner-Zeichen <
(less than)
für das Größer-Zeichen >
(greater than)
für das Und-Zeichen &
Anführungszeichen
Apostroph
Leerzeichen, nicht trennbar (non-breaking space)
"weiches" Trennzeichen; hier wird (wenn nötig) getrennt (soft hyphen)
Entität Dezimal yy
Entität Hexadezimal 0xyy
Dollarzeichen

3.3 Das Deck
WML Seiten werden Decks genannt. Ein Deck (Stapel) ist mit einer HTML Seite vergleichbar. Jedes Deck beginnt mit <wml> und endet mit </wml> (s. Tabelle 3-1).
<wml>
...
</wml>

Weiterhin kann ein Deck Meta-Tags und Vorlagen8 (templates) enthalten.
Tabelle 3-1: Aufbau eines WML-Dokuments
WML Markup

Attribut/ Beschreibung

<?xml version="1.0"?>
<!DOCTYPE wml PUBLIC
"-//WAPFORUM//DTD WML 1.3//EN"
"http://www.wapforum.org/DTD/wml13.dtd">

Prolog, gibt die benutzte WML Version an.
Der Prolog darf nicht ausgelassen werden.

<!-- Kommentar-->

Kommentare werden nicht im Browser dargestellt und können überall im Dokument stehen.

<wml>

8

für alle Cards gültige <do>-Elemente (s. 3.13.4)

95
<head>

Bernhard Fechner
access

Domain
path

meta

http-equiv
name
forua
content
scheme

<head> ist optional.
Er enthält Informationen, die das ganze Deck betreffen.
Er muss mindestens ein <meta> oder ein <access>
Element enthalten

<template>
...
</template>

<template> ist optional.
Deklariert eine Vorlage für alle Karten im Deck.
Hier an Tasks gebundene Ereignisse gelten für alle Cards
im Deck. Eine <card> Deklaration kann diese Festlegung
überschreiben. Vorlagen können nur <do> oder
<onevent> Elemente enthalten (s. 3.13.5 Templates).

<card>

Die Seite muss mindestens eine Card enthalten.
Siehe 3.4 Cards

3.4 Cards
Ein Deck besteht aus einer oder mehreren Cards. Eine Card ist der Teil eines Decks, mit dem
der Benutzer navigiert. Cards können sich entweder auf einem Deck (einer Datei) zusammen
oder in unterschiedlichen Dateien befinden. Cards werden nacheinander in der Anzeige dargestellt. Jede Card entspricht einer (sehr kleinen) Bildschirm-Seite. Sie beginnt mit <card>
und endet mit </card> (s. Tabelle 3-2).
<card id="testcard" title="Ueberschrift der Card">
...
</card>

gibt die Bezeichnung der Karte in der Titelzeile und in Suchhilfen an. Mit der
für die Navigation notwendigen Identifikation der Karte (id) kann man auf die Card mit #id
zugreifen. Die id sollte nicht mehr als 8 Zeichen umfassen. Decks und Cards werden in der
Form [deckname][#cardname] angesprochen. Wenn [deckname] ausgelassen wird, wird der
Browser nach einer Card [#cardname] im geladenen Deck suchen. Wenn [#cardname] ausgelassen wird, wird der Browser das Deck [deckname] laden und zur ersten Card im Deck
springen. Wenn [deckname] und [#cardname] angegeben werden, wird der Browser das
Deck [deckname] laden und zur Card [#cardname] springen.
title="..."

Tabelle 3-2: Das card-Tag
WML
markup

Attribut

<card>

Beschreibung

Definiert eine WML Card. Kann mehrere Male in einem Dokument
auftauchen.
title=
newcontext=[true|false]
Default: false

</card>

Legt den Titel einer Card fest
der Kontext des WAP-Browsers wird in einen wohldefinierten
Zustand zurückgesetzt. Es werden alle Variablen und der Verlauf im
Browser-Kontext gelöscht.

true:

Abschließendes Tag

3.5 Variablen
Variablen werden benutzt, um Statusinformationen oder Benutzereingaben kontextsensitiv
von einer Card zur nächsten oder an einen Server weiterzugeben. Dies ermöglicht die Pro-

96

WML (Wireless Markup Language)

grammierung von dynamischen Cards. WML Variablen werden zur Laufzeit mit ihrem momentanen Wert substituiert. Nur Text kann substituiert werden. Weder WML-Elemente noch
Attribute können ersetzt werden. Eine Variable wird gesetzt, wenn sie einen Wert ungleich
dem leeren String (““) zugewiesen bekommt. WML Variablennamen bestehen aus einem
Dollarzeichen („$“) gefolgt von einem Buchstaben oder Unterstrich. Danach folgt eine beliebige Anzahl von Buchstaben, Zahlen oder Unterstrichen. Die Zeichenfolge nach dem Dollarzeichen kann auch geklammert werden. Groß- und Kleinschreibung wird unterschieden [9].
Tabelle 3-3: Das setvar-Tag
WML markup

Attribute

<setvar/>

Beschreibung

Eine Variable festlegen.
name=

Name der Variablen.

value=

Wert, der der Variablen zugewiesen werden soll.

3.6 CDATA
Mit dem CDATA-Element kann ein Text ohne Rücksicht auf Schlüsselwörter oder Sonderzeichen dargestellt werden.
<![CDATA[<Jedes> Zeichen, auch "$%&" erlaubt!]]>

3.7 Tabellen
HTML und WML gleichen sich bei der Deklaration von Tabellen sehr. title gibt den Titel,
columns die Anzahl der Spalten (Pflicht) der Tabelle an. tr (Table Row) leitet eine neue
Zeile, td (Table Delimiter) leitet eine neue Spalte ein. Das Verschachteln von Tabellen ist
nicht erlaubt.
Tabelle 3-4: Tabellendeklaration
WML
markup

Attribute

<table>

Beschreibung

Erstellt eine Tabelle. Kann nur <tr>-Elemente enthalten.
columns=

Anzahl der Spalten. Muss vorhanden sein.
Die Anzahl der Spalten darf nicht Null sein

title=

Titel der Tabelle, sollte nicht länger als 6 Buchstaben sein.

align=[left|right|center]

Textausrichtung für jede Spalte. Beispiel für 3 Spalten:
align=“LCR“: erste Spalte linksbündig, zweite zentriert,
dritte rechtsbündig.

<tr>

Gibt eine Tabellenzeile an. Darf nur <td>-Elemente enthalten.

<td>

Gibt eine einzelne Datenzelle an. Sie kann jede Art von Text
enthalten (Bilder, Hyperlinks, hervorgehobenen Text, etc.).

3.8 Textauszeichnungen
Wie in HTML, kann man auch in WML Texte hervorheben. Ob der Text tatsächlich dem Tag
entsprechend angezeigt wird, ist vom jeweiligen WAP-Gerät abhängig.
Tabelle 3-5: Textauszeichnungen mit em, strong, b, i, u, big und small
WML markup
<em>
<strong>

Bedeutung

Hervorgehoben
Stark hervorgehoben

97

Bernhard Fechner

<b>

Fett
Kursiv
Unterstrichen
Gross
Klein

<i>
<u>
<big>
<small>

Wie in HTML kann die Unterstreichung von Textpassagen zur Verwechslung mit einem Link
führen. Daher sollte man die Unterstreichung vermeiden.

3.9 Absätze
Text kann nur innerhalb von Absätzen (s. Tabelle 3-6) gesetzt werden, also zwischen <p> und
</p>.
Tabelle 3-6: Das p-Tag
WML
markup

Attribute

Beschreibung

align=[right|left|center]

Textausrichtung, Standard: left

mode=[wrap|nowrap]

<p>

wrap: lange Zeilen umbrechen bzw. scrollen
nowrap: den Zeilenumbruch unterbinden.
Standard: wrap, sonst der Modus des vorhergehenden Absatzes

Zeilenumbrüche innerhalb von Absätzen können durch das br-Tag <br/> erzwungen werden.

3.10 Bilder
Es ist möglich, Bilder in Cards einzubinden. WML bietet die Möglichkeit Grafiken mit dem
img-Tag <img/> in den Textfluss einzubauen. Dafür müssen die Grafiken im WBMP-Format,
vorliegen. Grafiken im BMP-Format können mit einem geeigneten Programm, z.B. den Nokia
WBMP Tools (http://7110.nokia.de/wapkurs/wbmp/wbmp_tools.zip) oder Dissect Image von
neutrinosoft (http://www.neutrinosoft.com/), in WBMP umgewandelt werden. Die Größe der
Bilder ist beschränkt: die Anzahl der Pixel darf meist nur zweistellig, abhängig von der Größe
der Anzeige sein. Die Grafiken haben eine Farbtiefe von 1 Bit (Schwarz-Weiß-Grafiken). Der
Alternativtext (s. Tabelle 3-7) wird immer dann verwendet, wenn der Browser keine Bilder
darstellen kann, oder das Bild nicht vorhanden ist. Weiterhin kann vspace (oben und unten)
und hspace (links und rechts) verwendet werden, um zusätzlichen Platz um das Bild herum
zu reservieren. align dient der Ausrichtung des Bildes. "height" und "width" geben Höhe
und die Breite des Bildes an. Diese Angabe wird in WML dazu verwendet, um Platz für das
Bild zu reservieren. Dadurch wird die Card schneller aufgebaut.
Tabelle 3-7: Das img-Tag
WML
markup
<img>

Attribute
alt=
src=
localsrc=
vspace=
hspace=
align=[top|middle|bottom]
height=
width=

Beschreibung

Alternative Textangabe für das Bild
URI des Bildes
Alternative interne Repräsentation des Bild-URI
Platz in Pixeln oder Prozent über dem Bild, Standard=0
Platz in Pixeln oder Prozent links vom Bild, Standard=0
Ausrichtung des Bildes im Textfluss
Höhe des Bildes in Prozent oder Pixel
Breite des Bildes in Prozent oder Pixel

Der Aufbau des Tags ist HTML ähnlich, ebenso die möglichen Eigenschaften des Tags.

98

WML (Wireless Markup Language)

<img src="test.wbmp" alt="Test" vspace="3" hspace="5" align="top">

3.11 Formulare
In WML sind Möglichkeiten für die Eingabe von Daten durch den Benutzer vorgesehen, die
dann als Parameter vom Client an ein auf einem Server laufendes CGI-Programm übermittelt
werden. In WML werden dazu Formulare eingesetzt. Für Formulare stehen Auswahllisten
(Select) und Eingabefelder (Input) bereit.
3.11.1 Auswahlliste (Select)
Eine Auswahlliste gibt dem Benutzer die Möglichkeit zwischen verschiedenen Optionen zu
wählen. Die Darstellung erfolgt dabei in Listenform. Es kann festgelegt werden, ob eine oder
mehrere Optionen innerhalb dieser Liste ausgewählt werden dürfen. Dazu muss
multiple="true" (s. Tabelle 3-8) in das select-Tag aufgenommen werden. Mit name kann
man die Ergebnisvariable angeben, in der die Auswahl gespeichert werden soll. Mit value
kann man eine Auswahl vordefiniert werden.
Tabelle 3-8: Das select-Tag
WML
markup
<select>

Attribut

name=
value=
iname=

ivalue=

tabindex=
title=
multiple=[true|false]
<option>
value=
title=
onpick=
</option>
</select>

Beschreibung

Auswahlliste definieren
Name der Variable
Vorgabe der Auswahl
Name der Index-Variablen, die den Index einer oder mehrerer
ausgewählter Optionen speichert. Dieser Variablen wird der Index
des oder der ausgewählten option-Tags zugewiesen.
Eine Option innerhalb des select-Tags als ausgewählt kennzeichnen, indem dem Attribut der gewünschte Index zugewiesen
wird. Das Attribut name nimmt den Wert, also den Index, des
Attributs ivalue an.
Bestimmt das Verhalten beim Weiterspringen, das sogenannte
'Tabbing'. Die Reihenfolge in der das Element angesprungen wird.
Titel
true: Auswahl von mehreren Elementen möglich
Ein Listenelement definieren
Der Wert eines Listenelements
Über dieses Attribut wird der Titel des option-Tag definiert.
onpick gibt eine URL an, die sofort angesprungen werden soll,
falls die Option ausgewählt wurde.
Abschließendes Tag für ein Listenelement
Abschließendes Tag für die Auswahlliste

Im folgenden Beispiel kann man mehrere Elemente aus der Liste auswählen:
<select multiple="true" name="tier" iname="indextier" ivalue="2;3">
<option value="cat">Katze</option>
<option value="dog">Hund</option>
<option value="horse">Pferd</option>
</select>

Durch ivalue="2;3" werden Hund und Pferd bereits markiert angezeigt. Wählt der Benutzer
Katze und Pferd aus, hat die Variable tier den Inhalt cat;horse, "indextier" hat den
Inhalt "1;3".

99

Bernhard Fechner

3.11.2 Eingabefelder (Input)
Hiermit kann ein Eingabefeld (s. Tabelle 3-9) in die Seite eingebaut werden. <input> erzeugt
ein Texteingabe-Feld und prüft die Eingabe gegen eine Format-Angabe. Das Ergebnis wird in
einer Variablen gespeichert. Mit name kann man eine Variable angeben, in der die Eingabe
gespeichert wird. value kann einen Text beinhalten, der beim Aufruf der Seite im Eingabefeld angezeigt wird. Die Eigenschaft type, ist entweder text oder password. Ist
type=“password“, so wird der eingegebene Text nicht im Eingabefeld angezeigt, sondern
durch eine Sternmaske überdeckt.
Tabelle 3-9: Das input-Tag
WML
markup
<input>

Attribut

Beschreibung

name=
value=
type=[text|password]
format=
maxlength=
title=
emptyok=[true|false]
size=
tabindex=
accesskey=
</input>

Eingabefeld definieren
Name der Variablen
Vorgabe
Typ des Eingabefeldes
(s. 3.11.2.1 Das format-Attribut)
Maximale Länge der Eingabe
Titel
true: das Eingabefeld darf einen leeren Wert enthalten.
Länge des Eingabefeldes.
Bestimmt das Verhalten beim Weiterspringen, das sogenannte
'Tabbing'. Die Reihenfolge in der das Element angesprungen wird.
(s. 3.11.2.2 Das accesskey-Attribut)
Abschließendes Tag

Zwischen <fieldset> und </fieldset> können mehrere zusammengehörige Eingabefelder zusammengefasst werden.
3.11.2.1 Das format-Attribut
Das format-Attribut gibt eine Maske für Benutzereingaben an. Die Maske besteht aus Steuerungszeichen (s. Tabelle 3-10) und statischem Text, der in der Eingabe angezeigt wird. Benutzt wird die formatierte Eingabe für beschleunigte Eingaben (Uhrzeiten etc.). Die Eingabe
ist nur gültig, wenn sie nur der Formatierungsvorlage entsprechende Zeichen und statischen
Text enthält. Die Formatsteuerung gibt das Datenformat an, das vom Benutzer eingegeben
werden soll. Die Standardeinstellung ist "*M".
Tabelle 3-10: Formatbeschreibungszeichen
Format
A
a
N
n
X
x
M
m
*f
nf
\c

Bedeutung

Großbuchstaben, Symbole oder Satzzeichen. Keine Ziffern.
Kleinbuchstaben s.o.
Ziffern
Ziffern, Symbole oder Satzzeichen.
Großbuchstaben, Symbole oder Satzzeichen.
Kleinbuchstaben s.o.
(Groß-)Buchstaben, Ziffern, Symbole, Satzzeichen, falls verfügbar
(Klein-)Buchstaben, Ziffern, Symbole, Satzzeichen, falls verfügbar
Jede Anzahl Buchstaben; f steht für [A|a|N|n|X|x|M|m] gibt an, welche Eingaben getätigt
werden können. Dieses Format darf nur einmal am Ende des Formatstrings angegeben werden.
n: [1-9] Buchstaben; s. *f.
Darstellung von nicht-formatierenden Buchstaben im Eingabefeld.
Beispiel Datumseingabe "NN\-NN\-NN": es wird ein 6-stelliges Eingabefeld, an jeder 2. Stelle
unterbrochen durch „-“, erzeugt.

100

WML (Wireless Markup Language)

3.11.2.2 Das accesskey-Attribut
Mit diesem Attribut kann einem (häufig benutzten) Element eine Funktionstaste zugewiesen
werden. Die verfügbaren Tasten variieren je nach Gerät. Auf Mobilteilen sind normalerweise
die Tasten "0"-"9", "*" und "#" verfügbar. Die Elemente A, INPUT, und ANCHOR unterstützen accesskey. Im folgenden Beispiel wird der Funktionstaste “1” ein Verweis zugeordnet. Beim Drücken der Taste wird der Hyperlink angesprungen.
<a accesskey="1" href="http://www.domain.com/inhalt.wml">Inhalt</a>

3.11.3 Übermittlung der Formulardaten
In ein Formular eingegebene Daten werden (meistens) durch ein CGI-Skript verarbeitet.
Im folgenden Beispiel wird das Versenden von Formulardaten erklärt. Der Benutzer soll seinen Vornamen und Nachnamen in das jeweilige Eingabefeld eintragen und hat dann die
Möglichkeit diese Eingabe zu versenden.
<p>
Vorname: <input type="text" name="vorname"/><br/>
Nachname: <input type="text" name="nachname"/>
</p>
<p align="center"><anchor>Senden
<go href="senden.pl" method="post">
<postfield name="pfvorname" value="$(vorname)"/>
<postfield name="pfnachname" value="$(nachname)"/>
</go>
</anchor></p>

Wenn der Link „Senden“ angeklickt wird, so wird (über das go-Task) ein auf dem Server laufendes Perl Skript senden.pl aufgerufen. Die im Formular eingegebenen Daten werden in
die Variablen vorname, nachname geschrieben. Durch das postfield-Tag werden die Variablen pfvorname, pfnachname durch vorname, nachname definiert und an das Skript übermittelt (geposted).
3.11.4 Das postfield-Tag
Über <postfield/> (s. Tabelle 3-11) können Variablen definiert werden, die mit Hilfe des
go-Tasks an eine URL übergeben werden können. Das postfield-Tag wird also innerhalb
des go-Tags eingebunden. Da die Variable nicht statisch, sondern von der Benutzereingabe in
einem Formularelement abhängig ist, muss der Inhalt der Variablen im Formularfeld dem
Inhalt der Variablen im postfield-Tag zugewiesen werden. Dies geschieht im postfieldTag durch value="$(variable)". Im obigen Beispiel stehen zwei Eingabefelder für den
Vor- und Nachnamen zur Verfügung. Die Eingabe im Feld für den Vornamen wird in der
Variablen vorname abgelegt. Um im postfield-Tag die Variable zu setzen, muss dort
value="$(vorname)" stehen.
Tabelle 3-11: Das postfield-Tag
WML markup

Attribut

<postfield/>

Beschreibung

Ein Formularübermittlungsfeld festlegen.
name=

Name der Variablen, die an eine URL übergeben wird.

value=

der (gesetzte) Wert der Variablen

101

Bernhard Fechner

3.12 Tasks
Tasks werden ausgeführt, wenn bestimmte Ereignisse aufgetreten sind (z.B. durch das doTag, die Auswahl eines anchor-Tags oder die Ereignisbehandlung). Bei WML unterscheidet
man zwischen vier verschiedenen Tasks - go, prev, refresh und noop.
<task "go/prev/refresh/noop">

3.12.1 go
Der go-Task wird über <go> und </go> oder durch <go/> definiert (s. Tabelle 3-12). Er bewirkt, dass eine URL (ein Deck) oder eine weitere Card aufgerufen wird. Mit Hilfe des goTasks können Variableninhalte, z.B. der Inhalt eines Formulars, an eine URL (nicht nur an
eine Card innerhalb eines Decks) übergeben werden, damit diese von einem CGI-Programm
verarbeitet werden können.
<go href="http://www.domain.de/deck"/>
<go href="#card"/>

Tabelle 3-12: Das go-Task
WML
markup

Attribut

<go/>

Beschreibung

Ein go-Task festlegen.
method=[get|post]

wap-Übermittlungsmethode

href=

Die Zieladresse (ein URL).

Dabei werden folgende Aktionen ausgeführt:
1. Die Ziel URL (href) wird Identifiziert und geholt.
2. Die angegebene Zielkarte wird lokalisiert.
3. Wenn keine Zielkarte angegeben wurde, wird die erste Karte des Deck geladen.
4. Wenn die Zielkarte in den Karten des geladenen Decks gefunden wurde, wird diese
Karte angezeigt.
5. Wenn die angegebene Zielkarte nicht gefunden wurde, wird die erste Karte des Deck
angezeigt.
6. Die Variablenzuweisungen werden in den momentanen Browserkontext übertragen.
7. Wenn die Zielkarte ein newcontext Attribut enthält, wird der Browserkontext aus der
Karte reinitialisiert.
8. Die Zielkarte wird auf den Verlaufsstack gelegt.
9. Wenn die Zielkarte eine onenterforward Ereignisbindung enthält, wird der mit dem
Ereignis verbundene Task ausgeführt.
10. Wenn die Zielkarte ein timer Element enthält, wird der Zeitgeber gestartet.
11. Die Zielkarte wird angezeigt.
3.12.2 prev
Der prev-Task wird über <prev/> definiert und ruft die im Verlauf vorhergehene URL auf.
<do type="prev" label="zur&#xFC;ck";>
<prev/>
</do>

102

WML (Wireless Markup Language)

1. Springt zur vorherigen URL im Verlauf. Wenn keine Karte auf dem Verlaufsstapel
liegt, wird keine Aktion ausgeführt.
2. Aktionen 2-7 aus 3.12.1
3. Wenn die Zielkarte ein Bindungen an das onenterbackward Ereignis enthält, wird der
mit dem Ereignis verbundene Task ausgeführt.
4. Aktionen 10-11 aus 3.12.1
3.12.3 refresh
Der refesh-Task wird über das refresh-Tag <refresh> und </refresh> definiert. Er bewirkt, dass die aktuelle Seite neu geladen wird und speziell die innerhalb des refresh-Tags
aufgeführten Variablen wie dort angegeben initialisiert werden. Es finden die Aktionen 6, 10
und 11 aus 3.12.1 statt.
<do type="reset" label="Neu darstellen">
<refresh>
<setvar name="alter" value="">
</refresh>
</do>

3.12.4 noop
no operation - es passiert nichts. Dieses Element kann zum Überschreiben eines Templates
gebraucht werden.
<do type="accept" label="AnfangsCard">
<noop/>
</do>

3.13 Ereignisbehandlung
In WML ist eine Ereignisbehandlung (event handling) vorgesehen, die es ermöglicht, vordefinierte Tasks ausführen zu lassen, wenn ein bestimmtes Ereignis eingetroffen ist. Es gibt vier
verschiedene Ereignisse: onenterforward, onenterbackward, ontimer und onpick. Die
Ereignisse onenterforward, onenterbackward und ontimer können innerhalb einer Card
und/oder auf dem Deck definiert werden. Das Ereignis onpick steht nur als Attribut des
option-Tags einer Auswahlliste (s. 3.11.1) zur Verfügung.
Eine Card kann also auf vier verschiedene Ereignisse reagieren:
• den Ablauf eines Timers (ontimer),
• den Aufruf einer Card mittels <go> (onenterforward),
• <prev> (onenterbackward) und
• dem Klicken einer Option einer Auswahlbox (onpick).
Das Auslösen der obigen Events kann direkt in der Deklaration der Cards und der Vorlage als
Attribut der Card definiert werden.

103

Bernhard Fechner

<card id="test" onenterbackward="deck50.wml">
<!-- Inhalt der Card -->
</card>

Einzige Ausnahme bildet onpick (s. 3.13.3) ausgelöst.
3.13.1 Ontimer
Dieses Ereignis tritt auf, wenn ein vorher mit timer definierter Timer abgelaufen ist. Ein
Timer wird <timer value=“Wert“ name=“id“/> definiert. “Wert“ ist dabei die
Anzahl der Zehntelsekunden, bis das Timer-Ereignis ausgelöst wird.

3.13.2 Onenterforward/ onenterbackward
Die Ereignisse onenterforward und onenterbackward werden ausgelöst, wenn die Card
aufgerufen wird. onenterforward wird ausgelöst, wenn eine Card oder ein Deck über einen
go-Task, oder direkt durch die Eingabe der URL aufgerufen wird. onenterbackward wird
ausgelöst wenn die Card über eine Aktion des Verlaufs9 erneut gestartet wird. Dies kann zum
Beispiel mit Hilfe eines prev-Tasks geschehen.
3.13.3 Onpick
Bis auf onpick sind die Ereignisse auf Cards bezogen. onpick dagegen kann man nur bei
Elementen aus Auswahllisten verwenden. Dabei wird das Ereignis onpick jedes mal ausgelöst, wenn der Benutzer ein Element der Auswahlliste markiert.
<select name="wohin">
<option onpick="hilfe.wml">Hilfe</option>
<option onpick="#info">Information</option>
</select>

Hier wird eine Auswahlliste definiert, die dem Benutzer zwei Optionen zur Verfügung stellt.
Wird die erste Option 'Hilfe' ausgewählt, so wird das Deck 'hilfe.wml' aufgerufen. Sollte die
zweite Option 'Information' ausgewählt werden, wird die Card mit der id 'info' angezeigt.
3.13.4 Eventbehandlung mit do
Sonderschaltflächen bzw. Menütasten werden mit <do> (s. Tabelle 3-13) in einer Card oder
einem Template für ein Deck definiert. Innerhalb des do-Tags wird ein vordefinierter Task
aufgerufen. <do> dient der Behandlung von eingetretenen Ereignissen. <do>-Elemente auf
Card-Ebene überschreiben gleichnamige <do>-Elemente auf Deck-Ebene. Mit noop kann der
Event-Handler des Decks auf einer Karte deaktiviert werden. Auf Deck-Ebene muss <do>
innerhalb von <template> und </template> stehen. Die Darstellung ist Browser-spezifisch.
<do type="prev" label="zur&#xFC;ck";>
<prev/>
</do>

Tabelle 3-13: Das do-Tag
WML
Markup

9

Attribute/ Beschreibung

Der Verlauf ist ein Zwischenspeicher, organisiert als Stack, in dem die bisher besuchten Seitenadressen
gespeichert werden.

104
<do>

WML (Wireless Markup Language)
Eine Aktion festlegen.
type=

Die Angabe ist Pflicht. Alle hier dargestellten Typen sind reserviert.
Folgende do-Typen sind vordefiniert:
Typ

Beschreibung

accept

Akzeptieren - dient der Bestätigung von Abfragen

prev

Zurück - Ähnlich dem Back-Buttons in HTML-Browsern.

help

Hilfe - Hiermit kann zum Beispiel ein Link zu einer Hilfeseite
eingebaut werden.

reset

Zurücksetzen - Zum Beispiel um ein Formular zu löschen.

options

Optionen - Für zusätzliche Einstellungen.

delete

Löschen eines Elementes oder der aktuellen Auswahl.

label=

Eine Beschriftung des Elements. Sollte nicht Länger als 6 Buchstaben sein.

name=

Optional. Wenn <do>-Elemente im Deck (in <template>) und in der Card
denselben Namen haben, überschreibt das <do>-Element in der Card das
<do>-Element in der Vorlage.

optional=[true|false]
Standard: false

Legt fest, ob der Brower das Element anzeigen muss
oder nicht.
true: der Browser ignoriert dieses Element.
Task: Siehe 3.12 Tasks

</do>

Die Eigenschaft type soll für den Browser ein Hinweis sein, wozu dieser spezielle Link gedacht ist. Es sind einige Typen vordefiniert. Diese werden allerdings unterschiedlich durch
den jeweiligen WML-Browser interpretiert.
3.13.5 Templates
Normalerweise werden Sonderschaltflächen und Ereignisbehandlungen innerhalb einer Card
definiert und stehen nur dort zur Verfügung. Will man einen Menüpunkt bzw. eine Ereignisbehandlung auf allen Cards eines Decks verfügbar machen, kann man ihn als Vorlage auf
Deck-Ebene innerhalb der template-Tags <template> und </template> deklarieren. Der
folgende Abschnitt muss vor der ersten Card stehen, als Vorlage für alle weiteren Cards. In
einem Deck darf nur eine Vorlage (template) existieren.
<template>
<do type="options" label="Zurueck" name="prev">
<prev/>
</do>
</template>

In jeder Card kann dieser Menüpunkt verwendet, überschrieben oder gelöscht werden. Ist in
einer Card kein do-Element mit dem gleichen Namen vorhanden, wird dieses Element gemäß
der Vorlage auch in der Card verwendet. Zum Überschreiben des do-Elementes in der Vorlage definiert man in der Card ein neues Element mit gleichem Namen. Dadurch ist man in
der Lage, verschiedene Optionen für verschiedene Cards festzulegen. Soll ein do-Element der
Vorlage auf einer Card überhaupt nicht gelten, erstellt man in der Card ein do-Element mit
dem noop-Task.

105

Bernhard Fechner

3.13.6 Das Onevent Element
Events können auch über das onevent-Tag (s. Abbildung 3-1) in eine Card und/ oder ein
Deck eingebunden werden, um einen vordefinierten Task auszuführen. Das onevent Element
bindet einen Task (siehe 3.12) an ein bestimmtes Ereignis, welches über das Attribut type des
onevent-Tags angegeben wird.
<onevent type="onenterbackward">
<go href="deckBack.wml"/>
</onevent>

Elem ent
tim er

anchor , a, input

do

select

accesskey

onpick

accept

option

help

reset

prev

delete

Events
ontim er

onenterforward

onenterbackward

onpick

(Onevent)

Tasks
go

prev

noop

refresh

Abbildung 3-1: Ereignisbehandlung in WML

3.14 Hyperlinks
Hyperlinks sind Verweise auf Informationen, die vom Benutzer ausgewählt werden können.
Die Navigation zwischen Cards innerhalb eines Decks oder zu einem anderen Deck wird in
WML, wie auch in HTML, über Hyperlinks ermöglicht. In WML gibt es zwei Möglichkeiten,
wie Links programmiert werden können, die sich sowohl in ihrer Syntax als auch in dem gedachten Einsatzzweck unterscheiden:
1. das a-Tag für interne / externe Links und
2. das anchor-Tag für Links mit Taskbindung.
3.14.1 Das a-Tag
Am einfachsten werden Verweise mit dem Tag <a> innerhalb von Absätzen in der folgenden
Form realisiert:
<a href="url">...Text...</a>
<a accesskey="1" href="#card">Gehe zu Karte</a>
<a href="http://wml.domain.de/deck.wml/#card">Gehe zu Karte</a>

Zwischen <a> und </a> steht ein Text oder eine Bildangabe, die vom Benutzer ausgewählt
werden kann. Href gibt das Ziel des Verweises an, entweder ein Deck oder eine Card. Das
Ziel kann also entweder absolut oder relativ angegeben werden.

106

WML (Wireless Markup Language)

3.14.1.1 interne Links mit <a>
Querverweise innerhalb einer Gruppe von WML-Dateien, die logisch zusammen gehören und
gemeinsam gewartet werden, werden mit internen Links realisiert. Hiermit können bestimmte
Karten innerhalb eines Decks ausgewählt werden. Im URL wird die id dieser Card mit einem
vorangestellten # angegeben. Wenn keine Card angegeben ist, wird zur ersten Card des Decks
gesprungen.
<a href="#card1">Zur Card 1</a>

3.14.1.2 externe Links mit <a>
Externe Links (s. Tabelle 3-14) regeln die Navigation zwischen Decks. Dabei kann die Angabe der Zieladresse (des Decks ) relativ (wml-deck-2.wml) oder absolut (http://wap.hafas.de)
erfolgen.
<a href="wml-deck-2.wml">Zum Deck 2</a>
<a href="http://wap.hafas.de/7110.wml"> Fahrplanauskunft der Bahn </a>

Tabelle 3-14: Das a-Tag
WML
markup

Attribute

<a>

Beschreibung

Eine Verknüpfung festlegen.
title=

Titel der Verknüpfung

href=

Die Zieladresse (ein URL).

accesskey=

(s. 3.11.2.2 Das accesskey-Attribut)
Abschließendes Tag.

</a>

3.14.2 Das anchor-Tag
Die zweite Möglichkeit eines Verweises wird durch das anchor-Tag (s. Tabelle 3-15) realisiert. Zusätzlich zur Funktion des a-Tags, besteht die Möglichkeit den Link an vordefinierte
Tasks (go, prev , refresh ) zu binden, die dann ausgeführt werden, wenn der Benutzer
den Link auswählt. Innerhalb des anchor-Tags wird das Linkziel und der Task festgelegt.
anchor wird u.a. verwendet, wenn Formulardaten gesendet werden sollen. Das anchor-Tag
besitzt das Attribut title durch das dem Link ein Titel zugeordnet wird.
<anchor>Gehe zu Deck
<go href="deck.wml"/>
</anchor>

Der (vordefinierte) Task, der hier genutzt wird ist der go-Task. Würde der Benutzer diesen
Link auswählen, dann würde er zu dem angegebenen Deck 'deck.wml' gelangen. Das Resultat
ist identisch mit dem des Beispiels des externen Links, der durch das a-Tag realisiert wurde.
Tabelle 3-15: Das anchor-Tag
WML
markup

Attribute

Beschreibung

107

Bernhard Fechner

<anchor>

Eine Verknüpfung (mit Tasks) festlegen.
title=

Titel der Verknüpfung. Sollte nicht länger als 6 Buchstaben sein.

accesskey=

(s. 3.11.2.2 Das accesskey-Attribut)

href=

Die Zieladresse (ein URL).
Task: Siehe 3.12 Tasks

</anchor>

Abschließendes Tag.

4 Fazit
Das Beziehen und Darstellen von (multimedialen) Informationen über das Internet auf einem
WAP-Gerät ist zur Zeit immer noch unbefriedigend. WML scheint eher eine Übergangslösung zu sein, die den Mangel an derzeit verfügbarer Bandbreite und die Zeitspanne bis zur
Einführung mobiler Netze (größerer Bandbreite s. Tabelle 4-1) überbrücken soll. Die
Geschwindigkeit wird sich mit Einführung neuer Netztechniken verbessern. WAP-Handys
eignen sich gut, um schnell an wenig Informationen zu kommen, eine Telefonnummer, eine
Zugverbindung, vielleicht auch zur Routenplanung. Derzeitige Handy-Netze sind bei vielen
gleichzeitig auftretenden Benutzeraktionen hoffnungslos überlastet. Langfristig scheint WML
keine guten Chancen zu haben. Sobald die Bandbreiten drahtloser Kommunikation steigen
und Handy-Anzeigen besser (farbiger und größer) werden, könnte sich HTML bzw. XHTML
bei Handys und anderen mobilen Kleingeräten durchsetzen. Dies wird möglicherweise schon
mit der Einführung des Hochgeschwindigkeits-Datendiensts GPRS, spätestens aber mit der
Verbreitung von UMTS der Fall sein. UMTS arbeitet deutlich schneller als ISDN und soll bis
Mitte des Jahrzehnts eine ähnliche Verbreitung wie das heutige GSM-Netz finden. Dann wird
die grafikarme WML wenig attraktiv werden, sich HTML auch bei Kleingeräten als Darstellungsnorm durchsetzen. Ein Anzeichen hierfür ist der Microsoft Mobile Explorer, der sowohl
WML als auch HTML unterstützt.
Tabelle 4-1: Übertragungstechniken für Handys

Name
HSCSD10
GPRS11
EDGE12
UMTS13

10

Übertragungsrate
bis 56,7 KBits/Sek.
bis 115 KBits/Sek.
bis 384 KBits/Sek.
über 2MBits/Sek.

Basis
GSM
GSM
GSM

Besonderheit
Paketvermittelte Übertragung
Kanalbündelung von bis zu 8 Kanälen
Mobilfunklizenzen und Funkstationen

High Speed Circuit Switched Data
General Packet Radio Service. Informationen unter: http://www.gsmworld.com/technology/gprs.html
12
Enhanced Data Rates for GSM Evolution
13
Universal Mobile Telecommunication System. http://www.gsmdata.com/artholley.htm
11

108

WML (Wireless Markup Language)

5 Der Quelltext (demo.wml) eines Beispiels
<?xml version="1.0" encoding="ISO-8859-1" ?>
<!DOCTYPE wml PUBLIC "-//WAPFORUM//DTD WML 1.3//EN" "http://www.wapforum.org/DTD/wml_1.3.dtd">
<wml>
<!-- Umlaute werden nach o.a. encoding direkt umgesetzt-->
<template>
<do type="prev" label="Zurück"> <!-- "Zurueck" auf jeder Card -->
<prev/>
</do>
</template>
<card id="card11" title="Start mit Timer" ontimer="#card12a">
<timer name="t1" value="100"/>
<do type="prev"> <!-- "Zurück" auf dieser Card deaktivieren -->
<noop/>
</do>
<do type="accept" label="Weiter"> <!-- "Weiter" auf dieser Card -->
<go href="#card12b"/>
</do>
<p align="center">
&lt;&quot;WML Demo!&quot;&gt;<br/>
<img src="titel.wbmp" alt="WML Seminar 01922" align="middle"/><br/>
Nach 10 Sekunden geht's weiter...<br/>
</p>
</card>
<card id="card12a" title="ontimer Event">
<p>
Sie sind automatisch hierher gekommen.<br/>
Wollen Sie <a href="#card13a">Aus-</a> oder<br/>
<a href="#card14">Eingaben</a>&nbsp;testen?
</p>
</card>
<card id="card12b" title="Timer">
<p>
$t1 Zehntel-Sekunden vergangen...<br/>
Wollen Sie <a href="#card13a">Aus-</a> oder<br/>
<a href="#card14">Eingaben</a>&nbsp;testen?
</p>
</card>
<card id="card13a" title="Formatierung">
<do type="prev" label="Zurück"> <!-- "Zurück" auf dieser Card -->
<go href="#card12a" />
</do>
<do type="accept" label="Weiter"> <!-- "Weiter" auf dieser Card -->
<go href="#card13b" />
</do>
<p>
<strong>strong </strong><em>emphasize</em><br/>
<big>big </big><small>small</small><br/>
<i>italics </i><u>underline</u>
</p>
</card>
<card id="card13b" title="Tabellen">
<do type="accept" label="Weiter"> <!-- "Weiter" auf dieser Card -->
<go href="#card12a" />
</do>
<p>
Umlaut a in der Tabelle einmal mit <i>encoding</i>, einmal als Unicode.
<table columns="1" title="Umlaut">
<tr><td>Ae Ä &#xc4; &#8364;1 -> $$1,63322</td></tr>
<tr><td>ae ä &#xe4; &#8362;1 -> $$0,01521</td></tr>
</table>
</p>
</card>

109

Bernhard Fechner

<card id="card14" title="Texteingabe POST">
<do type="accept" label="Fertig und senden!">
<go href="http://localhost/cgi-bin/demo.pl" method="post" sendreferer="true">
<postfield name="n" value="$nname"/>
<postfield name="v" value="$vname"/>
<postfield name="e" value="$essen"/>
<postfield name="g" value="$geschlecht"/>
</go>
</do>
<do type="delete" label="Löschen">
<refresh>
<setvar name="nname" value=""/>
<setvar name="vname" value=""/>
<setvar name="essen" value=""/>
<setvar name="geschlecht" value=""/>
</refresh>
</do>
<p>
Hallo $vname!
<fieldset title="Vor- und Nachname">
Vorname <input type="text" name="vname" value="" format="X*x"
tabindex="1" maxlength="32"/>
Nachname <input type="text" name="nname" value="" format="X*x"
tabindex="2" emptyok="true" maxlength="32"/>
</fieldset>
<fieldset title="Geschlecht, Essen">
Geschlecht
<select name="geschlecht" ivalue="1"> <!-- Weiblich vorwählen -->
<option value="weiblich">Weiblich</option>
<option value="maennlich">Männlich</option>
</select>
<br/>
Lieblingsessen
<select name="essen" multiple="true">
<optgroup title="Gemüse">
<option value="Tomaten">Tomaten</option>
<option value="Salat">Salat</option>
</optgroup>
<optgroup title="Fleisch">
<option value="Huhn">Huhn</option>
<option value="Rind">Rind</option>
</optgroup>
</select>
</fieldset>
</p>
</card>
</wml>

110

WML (Wireless Markup Language)

6 Glossar
Card
Der Bereich eines Decks, der gerade in der Anzeige eines WAP-Geräts dargestellt wird.
Client
Clients (Kunden) sind die Benutzer, die Informationen haben wollen. Client-Programme sind
die Programme, mit denen die Benutzer von ihren eigenen Rechnern (PCs) aus auf Informationen, die auf Servern gespeichert sind, zugreifen. WWW-Client-Programme werden auch als
Web-Browser bezeichnet.
CGI (Common Gateway Interface)
CGI-Programme sind Programme oder Shell-Scripts, die auf dem WWW-Server laufen, eventuelle Eingaben des Clients verarbeiten und die Ergebnisse in HTML an den Client-Rechner senden.
CSS (Cascading Style Sheets)
Ein einfaches Format für Style-Sheets für die Darstellung von HTML- und XML-Dokumenten.
Siehe auch XSL.
Deck
Eine Sammlung von Cards, die sich in einer Datei befinden. Ein WML-Dokument.
DHTML (Dynamische HTML)
Dynamisches HTML ermöglicht die Veränderung von Web-Seiten in Abhängigkeit von Benutzeraktionen direkt im Web-Browser.
DOM (Document Object Model)
DOM ist ein Objektmodell. Es beschreibt die in einem Dokument einer bestimmten XML-Anwendung enthaltenen Elemente als Objekte, für die Verarbeitung durch eine objekt-orientierte
Programmiersprache.
DSSSL (Document Style Semantics Specification Language)
DSSL ist eine sehr mächtige und daher auch sehr komplexe Sprache für die Spezifikation der
Darstellung von SGML-Dokumenten. Siehe auch CSS und XSL.
DTD (Document Type Definition)
Eine DTD beschreibt die Struktur einer Klasse von SGML- oder XML-Dokumenten, also einer
SGML- oder XML-Applikation, mit Hilfe einer Text-Datei, die alle Syntax-Regeln in einem von
SGML vorgeschriebenen Format enthält. Beispielsweise ist jede HTML-Version durch eine
DTD definiert. Eine Alternative dazu ist die Definition mit Hilfe eines Schemas.
EDI (Electronic Data Interchange)
EDI ist ein System zur Festlegung von normierten Formaten für den Austausch von Daten zwischen kommerziellen Datenverarbeitungsprogrammen (z.B. EDIFACT). Siehe auch XML.
HTML (Hypertext Markup Language)
HTML ist das Format, in dem Text- und Hypertext-Informationen im WWW gespeichert und
übertragen werden.
HTTP (Hypertext Transfer Protocol)
HTTP ist das Protokoll, nach dem Informationen zwischen WWW-Servern und WWW-Clients
über das Internet übertragen werden.
Hypertext
Unter Hypertext versteht man Texte, die mit weiteren Texten über Verweise vernetzt sind. Im
WWW werden solche Verweise mit der Hilfe von URLs realisiert. Bei Hypertext-Dokumenten
gibt es keine lineare Lesereihenfolge, sondern die Leser können jede Einzelinformation über
viele verschiedene Wege und von vielen verschiedenen Stellen aus erreichen.
Internet
"Interconnected Networks" (verbundene Netze); das Internet ist die Gesamtheit aller miteinander verbundener Netze, die TCP/IP verwenden.
SAX (Simple API for XML)
SAX ist eine Programm-Schnittstelle (Application Programmers Interface, API) für die Verarbeitung einer Klasse von XML-Dokumenten, also einer XML-Applikation, mit Hilfe einer objektorientierten Programmiersprache. Siehe auch DOM.

111

Bernhard Fechner

Schema (Mz.: Schemata)
Ein Schema beschreibt die Struktur einer Klasse von XML-Dokumenten, also einer XML-Applikation, ähnlich einer DTD, jedoch nicht in DTD, sondern in XML-Syntax.
SGML (Standard Generalized Markup Language)
SGML ist eine Meta-Sprache, durch die Markup-Sprachen wie z.B. HTML definiert werden
können. Die Struktur und Syntax solcher Markup-Sprachen ("SGML-Anwendungen") wird mit
einer DTD festgelegt. Siehe auch XML.
Style-Sheets
Style-Sheets bieten eine gute Möglichkeit, die Darstellung des Inhalts von Web-Seiten in einem
einheitlichen und konsistenten Layout zu bewirken.
URL (Uniform Resource Locator)
Der URL enthält Informationen wie die Art des Zugriffs (Protokoll) und die Adresse des
Server-Computers (Hostname).
WAP (Wireless Application Protocol)
WAP ist ein einfaches Gegenstück zu HTTP, entwickelt für die Übertragung von WML-Dateien
auf Mobil-Telefone und ähnliche Geräte.
WAP-Gateway
Ein WAP-Gateway ist ein Proxy-Server, der Mobil-Telefone (Handys) auf der einen Seite mit
Web-Servern auf der anderen Seite verbindet. Die Verbindung zwischen Handy und WAP-Gateway erfolgt über das Telefonnetz durch das WAP, die Verbindung zwischen WAP-Gateway
und Web-Server über das Internet durch das HTTP. Die Bezeichnung WAP-Gateway wird auch
für Umwandlungsprogramme verwendet, die die dort vorhandenen HTML-Informationen automatisch (so gut das geht) in WML übersetzen.
Web-Browser
Als Web-Browser bezeichnet man Client-Programme für den Zugriff auf WWW-Server.
WML (Wireless Markup Language)
WML ist das Gegenstück zu HTML für die Darstellung von Informationen auf Mobil-Telefonen
(Handys) und anderen Geräten mit kleinen Anzeigen. WML baut nicht auf HTML sondern auf
XML auf, ist also ähnlich wie HTML, aber nicht zu HTML kompatibel. WML-Dateien werden
wie HTML-Dateien auf Web-Servern gespeichert, der Zugriff erfolgt über ein WAP-Gateway
mit WAP.
XHTML (Extensible Hypertext Markup Language)
Mit XHTML bezeichnet man eine HTML-Datei, die den strengeren Syntax-Regeln von XML
entspricht. XHTML 1.0 entspricht dem Funktionsumfang von HTML 4.0.
XML (Extensible Markup Language)
XML ist eine vereinfachte Form von SGML. Mit XML können eigene Markup-Sprachen oder
auch eigene Erweiterungen von HTML bzw. XHTML mit eigenen Tags für bestimmte Elemente
mit bestimmten logischen Bedeutungen definiert werden.
XML-Parser
Ein XML-Parser ist ein Programm, das eine XML-Datei liest und den Inhalt in der Form von
DOM oder SAX liefert. Ein validierender Parser überprüft zusätzlich die Richtigkeit der Daten
an Hand der DTD oder des Schemas.
XSL (Extensible Style Language)
Mit XSL wird ein Style-Sheet definiert, das angibt, wie der in einem XML-Dokument definierte
Inhalt vom Web-Browser oder anderen Programmen dargestellt werden soll.
XSL ist mächtiger als CSS und DHTML.

112

WML (Wireless Markup Language)

Literatur
[1]

"Wireless Application Protocol Architecture Specification", WAP Forum, 30.04.98.
URL: http://www.wapforum.org/

[2]

"Binary XML Content Format Specification", WAP Forum, 04.11.99.
URL: http://www.wapforum.org/

[3]

"Extensible Markup Language (XML), W3C Proposed Recommendation 10.02.98.
REC-xml-19980210", T. Bray, et al, 10.02.1998.
URL: http://www.w3.org/TR/REC-xml

[4]

"HTML 4.0 Specification, W3C Recommendation 18-December-1997,
REC-HTML40-971218", D. Raggett, et al., 17.09.97.
URL: http://www.w3.org/TR/REC-html40

[5]

"Information Processing - Text and Office Systems -
Standard Generalised Markup Language (SGML)", ISO 8879:1986.

[6]

Bager, Jo:
Das Handy spricht Web; Eine kurze Einführung in die Wireless Markup Language;
c´t 22 (1999) S. 126

[7]

Röwekamp, Lars:
Handy HTML: Einführung in die Wireless Markup Language; iX 2 (2000) S. 52

[8]

http://updev.uplanet.com/dev/ts/htmldoc/32w/wmlref/

WML Referenz
[9]

WAP WML Specification Version 1.3, WAP Forum, 10.02.2000.
URL: http://www.wapforum.org/

Aufbau von Ad-hoc Netzwerken mit Jini
Robert Bozic

Robert.Bozic@Fernuni-Hagen.de
Zusammenfassung: Mit Jini ergeben sich Möglichkeiten einer spontanen Kommunikation zwischen verschiedenen Jini-Diensten in Netzwerken. Dabei können unterschiedliche
Geräte (Computer, Unterhaltungselektronik oder elektronische Haushaltsgeräte) auch bei
einem Wechsel des Ortes problemlos miteinander kommunizieren; eine manuelle Suche
nach erforderlichen Treibern für die Hardware-Kommunikation ist nicht mehr erforderlich. Um dies zu realisieren baut die spontane Vernetzung auf folgende fünf Grundprinzipien auf: Discovery, Lookup, Leasing, Remote (Ereignisse), Transaktion.

1 Was ist Jini ?
Jini (Java Intelligent Network Infrastructure) ist eine Sammlung von Java Klassen und
Diensten, entwickelt von der Firma Sun, die eine Zusammenarbeit von beliebigen Geräten
(Computer, Unterhaltungselektronik oder elektronische Haushaltsgeräte) erheblich erleichtert.
Es stellt allen Beteiligten eine Infrastruktur zur Verfügung, die als ein dynamisch verteiltes
System arbeitet, da permanent neue Dienste hinzugefügt oder entfernt werden können. Jini ermöglicht den Verbindungsaufbau zwischen verschiedenen Geräten mit Hilfe verschiedener
Dienste; diese werden durch Java-Objekte dargestellt. Voraussetzung für diese Dienste ist die
Java Virtuelle Machine (JVM), die auf dem Rechner installiert sein muss. Dank Jini ist eine
manuelle Konfiguration nicht mehr notwenig, somit erübrigt sich eine manuelle Suche nach
erforderlichen Treibern für die Hardware-Kommunikation, denn Jini-Dienste erkennen JiniHardware automatisch an. Den größten Vorteil von Jini erkennt man beim Ausführen von
Diensten; temporäre Einstellungen, die für eine optimale Nutzung der Jini-Dienste angenommen wurden, setzen sich automatisch wieder zurück bzw. werden gelöscht, nachdem sie
nicht mehr in Anspruch genommen werden, z.B. bei einem örtlichen Wechsel oder wenn sich
keine andere Jini-taugliche Hardware in der Nähe befindet. Somit ist das Arbeitsprinzip von
Jini spontan und flexibel, da es sich jederzeit auf neue Aufgabensituationen einstellt.

2 Voraussetzungen für einen Jini-Dienst
Jedes Jini-fähige Gerät muss über einen eigenen Prozessor mit ausreichend Speicher verfügen
auf dem eine JVM lauffähig ist. Solche Geräte müssen außerdem eine Infrastruktur für Kommunikation besitzen. Als Gerät oder Dienst müssen Sie folgendes gewährleisten:
• Sie müssen in der Lage sein, eine Verbindung mit einem TCP/IP-Netzwerk herzustellen
und über eine IP Adresse einen vollständigen TCP-Protokollstapel von Multicast-Nachrichten zu senden und zu empfangen.
• Sie müssen den Discovery-Vorgang durchführen, um mindestens einen Lookup-Dienst
aufzufinden.
• Sie müssen sich bei einem Lookup-Dienst registrieren und diesem ein Proxy-Objekt übergeben, welches der Client herunterladen kann, um den Dienst zu verwenden.
• Sie müssen dafür sorgen, dass die Leases bei der Lookup-Registrierung verlängert werden, solange der Dienst verfügbar ist.

114

Aufbau von Ad-hoc Netzwerken mit Jini

3 Java-RMI-Technologie
RMI ist ein Java-Mechanismus, um Methoden von Objekten, die nicht auf derselben Java
Virtual Machine laufen, aufrufen zu können. Dabei bietet der RMI eine weitgehende Transparenz, so dass nach einer anfänglichen Initialisierung ein Aufruf genauso verwendet wird wie
im lokalen Fall. Der RMI ist in mehreren Schichten aufgebaut, wobei die oberste Schicht die
darunter liegenden Schichten, wie die Socketkommunikation und das Serialisieren und Deserialisieren von Parametern und Ergebniswerten, verdeckt. Bei RMI gibt es jeweils einen
Dienstanbieter, den Server, und einen Dienstnehmer, den Client. Zwar sind beide Objekte in
Java implementiert, doch der Server muss als solcher gekennzeichnet und für einen entfernten
Zugriff vorbereitet werden, bevor er vom Client genutzt werden kann. Während im nichtverteilten Fall das Verhältnis zwischen zwei Objekten symmetrisch ist (jedes Objekt kann ein
anderes aufrufen, solange es Referenz darauf hat), ist dies bei RMI asymmetrisch.
Der Server muss die Schnittstelle, die er für den entfernten Zugriff zur Verfügung stellt, in
einer Interface-Beschreibung, die vom Interface Remote abgeleitet ist, dokumentieren. Der
Stub ist ein Stellvertreterobjekt, das die gleiche Schnittstelle wie das Serverobjekt anbietet
und einen Aufruf zu seinem Serverobjekt weiterleitet. Das Skeleton verbleibt auf der Serverseite und nimmt die Aufrufe des Stubs entgegen, bereitet sie auf, übermittelt den Aufruf an
das Serverobjekt, erwartet das Ergebnis und sendet dieses zurück an den Stub. Stub und
Skeleton bilden zusammen eine Protokollschicht in der RMI-Architektur. Die darunter
liegende Referenzschicht dient dieser, um den jeweiligen Kommunikationspartner zu finden.
Da sich verteilte Objekte nicht genauso verhalten wie lokale Objekte, erben RMI-Objekte
nicht direkt von der Klasse java.lang.Object, sondern von der Klasse java.rmi.RemoteObject
Dadurch werden einige Methoden von java.lang.Object überladen, um diese an die Bedingungen in verteilten Systemen anzupassen. Von dieser ist wiederum die Klasse
java.rmi.UnicastRemoteObject abgeleitet, die einen Dienst mit Punkt-zu-Punkt-Verbindungen
anbietet.

Abbildung 1: Java-RMI-Technologie

4 Grundlegende Architektur von Jini
Um eine spontane Funktionalität von Diensten zu erreichen, baut die Architektur von Jini auf
fünf Grundprinzipien auf.
•
Discovery

115
•
•
•
•

Robert Bozic
Lookup
Leasing
Remote - Ereignisse
Transaktionen

Abbildung 2: Grundlegende Architektur von Jini

4.1 Discovery
Bevor eine Jini-fähige Einheit andere Jini-Dienste nutzen kann, müssen ihr eine oder mehrere
Jini-Gemeinschaften bekannt sein. Dies kann die Einheit durch das Auffinden eines LookupDienstes an dieser Stelle bewerkstelligen, wo die gemeinsamen verwendeten Ressourcen
innerhalb einer Gemeinschaft verwaltet werden. Dieser Vorgang des Auffindens eines verfügbaren Lookup-Dienstes wird als Discovery bezeichnet. Sobald ein Lookup-Dienst eine
Multicast-Discovery-Anfrage erhält, antwortet er durch direkte Verbindungsaufnahme mit
dem angeforderten Dienst und Sendet eine Unicast-Nachricht (d.h. von Punkt zu Punkt).
Diese enthält das Proxy-Objekt, das der Dienst verwenden kann, um Kontakt mit dem
Lookup-Dienst aufzunehmen. Genaugenommen kann das Discovery durch drei verschiedene
Protokolle ausgeführt werden:
• Multicast-Request-Protocol: Das Multicast-Request-Protocol ist ein vom Dienst initiiertes
Protokoll, welches eingesetzt wird, wenn ein Dienst alle Lookup-Dienste entdecken muss,
die in einem lokalen Netzwerk bereits vorhanden sind. Sobald ein Lookup-Dienst die
Multicast-Nachricht erhalten hat, kann es den Suchenden Dienst ein Proxy-Objekt übermitteln. Wenn sich der Client auf das Senden von Anforderungen und den Empfang von
Antworten eingerichtet hat, sendet er in bestimmten Abständen Multicast-Request-Nachrichten. Diese gehen an eine festgelegte Adresse, die Jini-Lookup-Dienste abhört (IPAdresse 224.0.1.85, Port-Nummer 4160).

116

Aufbau von Ad-hoc Netzwerken mit Jini

Abbildung 3: Multicast-Request-Protocol

•

Multicast-Announcement-Protocol: Dieses Protokoll wird während der gesamten Lebensdauer eines Lookup-Dienstes verwendet. Es wird vom Lookup-Dienst für die Bekantmachung an die interessierten Clients verwendet, wobei in bestimmten Abständen die Bereitschaft des Lookup-Dienstes an alle Clients gesendet wird. Wenn ein Lookup-Dienst gestartet wird, erstellt er einen UDP-Multicast-Socket für das Senden seiner Ankündigungsnachrichten. Dieser ist an eine festgelegte Adresse gebunden, an der die Clients auf die
Bekanntmachungen warten (IP-Adresse 224.0.1.84, Port-Nummer 4160). Außerdem erstellt der Dienst einen TCP-Socket, um dort auf eingehende Unicast-Nachrichten von
Clients zu warten, welche die Bekantmachung gehört haben um daraufhin das Proxy-Objekt des Lookup-Dienstes mit Hilfe von Unicast Discovery anzufordern.

Abbildung 4: Multicast-Announcement-Protocol

•

Unicast-Discovery-Protocol: Der Client versucht sich beim Unicast-Discovery-Protocol
mit einem Lookup-Dienst zu verbinden, dessen Existenz an einem bestimmten Ort (Host
und Portnummer) bekannt ist.

4.2 Lookup
Ein Lookup-Server verwaltet eine Liste von Dienstelementen. Jedes Dienstelement umfasst
ein Proxy-Objekt und eine Liste mit Attributen, die den Dienst beschreiben. Im Dienstelement

117

Robert Bozic

wird ein serialisierbares Java-Objekt angeboten, das als Proxy-Objekt bezeichnet wird. Sobald
ein Client (bei dem es sich selbst um einen Dienst handelt) über eine Referenz auf einen
Lookup-Dienst verfügt, sucht sich der Client das richtige Dienstelement aus und ladet das
Proxy-Objekt herunter. Nach dem Herunterladen des Proxys, verwendet der Client diesen
für das direkte Kommunizieren mit dem Dienst. Dieses Konzept, Proxy-Objekte herunter zu
laden, ermöglicht Jini die Fähigkeit, Dienste und Geräte ohne explizite Installation von Treibern oder sonstiger Software zu verwenden.

Abbildung 5: Lookup-Server

Jini bietet mehrere Möglichkeiten des Suchens nach Dienstelementen. Dies erfolgt auf dem
Typ des im Dienstelement enthaltenen Proxy-Objekts oder der in Dienstelementen enthaltenen Attribute. Eine Digitalkamera (stellt sich selbst als Dienst zur Verfügung) möchte das
direkte Drucken von Bildern auf einen beliebigen, gerade verfügbaren Drucker ausführen. Um
jeden verfügbaren Drucker verwenden zu können, fungiert die Kamera als Verwender eines
Druckdienstes. In diesem Fall ist es am wahrscheinlichsten, dass die Kamera alle LookupDienste ihrer Gemeinschaft durchsucht um Dienstelemente zu ermitteln, welche die Schnittstelle Printer implementieren. Die Lookup-Dienste könnten darauf mit einem oder mehreren
Proxies antworten, welche diese Schnittstelle implementieren. Daraufhin könnte die Kamera
dem Benutzer ermöglichen, sich auf der LCD-Anzeige anhand der entsprechenden Namen,
Orte oder Kommentare, die den jeweiligen Attributen entnommen sind, einen der verfügbaren
Drucker auszusuchen. Will der Benutzer ein Bild mit einem bestimmten Drucker ausdrucken,
wird dazu die Print-Methode des Proxy-Objekts aufgerufen, welche die Ausgabe an den
Drucker sendet.

118

Aufbau von Ad-hoc Netzwerken mit Jini

Abbildung 6: Lookup und Proxy-Objekt

4.3 Leasing
Das Konzept Leasing bei Jini ist vollkommen identisch zu Leasing im alltäglichen Leben.
Allgemein gesprochen wird durch das Leasing die Nutzung einer Ressource für einen bestimmten, definierten Zeitraum zugesichert. Der Zeitraum, in dem eine Nutzung erfolgen
kann, wird zwischen den beteiligten Parteien (Dienstanbieter und Lookup-Dienst) bei der
erstmaligen Registrierung ausgehandelt. Ein Leasing-Ansatz ist notwendig, da in verteilt
arbeitenden Systemen die Jini-Dienste nicht verfügbar sein können. Dies sei bedingt, z.B.
durch ein ausgefallenes Rechnernetz oder einen Leasing-Nehmer (Client), der nicht mehr
interessiert an einem Jini-Dienst ist. Um einen Jini-Dienst als verfügbar zu melden, erneuert
jeder Jini-Dienst von sich aus das Leasing, und zwar beim Lookup-Dienst, wo es sich registriert hat. Falls das Leasing nicht erneuert wird, so löscht der entsprechende Lookup-Dienst
den entsprechenden Jini-Dienst. Alle Clients, die diesen Jini-Dienst benutzen, werden über
dessen Ausfall informiert.
Eines der größten Vorteile des Leasings besteht darin, dass es Mitgliedern einer Jini-Gemeinschaft eine praktische, wartungsfrei persistente Speicherung von Diensten ermöglicht. Systemverwalter brauchen sich nicht mehr durch Protokolle durchzuarbeiten um festzustellen,
welche Dienste aktiv bzw. inaktiv sind und welche Dienste veraltete Daten im System aufweisen.
Das Leasing lässt sich durch folgende Punkte charakterisieren:
• Es gibt ein Leasing-Zeitintervall, in dem der Dienstanbieter (Client) dem Dienstnehmer
(Lookup-Dienst) die Verfügbarkeit eines Dienstes zusichert.
• Innerhalb eines Leasing-Zeitintervalls kann der Dienstnehmer einen Dienst kündigen.
• Ein Leasing-Zeitintervall kann erneuert werden.
• Ein Leasing-Zeitintervall kann verfallen.
Diese aufgeführten Punkte sind in dem Interface Lease aus dem Package net.jini.core.lease
festgelegt.

119

Robert Bozic

Import java .rmi.RemoteException;
public interface Lease
{
long FOREVER = Long.MAX_VALUE;
long ANY = -1;
int DURATION =1;
int ABSOLUTE =2;
long getExpiration ( ) ;
void cancel ( ) throws UnknownLeaseException,
RemoteException;
void renew ( long duration ) throws LeaseDeniedException,
UnknownLeaseException,
RemoteException;
....
}
Durch das Interface wird die Konstante FOREVER definiert. Damit kann festgelegt werden,
dass der entsprechende Dienst nie verfällt und somit auch niemals erneuert werden muss. Die
nächsten beiden Konstanten geben das Format zur Angabe des Verfallzeitpunktes an. Bei
DURATION erfolgt die Angabe in Millisekunden (gerechnet vom Zeitpunkt der Serialisierung), und bei ABSOLUTE wird von einer absoluten Zeit (ebenfalls in der Maßeinheit Millisekunden) ausgegangen. Die Methode getExpiration liefert die verbleibende Zeit bis zum
Ablaufzeitpunkt (relativ zur eigenen Zeit, auch in Millisekunden).
Mittels cancel ( ) wird ein Dienst gelöscht, bevor sein Verfallsdatum erreicht ist. Durch die
Methode renew kann die Gültigkeit eines Service um ein weiteres Zeitintervall verlängert
werden.

4.4 Remote-Ereignisse
Für asynchrone Benachrichtigungen verwendet Jini in Übereinstimmung mit der in Java üblichen Vorgehensweise sogenannte Ereignisse. Ein Ereignis ist ein Objekt das Informationen
über eine externe Zustandsänderung enthält, an der eine Software-Komponente interessiert
sein könnte. Bei AWT wird beispielsweise ein MouseEvent gesendet, wenn sich der Zustand
der Maus ändert, sobald die Maus bewegt wird. Ereignisse werden dem System mit Hilfe von
Ereigniserzeugern hinzugefügt, die für das Feststellen von Zustandsänderungen zuständig
sind. In Java wird ein Ereignis, unmittelbar nachdem es vom System festgestellt wurde, an
alle Parteien gesendet, die sich für Ereignisse der jeweiligen Art interessieren. In dieser Hinsicht funktioniert das Ereignismodell von Jini exakt genauso wie in Java. All diese Modelle
unterstützen Ereignisse und rufen Methoden von Listenern asynchron auf, sobald Ereignisse
auftreten. Die Aufgabe eines verteilt wirkenden Ereignis-Mechanismus ist es, einem Java-

120

Aufbau von Ad-hoc Netzwerken mit Jini

Objekt in einer JVM die Möglichkeit zu geben, ein Ereignis in einer anderen JVM auszulösen.
In einem verteilten Ereignissystem existieren drei Komponenten:
• ein Objekt, das durch eine Registrierung Interesse an einem Ereignis zeigt.
• ein Objekt, in dem das Ereignis stattfindet (Ereigniserzeuger).
• einen Empfänger von Ereignissen (Ereignis-Listener).
Durch die Änderung interner Zustände des Objekts, in dem das Ereignis stattfand, können
Ereignisse ausgelöst werden. Der Ereignis-Listener wird von dieser Zustandsänderung informiert. Das Programmiermodell für Remote-Ereignisse stützt sich auf das Package
net.jini.core.event, wo einige einfache Klassen und Interfaces zur Unterstützung von RemoteEreignissen zur Verfügung gestellt werden.
Sender von Ereignissen benutzen die Klasse RemoteEvent. Ein Ereigniserzeuger enthält unter
anderem neben einer Ereignisnummer noch einen Verweis auf das Objekt, in dem das Ereignis aufgetreten ist.
public class RemoteEvent extends java.util.EventObject
{
protected Object source;
protected long eventID;
protected long seqNum;
protected MarshalledObject handback;
public RemoteEvent( Object source, long eventID,
long seqNum,
MarshalledObject handback )
public long getID( );
public long getSequenceNumber ( );
public MarshalledObject
getRegistrationObject( );
}
Object source stellt hierbei die Quelle des Ereignisses (also dessen Verursacher) dar. Mit
eventID wird die Art des Ereignisses charakterisiert und mit seqNr die Sequenznummer. Aus
der Kombination der Objektreferenzen des Ereignisgenerators und der Ereignis-ID lässt sich
der Ereignistyp bestimmen. Stößt man auf ein nicht registriertes Ereignis, so wird
UnknownEventException erzeugt. Dank der Kombination aus Zeitpunkt (zu dem ein Ereignis
eintrat) und der Sequenznummer, kann es zu keiner Verwechslung zwischen verschiedenen
verteilten Ereignissen kommen.

121

Robert Bozic

Bei dem Empfänger einer Benachrichtigung muss es sich nicht notwendigerweise um dasselbe Objekt handeln, das für die Registrierung verantwortlich ist. Bei der Benachrichtigung
ist ein Empfänger-Parameter erforderlich. Dieses Empfängerobjekt muss das
RemoteEventListener-Interface implementieren. Die Registrierung für ein bestimmtes Ereignis ähnelt der Registrierung beim Leasing-Mechanismus.
public interface RemoteEventListener extends java.rmi.Remote, java.util.EventListener
{
void notify ( Remote theEvent)
throes UnknownEventException,java.rmi.RemoteException;
}
Durch die notify-Methode werden interessierte Empfänger darüber informiert, dass ein bestimmtes Ereignis (RemoteEvent) durch den Ereignisgenerator ausgelöst wurde. Um einen
Ereignisempfänger bei einem Ereigniserzeuger zu registrieren, wird die Klasse
EventRegistration verwendet.
public class EventRegistration implements java.io.Serializable
{
public EventRegistration( long eventID,
Object eventSource,
Lease eventLease,
long seqNum )
public long geIDt( );
public Object get Source ( );
public Lease getLease ( );
public long getSequenceNumber ( );
}
Die Methode getID liefert einen Ereignis-Identifikator, für das eine Registrierung erfolgt,
zurück an den Empfänger. In Kombination mit getSorce ( ) kann ein Ereignis identifiziert
werden. Die getLease-Methode aus der Klasse Event Registration liefert das Lease-Objekt für
die Registrierung zurück .

4.5 Transaktionen
Eine Transaktion ist eine unteilbare Aktion. Dabei besteht eine Aktion aus einer oder mehreren Operationen. Eine Transaktion wird entweder vollständig oder gar nicht ausgeführt. Tritt
während einer Transaktion ein Zustand ein, der ein weiteres Fortführen nicht gestattet, so
werden alle bisher getätigten Operationen wieder zurückgesetzt, und der Zustand vor der Ausführung der Transaktion wird wieder hergestellt. Bei Jini basiert die Transaktion auf dem
Two-Phase-Commit-Protocol, das sich in zwei Bearbeitungsschritte unterteilen lässt.

122

Aufbau von Ad-hoc Netzwerken mit Jini

• Vorbereitungsschritt
• Commit Schritt
Beim ersten Schritt, dem sogenannten Vorbereitungsschritt, fordert der Transaktionsmanager
alle an der Transaktion Beteiligten auf, sich auf eine Durchführung ihrer Operationen vorzubereiten. Dies bedeutet, dass alle Beteiligten, die als Teilnehmer bezeichnet werden, folgendes zu tun haben: Zum ersten ermittelt jeder Teilnehmer das Ergebnis seiner Operation
und speichert es temporär in eine Protokolldatei. Danach übermittelt jeder Teilnehmer dem
Transaktionsmanager, ob er diesen Zustand erfolgreich einnehmen konnte.

Abbildung 7: Transaktion- Vorbereitungsschritt

Beim zweiten Schritt, der als Commit bezeichnet wird, wertet der Manager sämtliche Bestätigungen aus, die er nach dem Absolvieren der ersten Stufe von den Teilnehmern erhalten
hat. Falls einer der Teilnehmer nicht in der Lage war sich erfolgreich auf den zweiten Schritt
vorzubereiten, so wird die gesamte Transaktion abgebrochen. Wenn jedoch alle Teilnehmer
ihre Bereitschaft zum Fortfahren bestätigt haben, vermerkt der Manager die Absicht der Beendigung der Transaktion sowie eine Liste aller vorbereiteten Teilnehmer in ein entsprechendes Protokoll. Anschließend fordert er alle Teilnehmer zum Commit auf. Sobald die Teilnehmer diese Nachricht erhalten, kopieren sie jeweils ihr Ergebnis vom temporären in den permanenten Speicher und berichten dem Manager über die Beendigung der Operation. Eine
Transaktion wird durch einen Transaktionsmanager gestartet. Dazu ruft ein Client die createMethode vom Transaktionsmanager auf. Über die join-Methode können andere Teilnehmer
an einer Transaktion teilnehmen.

123

Robert Bozic

Abbildung 8: Transaktion - Commit

Die Beteiligten an einer Transaktion sind:
•
•
•

Transaktionsmanager
Transaktionsteilnehmer
Transaktions-Client

Unter Jini ist der Transaktionsmanager ein vollwertiger Jini-Dienst, der das Two-PhaseCommit-Protocol auf Anfrage einfach durchläuft. Für jede Transaktion legt der Transaktionsmanager eine Liste der Teilnehmer an. Er sendet an alle Teilnehmer Nachrichten, in denen
er ihnen mitteilt, welchen Zustand sie einzunehmen haben.
Bei einem Teilnehmer einer Transaktion handelt es sich um ein Programm, das eine Operation durchführt, die gemeinsam mit anderen Operationen im Rahmen einer Transaktion gruppiert wurde.
Der Transaktions-Client ist für das Starten des gesamten Vorgangs zuständig. Dies kann beispielsweise eine Jini-Anwendung sein, die Operationen unter Verwendung mehrere Dienste
durchführt und gewährleisten muss, dass alle gemeinsam verarbeitet werden.
Die allgemeine Vorgehensweise für das Verwenden einer Transaktion ist äußerst einfach.
Zunächst erlangt ein Client eine Referenz auf den Jini-Transaktionsmanager. Dies erfolgt in
der Regel mit Hilfe der herkömmlichen Discovery und Lookup-Prozesse. Anschließend ruft
der Client TransactionFactory auf, um ein neues Transaction-Objekt zu erstellen, welches
vom Transaktionsmanager verarbeitet wird. Nach dem der Client über ein Transaction-Objekt
verfügt, kann er mit dem Gruppieren der an der Transaktion beteiligten Operationen beginnen. Sobald alle beteiligten Operationen gruppiert sind, versucht der Client durch das Aufrufen der Methode commit ( ) des Transaction-Objekts, die Ausführung der Operation zu veranlassen. Bis zu diesem Zeitpunkt hat noch keiner der beteiligten Dienste ihre teilnehmende
Operationen tatsächlich ausgeführt.
Wenn der Aufruf commit ( ) erfolgreich verarbeitet wird, kann der Client sicher davon ausgehen, dass alle beteiligten Operationen erfolgreich ausgeführt wurden.

124

Aufbau von Ad-hoc Netzwerken mit Jini

5 JavaSpaces
Das Ziel von JavaSpaces besteht darin, quasi Dateisysteme für Objekte zur Verfügung zu
stellen. Das heißt, dass JavaSpaces eine allgegenwärtige natürliche Methode zum Speichern
und Verwenden von Objekten bereitstellen kann. Diese Methode soll auf natürliche Weise mit
in Java geschriebenen objektorientierten Anwendungen zusammen arbeiten. Anstelle von
einfachen Daten ohne Typ, werden ganze Objekte gespeichert. So ein Objekt kann ganz gewöhnlich erzeugt werden und anschließend in einem JavaSpace abgelegt werden, der sich auf
einem Server befindet. Ein Client greift über ein Netzwerk auf diesen Server zu und kann
seine Schnittstelle aus der Entfernung nutzen. Damit der Programmierer möglichst wenig mit
dieser Verteilung zu tun hat, wird ein lokales Objekt erzeugt, das den Server vertritt und dem
Client die Schnittstelle lokal anbietet. Um die Objekte im JavaSpace zu integrieren werden
folgende Befehle verwendet: Zum Schreiben write ( ), zum Lesen read ( ) und zum Herausnehmen take ( ).
Beim Schreiben wird die Gültigkeitsdauer eines Eintrags mit angegeben, so dass veraltete
Objekte entfernt werden und das JavaSpace von Altlasten freigehalten wird. Die Gültigkeit
eines Eintrags kann allerdings durch ein Leasing verlängert werden. Als Ergebnis einer
Schreiboperation erhält man ein Lease-Objekt, mit dessen Hilfe sich die Gültigkeit verlängern
lässt.

Abbildung 9: JavaSpaces - Verwaltung von Entry-Objekten

Die Befehle read ( ) und take ( ) liefern jeweils einen Eintrag aus dem JavaSpace zurück an
den Kunden, wobei read ( ) den Eintrag lediglich kopiert und im JiniSpace belässt, während
take ( ) den Eintrag aus dem JiniSpace löscht.
Wenn kein passender Eintrag vorhanden ist, können die Befehle read ( ) und take ( ) den gesamten Ablauf blockieren. Erst wenn ein passender Eintrag erfolgt, kann
der Ablauf fortgesetzt werden. Bei beiden Befehlen kann die Angabe eines Timeouts in Millisekunden die Wartezeit begrenzen.
Um nach einem Eintrag zu suchen, wird diesen Operationen ein Eintrags-Muster mitgegeben.
Dieses Muster, auch Template bezeichnet, ist vom gleichen Typ wie der gesuchte Eintrag.
Das Muster kann auch Platzhalter enthalten, die nicht spezifiziert sind, d.h. sie werden auf
null gesetzt. Diese Platzhalter werden Wildcards genant. Das JavaSpace vergleicht die vorhandenen Einträge feldweise mit dem Template und liefert einen Eintrag zurück, bei dem alle
Felder, die nicht mit einer Wildcard besetzt sind, identisch sind. Dabei können alle Methoden
von JavaSpaces transaktional behandelt werden.

125

Robert Bozic

Abbildung 10: JavaSpaces - Transaktion von Entry-Objekten

Literatur
Arnold, K.:
The Jini Specifications, Second Edition, Addison-Wesley,
Addison-Wesley, (2nd Edition), December 2000
Arnold, K.; O'Sullivan, O.; Scheifler, R.W.; Waldo, J.; Wollrath, A.;
The Jini Specification,
Addison-Wesley, June 1999
Edwards, K.:
Core Jini,
Prentice-Hall, (1st Edition), June 1999
Newmarch, J.:
A Programmer's Guide to Jini Technology,
Apress, November 2000
Oaks, S.; Wong, H.:
Jini in a Nutshell: A Desktop Quick Reference, Deutsche Ausgabe für Jini 1.0 und 1.1,
O'Reilly Verlag GmbH & Co. KG, Köln, 2001

Synchronisation mobiler Daten mit SyncML
Tobias Hoenig

tobiashoenig@gmx.de
Zusammenfassung: SyncML ist eine Beschreibungssprache zur Synchronisation aller
Endgeräte und Anwendungen innerhalb eines Netzwerkes. Sie definiert einen Standard
zur Kommunikation beliebiger Gerätetypen, Daten mobiler Geräte (PDA, Mobiltelefon)
sind in einem Netzwerk verfügbar und umgekehrt. Man erreicht damit einen hohen Grad
an Konsistenz aller denkbarer Daten, die für ein Unternehmen relevant sind.

1 Synchronisationsprozesse
1.1 Einleitung
In modernen Kommunikationssituationen ist es oft notwendig, aktuelle Daten an vielen verschieden Orten gleichzeitig übereinstimmend vorliegen zu haben. So kann ein mobiles Endgerät Anwendungen wie etwa einen Terminkalender, ein Emailprogramm oder eine Datenbank
mit einem Produktangebot ausführen. Änderungen an diesen Daten sollen auch für andere
Nutzer dieser Anwendungen im Zentralsystem eines Unternehmens erkennbar sein. Ebenso
ist es natürlich wünschenswert, dass Daten, die firmenintern einer Änderung unterliegen, auch
auf allen mobilen Geräten, die von diesen Informationen abhängen, aktualisiert werden. Beispielsweise soll die Änderung im Terminkalender eines PDA auch auf den Terminkalender
am Arbeitsplatz wirken, eine unterwegs gelesene Email soll als Gelesen im Netzwerk markiert werden, die Aktualisierung in einer Datenbank (etwa durch den Verkauf eines Produktes) hat Einfluss auf die Lagerhaltung des Unternehmens. Der Wunsch nach hoher Konsistenz
aller relevanten Daten, die von unterschiedlichen Orten auf unterschiedlichen Geräten und
Wegen beeinflusst werden können, führte zur Entwicklung einer Synchronisationsvereinbarung, der Synchronization Markup Language, kurz SyncML. Die Sprache wurde auf Initiative
führender Mobilfunkgeräte- und Computerhersteller entworfen, die Unternehmen bilden ein
Konsortium, dem andere Firmen als Förderer beitreten können. SyncML ist einerseits eine
Sprache, andererseits auch eine Protokollvereinbarung, die durch einen strenges Format einen
ordnungsgemäßen Datenaustausch gewährleistet.
Im folgenden sollen die einzelnen wichtigen Punkte einer Synchronisation erläutert werden.
Dazu wird eine Beispielsynchronisation beschrieben, die zwischen einem Client (z.B. Mobiltelefon) und einem Server stattfindet. Es wird der Fall der Zwei-Wege-Synchronisation behandelt, der immer dann eintritt, wenn sich Daten sowohl auf dem mobilen Endgerät als auch auf
dem Server verändert haben. Es gibt darüber hinaus weitere Synchronisationsprozesse, die in
[SSP00] nachzulesen sind. An dem Beispiel der Zwei-Wege-Synchronisation lassen sich jedoch bereits alle Charakteristika eines typischen Kommunikationsablaufs zwischen Mobilgerät und Server erkennen. Im einzelnen soll beschrieben werden:
• Der Gebrauch von Sync Anchors
• Adressierung
• Beginn der Übertragung: Authentifizierung und Autorisierung
• Initialisierung

128
•

Synchronisation mobiler Daten mit SyncML

Ablauf der Zwei-Wege-Synchronisation
o Client-Modifikationen
o Server-Modifikation

1.2 Grundlagen einer Synchronisierung
Bevor detailliert auf die einzelnen Punkte einer Synchronisation eingegangen wird, zeigt die
nachfolgende Abbildung ein Ablaufschema einer Synchronisation zwischen einer Anwendung
A auf einem Server und der Anwendung B auf einem beliebigen Endgerät (mobil oder stationär). Um im folgenden nicht immer von Anwendung A und Anwendung B sprechen zu
müssen, werden vereinfachend alle Prozesse am Beispiels eines Servers und eines Clients erläutert.

Abbildung 1: Komponenten eines Synchronisationsprozesses

Dabei stellt App A einen Serverprozess dar, der über ein Synchronisationsprogramm mit der
Synchronisationsschnittstelle verbunden ist. Dieses SyncML-Interface überträgt die erforderlichen Daten mittels üblicher Protokolle zur SyncML-Schnittstelle des Clients, der ebenfalls über ein Synchronisationsprogramm verfügt. Der Sync Client Agent leitet einen Synchronisationsvorgang ein und verwaltet die Übertragungsvorgänge auf Clientseite. Auf der Gegenseite des Clients wartet der Sync Server Agent auf eine Synchronisationsanforderung. Die
Sync Engine ist dabei verantwortlich, eine Analyse vorzunehmen, welche Daten verändert
werden müssen. Dazu öffnet und modifiziert sie Datenbanken, reagiert auf Veränderungen im
Terminkalender oder aktualisiert die Ordner des Emailprogramms.
Die nachfolgende Abbildung verdeutlicht die Rollen und Aufgaben der einzelnen Geräte, die
an einer Synchronisation beteiligt sind.

129

Tobias Hoenig

SyncML
Nachricht,
Datenänderung des Client
SyncML
Nachricht,
Datenänderung des Servers

Abbildung 2: Synchronisationsbeispiel mit Mobiltelefon und Server

Die Protokollsprache SyncML ist eine XML-Anwendung, sie besteht also aus Tags, die einen
Synchronisationsablauf strukturieren. Mit Hilfe dieser Tags wird der Synchronisationsablauf
gesteuert, innerhalb dieser Tags werden beispielsweise Angaben zur Identität des Servers und
des Clients vorgenommen oder Datenadressen und Daten übertragen. Die Struktur der
SyncML wird, wie bei XML üblich [See00], in einer Document Type Definition (DTD) festgelegt (vgl. [SRP00]).
1.2.1 Austausch der geänderten Daten
Eine grundlegende Forderung des erarbeiteten Synchronisationsstandards ist die Kenntnis der
Endgeräte über die Datenänderung seit der letzten Synchronisation. Das bedeutet, dass im
Beispielfall sowohl der Server als auch der Client jede Veränderung einer Anwendung zu
registrieren und während einer Synchronisation einander mitzuteilen haben. Diese Veränderungen wären im Falle einer Datenbank etwa ein Update, ein Löschen oder ein Neueintrag.
Es wird allerdings nicht vorgeschrieben, auf welche Weise ein Gerät, das an einer Synchronisation beteiligt ist, diese Änderungen zu speichern hat, es muss lediglich in der Lage sein,
einem anderen Gerät diese Änderungen mitzuteilen.
1.2.2 Der Gebrauch von Sync Anchors
Um die Konsistenz bei einer Synchronisation zu gewährleisten, werden von dem Synchronisationsprotokoll die Sync Anchors verwendet. Es gibt sie in zwei Ausprägungen, Last und
Next. Die Sync Anchors werden zu Beginn einer Synchronisation gesendet, sie geben Aufschluss über die Identität der Datensätze in beiden Geräten. Der Sync Anchor Last enthält den
Zeitpunkt, zu dem die Datenbestände aus der Sicht des den Anchor sendenden Gerätes zuletzt
abgeglichen wurden, der Sync Anchor Next enthält den Zeitpunkt des gegenwärtigen Austausches. Insbesondere muss vom Server der Sync Anchor Next des Client gespeichert werden.
Damit kann der Server entscheiden, wann die letzte Synchronisation stattgefunden hat und ob
die momentane Synchronisation mögliche Änderungen des Datenbestandes beinhaltet. Dazu
wird der Anchor Last des Client mit dem gespeicherten Wert auf dem Server verglichen. Im
Falle einer Datenbankänderung beim Client kann der Last Anchor des Clients auf den Wert
‚Empty' gesetzt werden, der Server vergleicht dann den gespeicherten Next-Wert mit dem
empfangenen Last-Wert und entscheidet im Falle der Ungleichheit auf eine Synchronisation
der Daten. Die Abbildung 3 zeigt die Verwendung der Sync Anchor.
In diesem Beispiel synchronisieren sich ein Client und ein Server zweimal. Zum ersten Synchronisationszeitpunkt am 10.10.2001 stimmen der gespeicherte Sync Anchor beim Server
mit dem Sync Anchor Last des Client überein, die Datenbestände sind konsistent. Der Sync
Anchor Next wird daraufhin beim Server als letzter Synchronisationszeitpunkt gespeichert.
Zwischen der ersten und der zweiten Synchronisation wird der persistente Speicher des Client
gelöscht und zur Kennzeichnung dieser Änderung der Sync Anchor Last auf den Wert
‚Empty' gesetzt. In der zweiten Synchronisationssitzung am 11.11.2001 passen somit der

130

Synchronisation mobiler Daten mit SyncML

gespeicherte Sync Anchor beim Server (der den Wert der letzten Synchronisation am
10.10.2001 hat) und der Sync Anchor Last beim Client nicht überein, ein vollständiger
Datenabgleich ist die Folge.
Falls sich nur einzelne Daten geändert haben, muss nicht jedesmal eine vollständige
Korrektheit überprüft werden: Es existieren neben diesen generellen Sync Anchors auch Sync
Anchors für Datensätze. Im Falle einer erzwungenen Synchronisation kann daher im nächsten
Schritt geprüft werden, welche Datensätze einer Änderung unterliegen und aktualisiert
werden müssen.

SyncML Client

SyncML Server

Synchronisation 1
Last(2001090909T090909Z), Next(2001101010T101010Z)

Gespeicherter
Sync Anchor:

OK
Ende der Synchronisation 1

Der persistente Speicher des Mobiltelefons wird gelöscht
Synchronisation 2

Last(‚Empty'), Next(2001111111T111111Z)
Synchronisation erforderlich

Gespeicherter
Sync Anchor:
10:10:10 AM,
10/10/2001

Abbildung 3: Beispiel für den Gebrauch von Sync Anchors

Dazu werden auf Seiten des Clients und des Servers Schlüsselzahlen für jeden Datensatz
vergeben, die veränderten Werte werden durch die Angabe dieser Schlüsselzahl dem Synchronisationspartner kenntlich gemacht [SSP00].
1.2.3 Aufbau einer Synchronisationsnachricht
Bevor im weiteren Verlauf detaillierter auf die Protokollbestandteile eingegangen wird, soll in
diesem Abschnitt der äußere Rahmen einer Synchronisationsnachricht beschrieben werden.
Betrachtet man die ausgetauschten Nachrichten, so erinnern sie in ihrem Aufbau an die Syntax einer HTML-Seite. Es gibt eine strikte Trennung in einen Header (eingeleitet durch den
Tag <SyncHdr>), der allgemeine Informationen zur verwendeten Protokollversion, zur
Client- und Serveradresse und zur Authentifizierung enthält. Auf diese Informationen folgen
im Datenkörper eines Nachrichtenpakets (markiert durch <SyncBody>) Angaben über die zu
synchronisierenden Daten. Innerhalb dieser einzelnen Gliederungs-Tags werden weitere Tags
verwendet, welche die jeweilige Funktion der übermittelten Zeichenfolge markieren. Insgesamt ergibt sich folgendes Gerüst für eine SyncML-Nachricht:

131

Tobias Hoenig

<SyncML>
<SyncHdr>
<!--Hier stehen Informationen über die Client- und Serveradresse, sowie Informationen zur Protokollversion und
Authentifizierung -->
</SyncHdr>
<SyncBody>
<!--Hier stehen Informationen zu den veränderten Datensätzen beim Client und Server -->
</SyncBody>
</SyncML>
Abbildung 4: Gerüst einer SyncML-Nachricht

1.2.4 Adressierung
Um die Teilnehmer einer Synchronisation anzusprechen, wird innerhalb des <SyncHdr>-Tags
ein definiertes URI-Schema des Gerätes angegeben [SRP00]. Geräte, die permanent mit dem
Internet verbunden sind, können über die bekannte URI adressiert werden, ebenso ist es
denkbar, dass von einigen Geräten (z.B. Mobiltelefonen) eigene Identifikationskennzeichnungen benutzt werden (IMEI = International Mobile Equipment Identity). Dabei ist zu beachten, dass bei einem späteren Transport etwa über dass HTTP die dort verwendeten Adressen der Endgeräte nicht mit den eigenen Adressen übereinstimmen müssen. Grundsätzlich
wird zwischen einer Quell- und einer Zieladresse unterschieden, je nachdem, welches Gerät
Informationen sendet und empfängt.
<SyncML>
<SyncHdr>
<Target><LocURI>IMEI:493005100592800</LocURI></Target>
<Source><LocURI>http://www.serverstandort.com/sync-dateien</LocURI></Source>
</SyncHdr>
<SyncBody>
<!--Hier stehen Informationen zu den veränderten Datensätzen beim Client und Server -->
</SyncBody>
</SyncML>
Abbildung 5: Adressierung zweier Synchronisationspartner

Die Abbildung 5 zeigt einen Ausschnitt eines Datenpaketes, das von einem Server an ein Mobiltelefon gesendet werden soll. Das Mobiltelefon nutzt dabei eine eigenständige Adressenstruktur.
Um eine Datenbank bei einem Synchronisationspartner anzusprechen, wird zunächst durch
einen <Sync>-Tag deutlich gemacht, dass diese Datenbank synchronisiert werden soll, anschließend wird die relative oder absolute Adresse dieser Datenbank im <SyncBody>-Bereich

132

Synchronisation mobiler Daten mit SyncML

angegeben. Ist diese Datenbank dann bekannt, können einzelne Datenbankeinträge über das
<Item>-Tag angesprochen werden. Folgende Abbildung verdeutlicht diese Möglichkeit,
wobei eine Server Datenbank angesprochen wird:
<SyncML>
<SyncHdr>
<Target><LocURI>http://www.serverstandort.com/syncdateien</LocURI></Target>
<Source><LocURI>IMEI:493005100592800</LocURI></Source>

</SyncHdr>
<SyncBody>
<Sync>
<Target><LocURI>./kalender/Donald_Duck</LocURI></Target>
<!-- Anweisungen zum Hinzufügen oder Verändern -->
<Item>
<Target>
<LocURI>100</LocURI>
</Target>
</Item>
</Sync>
</SyncBody>
</SyncML>
Abbildung 6: Änderung des 100. Eintrages einer Datenbank

Um auf die Datensätze gezielt zugreifen zu können, hat der Server ein Abbild der Clientdatenbank gespeichert, um jederzeit Werte des Clients verändern zu können. Dabei kann der
Server auch eine eigene Speicherstruktur der Clientdaten verwenden, es muss lediglich eine
Zuordnungstabelle existieren.
1.2.5 Authentifizierung
Um eine sichere Datenübertragung zu gewährleisten, kann eine Authentifizierung beider Synchronisationspartner gefordert werden. Die Authentifizierung kann durch das Versenden digitaler Signaturen gewährleistet sein, die aufgrund von Verschlüsselungsalgorithmen vor dem
Zugriff Dritter geschützt sind. Eine Authentifizierung kann sowohl vom Server als auch vom
Client angefordert werden, mittels des <Chal>-Tags wird die Forderung gestellt. Über das
<Cred>-Tag sendet dann der zur Authentifizierung aufgeforderte Synchronisationspartner das
beispielsweise 64-Bit-verschlüsselte Passwort samt Nutzerkennung. Im folgenden Beispiel
fordert der Server von einem Mobiltelefon eine Authentifizierung, die das Mobiltelefon liefert. Anschließend steht der Server zur Synchronisierung zur Verfügung.
•

Auforderung zur Authentifizierung
<SyncML>
<SyncHdr>
<Target><LocURI>IMEI:493005100592800</LocURI></Target>

133

Tobias Hoenig
<Source><LocURI>http://www.serverstandort.com/syncdateien</LocURI></Source>
</SyncHdr>
<SyncBody>
...
<Chal>
<Meta>
<Type xmlns='syncml:metinf'>syncml:auth-basic</Type>
<Format xmlns='syncml:metinf'>b64</Format>
</Meta>
</Chal>
...
</SyncBody>
</SyncML>

•

Authentifizierung des Mobiltelefons
<SyncML>
<SyncHdr>
<Target><LocURI>http://www.serverstandort.com/syncdateien </LocURI></Target>
<Source><LocURI>IMEI:493005100592800</LocURI></Source>
<Cred>
<Meta>
<Type xmlns='syncml:metinf'>syncml:auth-basic</Type>
</Meta>
<Data>QnJ1Y2UyOk9oQmVoXYZ1</Data>
</Cred>
</SyncHdr>
<SyncBody>
...
</SyncBody>
</SyncML>

Innerhalb des <Meta>-Tags wird der Sicherheitsstandard definiert, mit dem sich der Client
beim Server identifizieren muss. Eine Authentifizierung eines Synchronisationsteilnehmers
geschieht grundsätzlich innerhalb des <SyncHdr>-Abschnitts eines Datenpaketes. Andere als
die hier erwähnte 64-Bit-Verschlüsselung sind möglich, erwähnt wird in der Spezifikation die
Verschlüsselung MD5 (message digest 5, ein spezieller Codierungsalgorithmus).
1.2.6 Initialisierung der Synchronisation
Eine Initialisierung bildet den Beginn einer Synchronisation. Sie gewährleistet, dass die Synchronisationsbefehle übertragen und von beiden Geräten verstanden werden können. Generell
werden drei Punkte innerhalb der Initialisierung abgearbeitet:

134
•
•
•

Synchronisation mobiler Daten mit SyncML
Identifizierung von Client und Server
Vereinbarung der zu synchronisierenden Datenbanken, Version des verwendeten Protokolls
Austausch der Gerätekapazität

Der letzte Punkt ist bislang nicht detailliert besprochen worden, es handelt sich im wesentlichen um die Klärung, wie groß die zur Verfügung stehenden Systemressourcen sind, um zu
vermeiden, dass es bei der Übertragung durch eine zu große Datenmenge zu Speicherproblemen kommt.
Da es sich bei SyncML um XML handelt, ist nicht nur eine Protokollversion, sondern auch
die Angabe der benutzten DTD obligatorisch. Zwischen dem Server und dem Client wird für
jede Synchronisation eine Session-ID vereinbart, ebenso eine Message-ID. Anhand beider
Identifikationsnummern ist es möglich, Datenpakete zuzuordnen und im Falle zu großer Datenmengen die Daten auf mehrere Pakete aufzuteilen. In der Initialisierung finden auch die
Sync Anchors ihren Platz, es wird dann vom Server entschieden, welche Synchronisationsart
erforderlich ist. Außerdem ist es für den Client und den Server möglich, durch einen <Alert>Tag den Synchronisationspartner darauf hinzuweisen, welche Datensätze abgeglichen werden
müssen.

2 Synchronisationstypen
2.1 Übersicht
Die SyncML-Spezifikation definiert sieben verschiedene Synchronisationsarten. Die Tabelle
gibt neben deren Nennung eine kurze Beschreibung. Um eine künstlich wirkende Übersetzung zu vermeiden, wurden die in [SSP00] eingeführten Bezeichnungen des Synchronisationstyps beibehalten.
Synchronisationstyp

Beschreibung

Two-way Sync

Gewöhnlicher Synchronisationstyp, Client und
Server tauschen veränderte Daten aus.
Alle Datensätze werden miteinander verglichen,
der Client sendet seine Datenbestände, der Server
aktualisiert sie und sendet sie zurück.
Nur der Client sendet die Datenänderungen.
Der Client sendet alle Daten einer Datenbank, die
entsprechende Datenbank auf dem Server wird
vollständig aktualisiert.
Der Client erhält aktuelle Datenänderungen vom
Server, sendet aber nicht.
Der Server sendet alle Daten einer Datenbank, die
entsprechende Datenbank auf dem Client wird
vollständig aktualisiert.
Der Server signalisiert dem Client, dass ein Synchronisationswunsch vorliegt. Normalerweise
geht eine Synchronisation vom Client aus.

Slow sync

One-way sync from client only
Refresh sync from client only

One-way sync from server only
Refresh sync from server only

Server Alerted Sync

Abbildung 7: Übersicht der Synchronisationstypen

Wie die Tabelle zeigt, unterscheiden sich die einzelnen Synchronisationstypen lediglich in der
Art der gesendeten Daten oder in der Aktionsform der Synchronisationsteilnehmer. Um einen

135

Tobias Hoenig

Überblick über den typischen Synchronisationsablauf zwischen Client und Server zu geben,
wird im folgenden der häufigste Synchronisationstyp beschrieben, die Two-way Sync.

2.2 Beispiel: Two-way Sync
Die Two-way Sync ist die übliche Synchronisationsform, bei der Client und Server Informationen über veränderte Daten austauschen. Dabei sendet der Client immer zuerst seine Änderungen an den Server, darauf nimmt der Server den Abgleich mit seinem Datenbestand vor
und sendet die erfolgreichen Veränderungen an den Client zurück.
Das folgende Diagramm verdeutlicht den Ablauf einer Two-way Sync.
Anwender

SyncML Client

SyncML Server

Client und Server initialisieren die Two-way Sync

Client bereitet zu sendende Daten vor

Sync-Daten vom Client zum Server

Server analysiert erhaltene Daten und vergleicht die Datenbestände
Status und Sync-Daten

Client aktualisiert die Datenbestände
Datenänderungsstatus zum Server

Sync-Ergebnis

Speicherbestätigung zum Client

Abbildung 8: Verlaufsdiagramm eines Two-way Sync

Die Pfeile in dieser Darstellung repräsentieren SyncML-Pakete, die eine oder mehrere Botschaften enthalten können. Alle SyncML-Daten haben dieselbe Session-ID, die in der Initialisierung vereinbart worden ist.
Die nachfolgenden Abschnitte präzisieren die einzelnen Schritte einer Two-way Sync.
2.2.1 Sync-Daten vom Client zum Server
Um eine Synchronisation zu beginnen, muss der Client den Server über alle Datenänderungen
informieren, die seit der letzten Synchronisation innerhalb der Client-Datenbank aufgetreten
sind. Alle in der Initialisierung zwischen dem Server und dem Client getroffenen Vereinbarungen hinsichtlich der Synchronisierungsphase finden sich hier im <SyncHdr>-Abschnitt
wieder. Darüber hinaus werden jetzt im <SyncBody>-Abschnitt die genauen Datensätze angegeben, die einer Änderung seit der letzten Synchronisierung unterlagen. Ein Datenpaket, das
der Spezifikation entspricht, findet sich als Beispiel in [SSP00], S. 35.

136

Synchronisation mobiler Daten mit SyncML

2.2.2 Status und Sync-Daten vom Server zum Client
Die in diesem Teil der Synchronisation gesendeten Daten erfüllen zwei Aufgaben: Einerseits
wird der Client darüber informiert, welche Ergebnisse die Synchronisationsanalyse auf dem
Server ergeben hat, zum anderen werden dem Client nun die Daten mitgeteilt, die sich auf
dem Server seit der letzten gemeinsamen Synchronisation geändert haben.
2.2.3 Datenänderungsstatus vom Client zum Server
Dieses Datenpaket wird gesendet, um dem Server mitzuteilen, welche Änderungen auf dem
Client vollzogen worden sind. Ebenfalls werden veränderte oder neue Schlüsselwerte für die
Datensätze in der Clientdatenbank mitgeteilt, die serverseitig gespeichert werden müssen.
Jede einzelne geänderte Datenbank wird dabei gesondert erwähnt.
2.2.4 Speicherbestätigung vom Server zum Client
Die Speicherbestätigung vom Server zum Client wird gesendet, um mitzuteilen, dass der Datenänderungsstatus auf dem Server gespeichert worden ist. Der Server verfügt nun wieder
über ein konsistentes Abbild der Clientdatenbank mit allen neuen bzw. veränderten Einträgen.
Die Speicherbestätigung entfällt, falls keine neuen Einträge in der Clientdatenbank vorgenommen worden ist.
Auf die detaillierte Darstellung der einzelnen Synchronisationspakete wird an dieser Stelle
nicht näher eingegangen, da nicht alle in ihnen verwendete Tags dargestellt werden können.
Eine genauere Ausführung des obigen Beispiels findet sich in [SSP00], S.33 ff.

2.3 Weitere Synchronisationstypen
Das Diagramm aus der Abbildung 7 zeigt exemplarisch den protokollarischen Ablauf einer
Two-way Sync. Die Tabelle aus Abschnitt 2.1 nennt weitere Synchronisationstypen. Auch ihr
Ablauf lässt sich jeweils in einem Schaubild darstellen, in der Darstellung finden sich charakteristische Punkte wieder:
Zu Beginn findet eine Initialisierung beider Synchronisationspartner statt, in Abhängigkeit
vom Synchronisationstyp bereitet einer der Synchronisationspartner dann die anzupassenden
Daten vor. Es werden Sync-Pakete von einem zum anderen Gerät gesendet und dort verarbeitet. Je nach Typ findet eine Rücksendung statt oder es wird lediglich eine Empfangsbestätigung geschickt, die den Absender darüber informiert, ob seine Datenänderungen konsistent
in die Datenbank des Empfängers übernommen werden konnten. Am Ende jeder Synchronisation wird der Anwender des (meist mobilen) Datenverarbeitungsgerätes über den Ablauf
der Synchronisation benachrichtigt.

Referenzen
[See00]

Seeborger-Weichselbaum, M. (2000):
XML - Das Einsteigerseminar, Kaarst, 2000.

[SSP00]

Ericsson et al. (Hrsg.) (2000):
SyncML Sync Protocol, Version 1.0, 2000.

[SRP00]

Ericsson et al. (Hrsg.) (2000):
SyncML Representation Protocol, Version 1.0, 2000.

Übertragung von Objekten mit OBEX
Johannes Magauer

johannes.magauer@yline.com
Zusammenfassung: Das Object Exchange Protocol, im folgenden kurz OBEX genannt,
ist ein sehr kompaktes und effizientes Datenübertragungsprotokoll (ähnlich HTTP). Es
unterstützt den Austausch von Daten in unterschiedlichen Formaten zwischen verschiedensten Geräten. Dazu können Infrarotverbindungen, aber auch andere her-kömmliche
Verbindungen eingerichtet werden. Um dies zu realisieren, bietet OBEX ein Objekt Modell sowie ein Session Modell an. Ein weiterer Vorteil von OBEX ist, dass eine typische
Implementierung für ein embedded System nur ca. 1 kByte Code benötigt [IrDA]. Dabei
umfasst dieser Standard das Session Modell für den Austausch der Daten, PUT und GET
Operationen, sowie das Objekt Modell für die Beschreibung der Objekte. Mit der Möglichkeit zur Erweiterung des Funktionsumfangs durch die Definition neuer Objekttypen
und neuer Session-Operationen lässt sich OBEX daher sehr universell einsetzen.

1 Das Objekt Modell
Das Objekt Modell ermöglicht die Darstellung von Objekten durch mehrere Header. Einen
Header kann man sich als ein Datenpaket vorstellen, der die wesentlichen Eigenschaften eines
Objekts, wie zum Beispiel den Namen, die Länge, eine Beschreibung des Objektes bzw. das
Objekt selbst darstellt. Weiters besteht ein Header im allgemeinen aus folgenden 2 Teilen:
• einem Headeridentifikator: dieser ist ein nicht vorzeichenbehafteter Ein-Byte Wert;
An diesem Identifikator lässt sich der Header identifizieren. Unerkannte Header werden vom Empfänger ignoriert und überlesen.
• einem Headerwert: dieser besteht aus einem bzw. mehreren Bytes;
die Bedeutung wird durch den Headeridentifikator festgelegt.
Die 6 niederwertigen Bits des Headeridentifikators beschreiben die Bedeutung des Headers,
die 2 höherwertigen Bits geben die Kodierung des Identifikators an. Dabei haben die Bits 8
und 7 folgende Bedeutung:
Bits 8 und 7 des HI
00 (0x0.)
01 (0x4.)
10 (0x8.)
11 (0xC.)

Bedeutung:
Null terminierter Unicode; Länge wird durch die ersten 2 Bytes angegeben
Zeichenkette; Länge wird durch die ersten 2 Bytes angegeben
Länge des Headerwerts: 1 Byte
Länge des Headerwerts: 4 Byte

Manche Header wurden zur mehrmaligen Übertragung entworfen (z. B.: Body). Bei anderen
wiederum ergibt es keinen Sinn, wenn diese öfters mitübertragen werden (z. B.: Name, Time).

138

Übertragung von Objekten mit OBEX

1.1 Beschreibung der Header und Angabe der Headeridentifikatoren (HI)
1.1.1 Count
Der Header 'Count' gibt die Anzahl der an einer Operation beteiligten Objekte an.

HI 0xC0

1.1.2 Name
HI 0x01
Der Header 'Name' ist ein optionaler Parameter. Wird dieser Header nicht übertragen, so muss
der Empfänger wissen, wie er die Daten ohne Namensheader bearbeiten soll. Dies kann z. B.
anhand eines Headers 'Type' bestimmt werden. Wird das Objekt an PCs, PDAs oder ähnliche
Geräte gesendet, so wird der Namensheader normalerweise als Filename interpretiert (Ausnahme: Verwendung von Name-Header mit den Operationen PUT und SETPATH). Ein Empfänger, der diesen Header als Filename deutet, muss einen Namen, der nicht seiner eigenen
Namenskonvention entspricht, verarbeiten können.
1.1.3 Type
HI 0x42
Der Header Type beschreibt den MIME-Typ des Objekts (z. B.: text, binary, vCard...). Dieser
Header entspricht dem 'content-type'-Header im HTTP. Wird ein im HTTP registrierter Typ
benutzt, müssen die entsprechenden Regeln des HTTP-Protokolls verwendet werden. Wird
kein Typ spezifiziert, so wird dieser als 'binary' angenommen. Zusätzlich ist dann der Empfänger über die weitere Behandlung des empfangenen Objekts zuständig. Dieser identifiziert
nun anhand weiterer Header (z. B.: Name, Context,...) die Verwendung des Objekts.
1.1.4 Length
HI 0xC3
Der Header 'Length' besteht, wie man anhand des Headeridentifikators sehen kann, aus 4
Bytes und gibt die Anzahl der Bytes des Objektes an. Steht schon zu Beginn die Länge des
Objektes fest, so soll diese im Header angegeben werden, da dadurch eine optimaleres
Handling erreicht wird. Übersteigt die Länge eines Objekts 4 Gigabyte - 1, so soll der HTTPHeader 'content-length' benutzt werden, da dieser durch ASCII-Codierung beliebig große
Längenangaben unterstützt.
1.1.5 Time
HI 0x44
Der Header 'Time' kann optional angegeben werden. In diesem wird wenn möglich die UTC -
Zeit in folgendem Format angegeben: YYYYMMDDTHHMMSSZ. Hierbei trennt der Buchstabe T das Datum von der Zeit. Der Buchstabe Z am Ende der Zeichenkette ist ein Hinweis
auf das UTC-Format. Ist die UTC Zeit nicht vorhanden, so kann auch die lokale Zeit in folgendem Format angegeben werden: YYYYMMDDTHHMMSS. Hier fehlt natürlich der
Buchstabe Z am Ende der Zeichenkette.
In einer älteren schon verabschiedeten Version wurde die Zeit in einem Vier-Byte IntegerWert angegeben. Dieser enthielt die Anzahl der seit 01.01.1970 verstrichenen Sekunden. Aus
Kompatibilitätsgründen wird dieser Header (mit Headeridentifikator 0xC4) ebenfalls noch
unterstützt.
1.1.6 Description
HI 0x05
Der Header 'Description' ist ein nullterminierter Unicode um Objekte und Operationen beschreiben zu können. Dieser Header kann optional angewendet werden. Im Header
'Description' können auch Informationen über den Verbindungsstatus übermittelt werden.
1.1.7 Target
HI 0x46
Der Header 'Target' ist eine 128 Bit-Zeichenfolge. Dieser dient zur Identifikation der Zieladresse, an die die Operation bzw. das Objekt gesendet werden soll. Falls dieser Header ver-

139

Johannes Magauer

wendet wird, so muss er der erste Header der ihn beinhaltenden Operation sein. Weiters ist zu
beachten, dass dieser Wert Case-sensitive ist.
1.1.8 HTTP
HI 0x47
HTTP ist eine optionale Zeichenfolge, die einen HTTP 1.x Header beinhaltet. Dadurch müssen Funktionen die schon im HTTP-Standard vorkommen nicht nochmals erfunden werden.
1.1.9 Body
HI 0x48
Der Header 'Body' besteht aus einer Längenangabe (2 Byte) und dem Objekt bzw. Teilen des
Objekts; d. h. dass ein Objekt auch auf mehrere Body-Header aufgeteilt werden kann.
1.1.10 End of Body
HI 0x49
Dieser Header wird verwendet, wenn die Länge eines Objekts im vorhinein noch nicht gegeben ist. Dabei wird das Ende dieses Objekts mit dem 'End of Body' Header abgeschlossen.
1.1.11 Who
HI 0x4A
Der Header 'Who' wird normalerweise in einer Connect-Operation vom Empfänger zur Identifikation zurückgegeben. Er entspricht also dem Gegenstück des Header 'Target' und besteht
wie dieser aus einer 128 Bit-Zeichenfolge.
1.1.12 Connection Id
HI 0xCB
Falls dieser Header verwendet wird, so muss er der erster Header eines Requests sein. Dabei
bezeichnet dieser Header die Verbindung, über die der weitere Datenaustausch erfolgt. Will
man mehreren Clienten einen gleichzeitigen Zugriff auf einen OBEX-Dienst über eine
TinyTP [Latuske] Verbindung zur Verfügung stellen, so hilft die 'Connection Id' die verschiedenen Clients zu unterscheiden. Dies ist insbesondere bei Diensten des OBEX-Servers der
Fall. Wird in einem CONNECT Request-Paket ein Target-Header verwendet, so wird vom
Server im CONNECT Responsepaket eine 'Connection Id' an den Client zurückgegeben.
Wurde eine OBEX-Verbindung aufgebaut, so müssen alle weiteren Requests diese
'Connection Id' beinhalten. Dabei muss die 'Connection Id' nur im ersten Paket eines Requests
vorhanden sein. Daraus folgt, dass zu jeder Zeit nur ein einziger Request von jedem Client
gestellt werden kann.
Wird eine ungültige 'Connection Id' empfangen, so wird die auszuführende Operation durch
die Meldung 'Service Unavailable' (0xD3) abgebrochen. Da nicht jeder Server diese Meldung
unterstützt, kann die Ungültigkeit der 'Connection Id' zusätzlich durch den Wert 0xFFFFFFFF
angezeigt werden.
Weiters ist zu beachten, dass ein 'Connection Id'-Header nicht in einer CONNECT-Operation
verwendet werden darf. Außerdem darf auch eine 'Connection Id' und ein Target-Header nicht
in ein und derselben Operation verwendet werden.
1.1.13 Application Request/Response Parameters
HI 0x4C
Dieser Header wird zur zusätzlichen Übertragung von Informationen über ein Request oder
Response-Paket verwendet. Um die verschiedenen Typen der Request/Response Parameter
übertragen zu können, werden Zeichenketten in folgendem Format benutzt:
Parameter Tripel 1 Parameter Tripel 2
Parameter Tripel ...
Tag 1 Länge Wert Tag 2 Länge Wert Tag... Länge... Wert...

Die Felder Tag und Länge sind jeweils 1 Byte lang. Der Wertebereich kann bis zu 255 Bytes
lang sein. Die maximale Länge ist durch die obere Grenze eines OBEX-Headers gegeben.

140

Übertragung von Objekten mit OBEX

1.1.14 Authenticate Challenge und Authenticate Response
HI 0x4D; 0x4E
Die Header 'Authenticate Challenge' (HI 0x4D) und 'Authenticate Response' (HI 0x4E) werden benutzt, um sich als Client bzw. als Server authentifizieren zu können. Die verschiedenen
Werte zur Authentifizierung werden wie bei den Application Parameters durch
Tag/Länge/Wert-Tripel übertragen.
1.1.15 Object Class
HI 0x4F
Mit diesem Header kann man auf Objektklassen und deren Eigenschaften verweisen. Im Prinzip verhält sich der Header 'Object Class' wie der Header Type; der Namensraum entspricht
aber den Regeln von OBEX und nicht von MIME. Es ist aber zu beachten, dass die referenzierten Objektklassen, nur in den Anwendungen erkannt werden, in denen diese Objekte definiert sind.
1.1.16 User Defined Headers
HI 0x30 - 0x3F
Durch solche Header wird einem Entwickler vollständige Flexibilität gegeben. Anhand der HI
werden diese Header problemlos erkannt. Dabei müssen diese benutzerdefinierten Header mit
besonderer Sorgfalt behandelt werden, da sie ja von mehreren Benutzern mit unterschiedlicher Semantik definiert werden können. Zur eindeutigen Identifikation trägt hier der WhoHeader bei.

2 Das Session Protokoll
Das Session Protokoll dient zur Beschreibung einer OBEX-Übertragung. Dieses Protokoll
bietet ein Übertragungsformat zwischen Geräten sowie spezielle Operationen für bestimmte
Vorgänge an. Eine solche Übertragung wird mittels einer Verbindung durchgeführt, die dabei
auf ein Client/Server - Request-Response Paradigma aufsetzt.

2.1 Request-Format
Ein Request besteht aus einem bzw. mehreren Paketen, wobei ein Paket aus einem Byte Operationscode, zwei Bytes Paketlänge und weiteren von der Operation abhängigen Headern
bzw. Daten besteht. Jedes Request-Paket muss mit einem Response-Paket beantwortet werden. Wird das höchste Bit des Operationscodes (Final-Bit) gesetzt, so ist dieses Paket das
letzte Paket des Requests. Werden mehrere Response-Pakete benötigt, um ein Request zu beantworten, so wird vom Server im Response-Paket ein 'Continue'-Code an den Client gesendet. Will nun der Client auch die nächsten Pakete erhalten, so muss er wiederum ein RequestPaket mit gleichem OP-Code, gesetztem Final-Bit, jedoch ohne zusätzliche Header an den
Server senden. Soll die Übertragung beendet werden, so wird ein 'ABORT'-Paket' gesendet.

2.2 Response-Format
Ein Response ist wie ein Request aufgebaut. Hier fordert jedoch ein gesetztes Final-Bit den
Clienten auf, ein neues Paket zu senden. Erhält ein Server einen unbekannten Opcode so antwortet dieser mit Response-Code 0xD1 (Not Implemented, gesetztes Final-Bit) und ignoriert
diese Operation. Die am häufigsten benutzten Response-Codes sind: 0x90 (Continue) und
0xA0 (Success).

2.3 Definition der OBEX Operationen und Opcodes
2.3.1 Operation 'Connect'
Opcode 0x80
Mit dieser Operation wird eine Verbindung initiiert. Die Operation 'Connect' muss im Request
sowie in einem Response in ein einziges Paket passen. Dabei setzen sich die Pakete auf folgende Art zusammen:

141

Anfragepaket:
(Request)

Antwortpaket:
(Response)

Johannes Magauer

Byte 0 Bytes 1 und 2
0x80

Byte 0
Responsecode

Byte 3

Byte 4 Bytes 5 und 6 Byte 7 bis n

Connect

OBEX

Paketlänge

Versionsnummer

Flag

Bytes 1 und 2

Byte 3

Connect-Response

OBEX

Paketlänge

Versionsnummer

maximale

optionale

Paketlänge

Header

Byte 4 Bytes 5 und 6 Byte 7 bis n
Flag

maximale

optionale

Paketlänge

Header

Durch Byte 3 wird die OBEX Protokoll Versionsnummer angegeben. Dabei bezeichnen Bit 0
- Bit 3 die Nebenversion und Bit 4 - Bit 7 die Hauptversionsnummer. Die derzeitige Protokoll Version ist 1.0.
Beim Flag-Byte darf nur Bit 0 gesetzt werden, alle anderen Bits müssen auf 0 gesetzt sein. In
einem CONNECT-Response Paket wird durch Bit 0 des Flag-Bytes angezeigt, ob der OBEX
Server fähig ist, mehrere gemultiplexte Verbindungen herstellen zu können. Dies kann zum
Beispiel mit IrLMP (IrDA Link Management Protocol) und LSAP (Logical Service Access
Point) realisiert werden [Latuske]. Ist dieses Bit 0, so muss der Client alle Operationen linear
über eine TTP (Tiny Transport Protocol) Verbindung übertragen, ansonsten kann der Client
mehrere TTP Verbindungen zum Server aufbauen und gleichzeitig Objekte übertragen.
Die maximale Paketlänge muss einen Wert ≥ 28 Bytes und ≤ 216 Bytes besitzen. Wurde einmal eine maximale Paketlänge vereinbart, so bedeutet dies nicht, dass alle Pakete diese Länge
besitzen müssen. Weiters dürfen auch der Client und Server verschiedene maximale Längen
besitzen. Als optionale Header können die unter Punkt 1 beschriebenen verwendet werden.
Will man eine spezielle Applikation ansprechen, muss ein Target-Header in einem
CONNECT Request-Paket abgesendet werden. Im Target-Header wird die gewünschte UUID
angegeben. Weiters muss der Who-Header angegeben werden, wenn diese Applikation von
mehreren Clients aufgerufen werden kann.
In einem Response auf ein CONNECT Request-Paket muss der Who-Header mit der UUID
des Target-Headers aus dem gestellten Request übereinstimmen. War der Who-Header in
einem Request vorhanden, so wird er im Response-Paket als Target-Header gesendet. Außerdem muss eine eindeutige Verbindungs- ID in einem angehängten 'Connection ID'-Header
übertragen werden. Diese ID wird dann in allen späteren Operationen verwendet.
Wird von einer Applikation der Target-Header nicht angenommen, da dieses Gerät zum Beispiel abgeschaltet ist, so wird die Verbindung mit dem dazugehörigen Inbox-Service hergestellt. Dies ist ein Ordner auf dem Server, in dem Daten für Anwendungen bis auf Abruf hinterlegt werden können. In einem solchen Fall muss der Client entscheiden, ob er die Verbindung aufrecht erhalten, bzw. trennen will.
Als Response auf einen ordnungsgemäßen CONNECT-Request wird der Code 0xA0
(Success) zurückgegeben. Jeder andere Responsecode zeigt einen Verbindungsfehler an. Das
standardmäßige Format wird aber auch im Fehlerfall eingehalten. Dadurch kann ein optionaler Header angehängt werden, der eine Beschreibung dieses Fehlerfalles beinhaltet.
2.3.2 Operation 'Disconnect'
Opcode 0x81
Dieser Operationscode kennzeichnet das Ende einer Verbindung. An den Befehl Disconnect
kann auch hier ein Description-Header angehängt werden. Der Befehl Disconnect muss sowohl in einem Request als auch in einem Response jeweils in ein Paket passen. Das Finalbit

142

Übertragung von Objekten mit OBEX

ist dabei immer gesetzt. Der standardmäßige Responsecode dieser Operation ist 0xA0
(Success). Wurde jedoch in einem Request z. B. eine ungültige 'Connection ID' mitgegeben,
so lautet der Returncode 0xD3 (Service unable). Obwohl die Verbindungstrennung mit
'Disconnect' wünschenswert ist, kann die Trennung einer Verbindung auch ohne diese Operation durchgeführt werden.
2.3.3 Operation 'Put'
Opcode 0x02
Die Operation 'Put' sendet ein Objekt vom Clienten zum Server. Dabei kann ein Put-Request
normalerweise aus mehreren Paketen bestehen. Grundsätzlich wird das Vorhandensein der
Header 'Name' und 'Length' vorausgesetzt. Zusätzliche Header, wie die unter Punkt 1 beschriebenen, können natürlich auch benutzt werden. Im letzten Paket muss wieder das FinalBit gesetzt werden. Typische Werte des Responsecodes sind 0x90 (Continue) und 0xA0
(Success). Antworten auf einen Put-Befehl dürfen nur aus einem Paket bestehen, wobei zusätzlich das Final-Bit gesetzt werden muss.
2.3.4 Operation 'Get'
Opcode 0x03
Mit 'Get' will man ein Objekt vom Empfänger erhalten. Ein Name-Header kann weggelassen
werden, wenn der Empfänger normalerweise nur einen Objekttypen kennt (z. B. System-informationen). Arbeitet der Empfänger aber mit mehreren Objekten, so wird in diesem Fall
empfohlen, als Responsecode 0x90 (Continue) bzw. 0xA0 (Success) und ein Standardobjekt
zurückzugeben. Typische Responsecodes im Fehlerfall sind 0xC0 (bad request) und 0xC3
(forbidden).
2.3.5 Operation 'Abort'
Opcode 0xFF
Die Operation 'Abort' wird zur Beendigung einer Multi-Paket Operation verwendet. Dabei
muss sie jeweils in ein Request- bzw. Responsepaket passen. Wird als Responsecode nicht
0xA0 (success) zurückgegeben, so soll vom Client die Verbindung getrennt werden.
2.3.6 Operation 'SetPath'
Opcode 0x85
Die Operation 'SetPath' muss in einem Request als auch in einem Response in ein einziges
Paket passen, wobei das Final-Bit gesetzt ist. Dabei setzen sich die Requestpakete auf folgende Art zusammen:
Byte 0 Bytes 1, 2 Byte 3
0x85

Byte 4

Byte 5 - n

Paketlänge Flags Konstanten optionale Header

Dieser Befehl dient zum Verändern des aktuellen Verzeichnisses beim Empfänger, wobei der
Pfadname in einem Name-Header übertragen wird. Wird dieser Befehl vom Empfänger nicht
akzeptiert, so werden die Fehlermeldungen 0xC0 (Bad Request) oder 0xC3 (Forbidden) zurückgegeben. Danach kann der Client entscheiden, ob er mit der Ausführung weiterer Befehle
fortfahren will.
Bei den Flags in Byte 3 dürfen nur Bit 0 und 1 gesetzt werden. Alle anderen müssen auf 0
gesetzt werden. Dabei veranlasst ein gesetztes Bit 0 einen Wechsel in ein darüberliegendes
Verzeichnis (../) und ein gesetztes Bit 1 bewirkt, dass ein nicht vorhandenes Verzeichnis nicht
erzeugt wird, sondern eine Fehlermeldung zurückgegeben wird. Das Byte 4 ist zur Zeit vollständig reserviert und muss vom Sender auf 0 gesetzt und vom Empfänger ignoriert werden.
Wird ein leerer Namensheader mitgesendet, so bewirkt dies einen Wechsel in das Rootver-

143

Johannes Magauer

zeichnis. In diesem befindet man sich auch immer nach Erstellen einer neuen Verbindung.

2.4 Authentifizierungsprozedur
Diese Prozedur basiert auf den Headern 'Authenticate Challenge' und 'Authenticate Response'.
Es wird angenommen, dass der Client sowie der Server jeweils einen gemeinsamen, nur ihnen
bekannten Schlüssel besitzen, der nicht übertragen werden darf.
Um die Authentität des Servers festzustellen, sendet der Client den Header 'Authenticate
Challenge'. Dieser beinhaltet den 'Digest Challenge String' (siehe nächster Punkt). Als
Responsecode wird vom Server ein SUCCESS mit angehängtem 'Authenticate Response'Header gesendet. Dieser beinhaltet den 'Digest Response String' (übernächster Punkt). Der
Client generiert nun den 'Digest Request String' und vergleicht diesen mit dem erhaltenen
'Digest Response String' des Servers. Sind diese gleich so hat der Client den Server authentifiziert, ansonsten kann der Client die Verbindung abbrechen.
Der Server authentifiziert den Client auf dieselbe Weise. Wird vom Client eine Operation
aufgerufen, die eine Authentifizierung erfordert, so sendet der Server in einem Responsepaket
den Rückmeldecode 0xC1 (Unauthorized), und hängt den Header 'Authenticate Challenge' an
dieses Paket an. Die Authentifizierung erfolgt danach wie beim Client. Wird der Client nicht
erkannt, so werden alle Requestpakete mit UNAUTHORIZED beantwortet. Werden nur Operationen aufgerufen, die alle eine Authentifizierung erfordern, so ist es sinnvoll, sofort bei der
Ausführung der CONNECT Operation die Authentifizierungsprozedur durchzuführen.
2.4.1 Der Digest Challenge String
Der Digest Challenge String kann mehrere Felder enthalten. Die Länge des Digest Challenge
String ist dabei aber auf 255 Bytes beschränkt. Zur Codierung wird das Tag-Länge-Wert
Schema verwendet, wobei die Felder Tag und Länge jeweils 1 Byte lang sind. In folgender
Tabelle sind die Felder des Digest Challenge Strings beschrieben:
Tag

Name

Länge

Beschreibung

Default
Wert

0x00
0x01
0x02

Nonce
Options
Bereich

16
1
n

verschlüsselte Zeichenkette
optionale Informationen
Zeichensatz + User-ID + Passwort

0

Der Eintrag Nonce wird immer benötigt. Bei ihm ist es wichtig, dass er zu jeder Zeit einen
anderen Wert besitzt. Dazu wird ein String aus der aktuellen Uhrzeit und dem geheimen
Schlüsselwort zusammengesetzt. Dieser String dient anschließend als Eingabe in den HashAlgorithmus MD5 [IrOBEX],[Wohlfeil] der als Ausgabe eine 128 Bit lange Zeichenkette, den
sogenannten Nonce liefert.
Das Feld Options kann wahlweise gesendet werden. Bei gesetztem Bit 1 wird der Empfänger
aufgefordert, mit einer User-ID im 'Digest-Response' String zu antworten. Bei gesetztem Bit 2
ist nur Lesezugriff erlaubt, ansonsten wird R/W -Zugriff erlaubt. Die anderen Bits müssen auf
0 gesetzt sein und werden vom Empfänger ignoriert.
Das Feld Bereich kann ebenfalls optional benutzt werden. Damit kann eine User-ID und ein
Passwort übermittelt werden. Das erste Byte dieses Feldes dient dabei zur Anzeige des benutzten Zeichensatzes, wobei mit 0 der ASCII-Zeichensatz, mit den Werten 0 bis 9 die Zeichensätze ISO-8859-1 bis ISO-8859-9 und 0xFF = 255 der Zeichensatz UNICODE angegeben wird.
2.4.2 Der Digest Response String
Der Digest Response String kann mehrere Felder enthalten. Dazu wird wiederum das TagLänge-Wert Schema verwendet. In folgender Tabelle sind die Felder des Digest Response
Strings beschrieben:

144

Übertragung von Objekten mit OBEX

Tag
0x00
0x01
0x02

Name
Request-Digest
User-ID
Nonce

Länge
16
n
16

Beschreibung
Request-Digest String
User-ID als String; max. 20 Bytes
Der Nonce aus dem Digest Challenge String

Durch nochmaliges Anhängen des gemeinsamen Schlüssels an den Nonce des Digest
Challenge Strings und anschließender Eingabe in den MD5 Algorithmus wird der 128 BitWert des Request-Digest geliefert. Das Feld User-ID wird nur benötigt, falls Bit 1 im Feld
Options der Digest Challenge gesetzt ist. Das Feld Nonce wird hier optional gehandhabt.
Wurden mehrere 'Authenticate Challenge'-Header gesendet, so wird im Feld Nonce der dazugehörige Wert aus dem Request gesendet. Wird kein Nonce im Digest Response String gesendet, so gehört dieser String zum ersten 'Authenticate Challenge'-Header.

2.5 Multiplexing in OBEX
OBEX unterstützt 2 Arten von Multiplexing; dies sind: Multiplexing auf Kommando-Ebene
und Multiplexing auf Transportschicht-Ebene. Beim Multiplexing auf Kommando-Ebene
existiert nur ein OBEX-Parser und dieser wird von mehreren Anwendungen benutzt. Dabei
kann immer nur ein Befehl zur selben Zeit ausgeführt werden.
Das Multiplexing auf Transportschicht-Ebene basiert auf den Fähigkeiten der darunter liegenden Transportschicht. Hier besitzt jede Anwendung einen eigenen OBEX-Server. Abwechselnd kann dann jeder Server für eine kurze Zeitspanne die Verbindung nützen.

3 OBEX Application Framework
Das OBEX Application Framework ist eine Menge von Konventionen und Dienste die zur
Unterstützung der Zusammenarbeit von Geräten entworfen wurden. Nachfolgend sind die 3
wichtigsten angegeben.

3.1 Der Default OBEX Server
Dieser Dienst wird allgemein nur OBEX Server genannt. Die Standarddienste sowie andere
Anwendungen werden über diesen Server mittels IrMC (Infrared Mobile Communications
Protokoll) Anwendungen angesprochen [Welbers99]. Es kann nur eine Entität als Default
OBEX Server registriert sein; existieren mehrere Entitäten, so ist es unmöglich für andere
Geräte zwischen diesen zu unterscheiden.

3.2 Der Inbox Service
Eine Anwendung kann ein Verzeichnis auf einem Dateiverzeichnis eines PC's belegen. Dieses
Verzeichnis wird dann Inbox genannt. Mit den Befehlen PUT und GET wird auf diese Inbox
zugegriffen. Eine Inbox muss aber nicht unbedingt ein fixes Verzeichnis bzw. Ort sein. Es
kann auch anhand eines Type-Headers oder einer Namenserweiterung ein Objekt an eine besser passende Anwendung weitergeleitet werden.

3.3 Der Capability Service
Dieser Dienst wurde entworfen, um einen universellen Zugriff auf Serviceinformationen anzubieten. Es wird dazu eine Liste der unterstützten Objekttypen und deren Aufbau verwaltet.
Mit dem Befehl Put bzw. Get wird es Clienten ermöglicht, Informationen von Objekten registrieren, bzw. abrufen zu können. Dadurch können Objekte in verschiedenen Formaten wiedergegeben werden. Es können so z. B. Grafikobjekte im jpg oder im gif-Format angegeben
werden.

145

Johannes Magauer

4 Vordefinierte Objekte in OBEX
4.1 Das Objekt Dateiverzeichnis
Das Objekt Dateiverzeichnis wird durch die Extensible Markup Language (XML) spezifiziert
und in einem bzw. mehreren Body-Header übertragen. Dabei besteht ein solches Datei-verzeichnis aus einer Menge verschiedener XML-Elemente. Ein Client kann mittels einem Verzeichnis-Browsers durch die Ordner suchen und mit dem GET-Befehl den Inhalt auslesen.
4.1.1
•
•
•
•

Elemente eines Dateiverzeichnisses
file: zeigt die Existenz eines Files innerhalb dieses Ordners an
folder: zeigt die Existenz eines Ordners innerhalb dieses Ordners an
parent-folder: beschreibt die Existenz des darüberliegenden Ordners
folder-listing: ist der document type

4.1.2 Attribute die in den Elementen eines Dateiverzeichnisses benutzt werden
•
name: ist der Name des Ordners oder Files. Er beinhaltet keine Pfadinformationen
•
size: Objektgröße
•
modified: Datum der letzten Änderung (wenn möglich im UTC-Format)
•
created: Erstellungsdatum
•
accessed: letztes Zugriffsdatum
•
user-perm; group-perm; other-perm: Zugriffsrechte für User; Group; Other
•
owner: zeigt den Benutzer an
•
group: zeigt die Benutzergruppe an, falls diese Eigenschaft unterstützt wird
•
type: gibt den MIME-Type des File-Objektes an
•
xml:lang: beschreibt die Sprache, in der die Attribute und deren Inhalt angegeben werden; der Default-Wert Englisch (us-EN) muss nicht angegeben werden.
•
version: gibt die benutzte DTD (Document Type Definition) an und wird nur im Element
'folder-listing' benutzt.
4.1.3 Details zum Objekt Dateiverzeichnis
• Damit man nicht mit einer Fülle von Daten überflutet wird, wenn ein kleines Gerät
Requests an größere Geräte stellt, soll man ein Verzeichnisprofil beim Capability Service
des Servers unter dem Namen "x-obex/folder-listing" registrieren. Dieses Objektprofil ist
ein leeres XML Verzeichnis-Objekt. In diesem Objekt werden alle unterstützten Elemente und Attribute in ihrer regulären Form, aber ohne Werte eingetragen. Wenn ein
PDA das Verzeichnis eines Desktop-Rechners durchsehen will, und zum Beispiel als
Antwort nur eine Liste der vorhandenen Files und Ordner inklusive deren Größe erhalten
will, dann erreicht man dies durch folgendes Verzeichnisprofil:
Operation Header
PUT
Name
Type

Body

Content
x-obex/folder-listing
x-obex/object-profile
<?xml version="1.0"?>
<!DOCTYPE folder-listing SYSTEM "obex-folder-listing.dtd">
<folder-listing version="1.0">
<parent-folder />
<folder name="" size="" />
<file name="" size="" />
</folder-listing>

146
•
•

Übertragung von Objekten mit OBEX
Ein Requestpaket an ein Dateiverzeichnis muss den Type-Header "x-obex/folder-listing"
beinhalten. Dieser Header ist nicht Case-sensitive. Im Responsepaket muss dieser dagegen nicht übertragen werden.
Wird ein Request an ein leeres Verzeichnis gestellt, so soll der Antwortcode SUCCES
mit einem gültigen leeren XML Objekt zurückgegeben werden, wie das folgende Beispiel zeigt:
<?xml version="1.0"?>
<!DOCTYPE folder-listing SYSTEM "obex-folder-listing.dtd">
<folder-listing version="1.0"/>

•

Ein gültiger Body-Header eines Responsepakets auf eine Verzeichnisabfrage kann folgende Form aufweisen:
<?xml version="1.0"?>
<!DOCTYPE folder-listing SYSTEM "obex-folder-listing.dtd">
<folder-listing version="1.0">
<parent-folder />
<folder name="System"/>
<folder name="IR Inbox"/>
<file name="Jumar.txt" size="6672">Jumar Handling Guide</file>
<file name="Obex.doc" type = "application/msword">IrOBEX Specification v1.0</file>
</folder-listing>

4.2 Das generische File Objekt
Will man eine neues File Objekt versenden, so ist dazu das Senden der Header 'Name' und
'Body/End-of-Body' zur Übertragung erforderlich. Weiters wird empfohlen die Header
'Length' und 'Time' zu übertragen. Der Header Type kann dabei optional verwendet werden.
Der gesendete Header 'End-of-Body' zeigt das Ende des Files an. Alle dazwischen gesendeten
Teile werden zur übertragenen Datei zusammengehängt.

4.3 Das 'Capability Object'
Das Objekt Capability wird durch die Extensible Markup Language (XML) spezifiziert. Dadurch wird das problemlose Hinzufügen von benutzerdefinierten Elementen ermöglicht. Ein
solches Capability Object besteht aus mehreren Sektionen. In der Sektion <General> müssen
die Einträge <SN>, <Manufacturer> sowie der Eintrag <Model> vorhanden sein. Mit dem
Eintrag <SN> wird die vom Erzeuger eindeutig zugeordnete Seriennummer bezeichnet. Der
Eintrag <Manufacturer> muss den vollen Namen des Erzeugers beinhalten, und der Eintrag
<Model> muss den Modellnamen angeben. Die folgenden Elemente können zusätzlich in der
<General> Sektion angegeben werden, und zwar sind dies:
• Firmware Version / Date
• OEM
• Software Version / Date
• Hardware Version / Date
Weiters gibt es eine Sektion <Inbox-Objects>. Darin werden die Objekttypen angegeben, die
in der Inbox des Geräts gespeichert werden können. Ein Objekt wird darin entweder durch
einen MIME-Typen oder durch die Namensextension angegeben. Es wird jedoch empfohlen
beide Attribute anzugeben. Das UUID-Attribut kann zusätzlich noch optional angegeben
werden.
Die nächste Sektion des Capability Objects ist die Sektion <Service-Objects>. In diesem Teil
werden die Objekttypen angegeben, die bei Ausführung von Services benötigt werden und
nicht in der Sektion <Inbox-Objects> angegeben wurden.

147

Johannes Magauer

Eine weitere Sektion ist durch <Services> gegeben. Darin werden die angebotenen Dienste
anhand der UUID aufgelistet. Zusätzlich können Informationen über den angebotenen Dienst
angegeben werden. Die Zugriffsmethoden können durch die Einträge Endpoint, Target sowie
Protocol angegeben werden. Der Eintrag Endpoint gibt den Verbindungspunkt für einen
Klienten an. In IrDA ist der Endpoint mit TinyTP LSAP-SEL identisch [Latuske]. In TCP
wird eine Portnummer angegeben. Der Eintrag Protocol gibt das für die Verbindung benützte
Transport-Protokoll an. Gültige Werte sind "TCP" und "IrDA".
Durch Senden eines Get-Befehls mit dem MIME-Typen "x-obex/capability" als Type-Header
an den Server kann das Capability Objekt abgerufen werden.

Literatur
[IrDA]

IrDA - ein Protokoll zur Datenübertragung mit Infrarotlicht,
Rudi Latuske, ARS Software GmbH,
Starnberger Str. 22, 82131 GAUTING/München, Juni, 1998

[IrOBEX]

IrDA Object ExchangeProtocol IrOBEX,
Counterpoint Systems Foundry, Inc Microsoft Corporation,
March 18, 1999, Version 1.2

[Latuske]

Rudi Latuske: USB (Universal Serial Bus), IEE1394 (Firewire), IrDA (Infrared Data
Association) und Bluetooth für embedded Systeme,
ARS Software GmbH

[Welbers99]

Protokolle zur schnurlosen Kurzstreckenkommunikation -IrDA & Bluetooth -
Andreas Welbers, Aachen, Oktober 1999

[Wohlfeil]

Sicherheit im Internet,
Kurs 1866, FernUniversität - Gesamthochschule in Hagen,
Autor: Stefan Wohlfeil

149

Index

A
Access Burst 27
Access Networt Domain 44
Adaptiven Rahmensynchronisierung 30
AGCH/PCH 28
Algorithmus A3 16
Algorithmus A5 17
Algorithmus A8 17
AND 44
ARQ 13
ARQ-Verfahren 5
A-Schnittstelle 12
AUC 7
Authentication Centre 7
Authentifizierungsschlüssel 16
Automatic Repeat Request 13
B
Base Control Function 10
Base Station Controller 7
Base Station System Application Part 15
Base Station System Management
Application Part 15
Base Transceiver Station 7
Base Transceiver Station Identity Code 8
Basisstation 7, 38
Basisstationen 6
BCCH 28
BCF 10
beacon 61
bearer 60
bearer services 5
binäre WML 95
Blockcodierung 29
BSC 7
B-Schnittstelle 12
BSIC 8
BSSAP 15
BSSMAP 15
BTS 7
Burst 25
C
CA 10
Card 97
CBCH 29

CC 33, 64
CCH 28
CDMA 40
Cell Allocation 10
Cell Identifier 8
CEPI 32
CGI-Scripting 84
Chiffrierungsschlüssel 17
CI 8
Circuit Switched Domain 45
CLMS 64
CM 14
CND 44
Codemultiplex-Verfahren 40
Codespreizung 40
COMS 64
Connection Management 14
Core Network 45
Core Network Domain 44
C-Schnittstelle 12
D
DCA 58
Deck 96
DECT 53
Digital Enhanced Cordless
Telecommunications 53
Direct Transfer Application Part 15
DLC-layer 62
Document Type Definition 131
Downlink 24
D-Schnittstelle 12
DTAP 15
DTD 131
Dummy Burst 27
Duplication Avoidance 48
dynamic channel allocation 58
E
EDGE 19, 21, 49
EIR 7
Enhanced Data Rates for GSM Evolution
19
Equipment Identity Register 7
E-Schnittstelle 12
ETSI 23
European Telecommunications Standards
Institute 23

150

Index

externer Handover 18

Hyperframe 25

F
FACCH 27
Faltungscodierung 29
FCCH 28, 30
FDD 41
FDMA 24
FDMA/TDMA 23, 24
FEC 5, 13
FPLMTS 49
Frequency Correction Burst 26
Frequency Division Multiple Access 24
frequency hopping 10
Frequenzsprungverfahren 25
Frequenzwiederholabstand 6
F-Schnittstelle 12
Funkschnittstelle 38
Funkschnittstelle von GSM 23
Future Public Land Mobile
Telecommunication System 49
G
GAP 53
Gateway GPRS Support Node 45
Gateway MSC 7
Gaussian Minimum Shift Keying 25
General Packet Radio Service 19, 45
Generic Access Profile 53
GGSN 45
GMSC 7, 13, 45
GMSK-Modulation 25
GPRS 19, 20, 45
G-Schnittstelle 12
GSM 5, 23
H
Handover 6, 15, 18
Handover-Vorbereitungen 33
HDLC 13, 31
High Speed Circuit Switched Devices 19
HLR 7
HND 44
Home Location Register 7
Home Network Domain 44
HSCSD 19
HTML 93
HTTP 83, 133, 139

I
IAS 74
ID Hopping 9
IMEI 9, 133
IMSI 9
IMT-2000 37
Interleaving 29
International Mobile Equipment Identity 9
International Mobile Subscriber Identity 9
International Mobile Telecommunication
2000 37
international portable user identity 66
International Switching Centre 7
interner Handover 18
Inter-Zell-Handover 18
Intra-Zell-Handover 18
IPUI 66
IrCOMM 75
IrDA 71
IrDa Data 74
IrDA DATA 71
IrDA Lite 75
IrDA Tranceiver 77
IrLAN 75
IrLAP 74
IrLMP 74
IrMC 75
IrOBEX 75
IrTran-P 75
ISC 7
IWF 5, 13
J
Java Intelligent Network Infrastructure
115
JavaSpaces 126
Jini 115
JVM 115
K
Kanalmultiplex 27
L
LA 8
LAI 8

151

Johannes Magauer

LAPDm-Sicherungsprotokoll 31
Leasing 120
LMT 11
Local Maintenance Terminal 11
Location Area 8
Location Area Identity 8
Location Update 8
Luftschnittstelle 12
M
MAP 15
MD5 145
Measurement Reports 25
Minimum-Shift-Keying 25
MM 14, 33, 64
Mobile Application Part 15
Mobile Station Roaming Number 9
Mobile Subscriber ISDN Number 9
Mobile Switching Centre 7
Mobile-services Switching Centre 45
Mobility Management 14
Mobilstation 7, 24, 38
MS 7, 24
MSC 7
MSISDN 9
MSK 25
MSRN 9
Multiframes 25
N
Network Subsystem 9
Netzübergangsvermittlungsfunktion 5
Normal Burst 26
NSS 10
NWK-layer 63

Packet Switched Domain 45
PAD 13
Phasenmodulation 25
PHY 74
PLMN 7
PN 41
portable user number 66
portable user type 66
Power Control 33
PPP 95
Pseude Noise 41
PSPDN 13
Public Land Mobile Network 7
PUN 66
Push-Funktionalität 87
PUT 66
Q
QoS 40
QoS-Klassen 40
Quality of Service 40
R
radio fixed part 54
Radio Link Protocol 5, 13
Radio Resource Management 14
Radio Subsystem 9
RFP 54
RLP 5, 13
RMI 116
RR 14, 33
RSS 9
RXLEV 33
RXQUAL 33
S

O
OBEX 139
OMC-R 11
OMC-S 11
OMS 10
Operation and Maintenance Subsytem 9
P
Packed Switched Domain 45
Packet Assembler/Disassembler 13
Packet Data Convergence Protocol 48

SACCH 27, 29
SAP 31
SAPI 31
SCH 28, 30
SDCCH 28
Sendeleistungsregelung 33
Service Access Point 31
Serving GPRS Support Node 45
Serving Network Domain 44
SGSN 45
Short Message Service 14
Signalisierung SS#7 14

152

Index

Signal-Störabstand 6
SIM 9, 43
SMS 14, 33
SS 14, 33, 64
SSL 85
Subscriber Identitiy Module 9
Superframes 26
supplementary services 5
Supplementary Services 14
Sync Anchor 131
Sync Client Agent 130
Sync Server Agent 130
Synchronization Burst 26
Synchronization Markup Language 129
SyncML 129

Universal Mobile Telecommunication
System 37
Uplink 24
user authentication key 67
User Services Identity Module 43
USIM 43
UTRAN 39, 44, 46
V
vCalendar 86
vCard 86
Virtual Home Environment 38
Visitor Location Register 7, 45
VLR 7, 45
Vorwärtsfehlerkorrektur 5, 13

T
TCH 27
TDD 39, 57
TDMA 57
TDMA Rahmen 25
Telekommunikationsdienste 5
Telematikdienste 5
teleservices 5
Temporary Mobile Subscriber Identity 9
Time Division Duplex 39
Time Division Multiple Access 24
Tiny TP 75
TLS 85
TMSI 9
TND 44
Träger 60
Trägerdienst 5
Trägerdienste 5
Transaktion 123
Transcoding and Rate Adaptation Unit 13
Transmit Network Domain 44
TRAU 13
Two-Phase-Commit-Protocol 123

W
WAE 83, 85
WAP 37, 81
WAP-Forum 81
WAP-Gateway 83, 95
WAP-Proxy 83
WBMP 86, 94
WBXML 83, 95
WCDMA 38
WDP 85, 89
Wireless Application Protocol 81
WML 85, 93
WML User Agent 83
WSP 85, 86
WTLS 85, 90
WTP 88
WWW 82
X
X.25-Paket 13
XML 94
Z

U
UAK 67
UDP-Multicast 118
UMTS 21, 37, 93

Zeitmultiplex 27
Zellen 6
Zusatzdienste 5

